{"componentChunkName":"component---src-templates-post-jsx","path":"/mysql-primary-key-design/","result":{"data":{"site":{"siteMetadata":{"title":"@Soo"}},"markdownRemark":{"id":"521d39b1-1b0f-58ed-98fd-4c9acece72d3","excerpt":"Primary Key 설계의 중요성 InnoDB 기준으로 MySQL은 Primary Key를 기준으로 데이터를 클러스터링한다. \n클러스터링이라는 용어는 인접한 키 값이 있는 레코드가 물리적으로도 인접하게 저장된다는 것을 말한다.\n즉, 논리적인 PK 값에 의해 레코드의 물리적인 위치가 결정된다.\nPK값이 변경된다면 해당 레코드의 물리적인 위치도 변경된다는 …","html":"<h2>Primary Key 설계의 중요성</h2>\n<p>InnoDB 기준으로 MySQL은 Primary Key를 기준으로 데이터를 클러스터링한다.\n클러스터링이라는 용어는 인접한 키 값이 있는 레코드가 물리적으로도 인접하게 저장된다는 것을 말한다.\n즉, 논리적인 PK 값에 의해 레코드의 물리적인 위치가 결정된다.\nPK값이 변경된다면 해당 레코드의 물리적인 위치도 변경된다는 얘기다.   </p>\n<p>모든 데이터베이스가 마찬가지겠지만 MySQL의 PK 설계는 다른 데이터베이스보다 더 중요하다고 볼 수 있다.\n왜냐하면, 일부 데이터베이스에서는 클러스터링할 인덱스를 선택할 수 있지만 MySQL은 기본키로 고정되어 변경할 수 없다. (MySQL 8.x 기준)<br>\n또한, MySQL은 Secondary Index의 Leaf Node에 오라클과 같이 물리적 위치에 대한 참조(ROWID)가 아닌 PK 값을 저장하고, PK 인덱스를 통해 실제 디스크 블록에 접근한다. 따라서, MySQL에서 PK 는 단순히 데이터를 식별하기 위한 식별자 역할뿐만 아니라 내부 구현에도 관여하기 때문에 그 중요성은 매우 크다고 볼 수 있다.</p>\n<h2>클러스터형 인덱스</h2>\n<p>고성능을 위한 Primary Key 를 설계하기 위해서는 Primary Key 의 저장 구조인 클러스터형 인덱스에 대한 이해가 필요하다.\n아래의 그림은 Secondary Index <strong>(Non-Clusted Index)</strong> 와 Primary Key Index <strong>(Clusted Index)</strong> 의 저장 구조를 나타낸다.   </p>\n<p>Secondary Index <strong>(Non-Clusted Index)</strong> 그림의 리프 노드를 보면 Index Key 값에 해당 하는 Primary Key 값을 저장하고 있는 것을 볼 수 있다.\nIndex Key 값은 정렬되어 있지만 Index Key 값에 맵핑되는 Primary Key들 사이에는 아무런 순서관계가 없다.</p>\n<p>Primary Key Index <strong>(Clusted Index)</strong> 그림의 리프 노드는 Index Key 값 기준으로 정렬되어 있고,\n참조가 아닌 실제 레코드를 저장하는 페이지가 리프노드에 위치해 있다. 페이지 내에서도 Primary Index Key 값 기준으로 레코드가 물리적으로 정렬되어 있다.</p>\n<!-- more -->\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/a67dad59e6a37da0b5730238ef926ae2/f97d7/index-tree.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 72.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACDElEQVR42p2Ta2+iQBiF/f//Zj/sl00v2nQ3rbV1d1vXFRURQQXkLggjcPYwpU3TaGt2kjckM8zzXs6ZFt4tz7axms0QBcHrXlVVMk5ZLXmhLJ9hvo/QsZHYFubTKVzXfQWeuiRw67mwxmO4jgOx38uDXZbBNU1EqyV87qe73WnA9WoFQ5tB+zuEuVgg2W7lgW1ZMNj6gommioJdmp4GnPR62MxURJoKY/AI8/E3/MkYPvfssYLINGApI6TLJTwmyYX4GFgUBQq2I1hBXe1gMEDAWYokQckzKQhnXDAyjkEQWDYzPy4KYVb3BlrnEqsf19AuzhCNhrUaEvYCDSiWvdAR+t5RB0gg0gThdRvOxTeUD12E7TOI4RMqClTlOcBKXVYfW2vkgQ+Vcw3D8KADJLDM2QovZmynjpwAwSQyF6vRKZizXqNsLqfsyNZ1BJyvW9vsjWCtJo2somLIb20d7hm8ZKgqdKpszOdI4lj+brFaU9MwH40wYWyj6B3w7Wqq2NGbk34fG3WKZGli3n+ActeFN1EQEL6h1WIq79BaKat3+cKE2B8AvnCLPUq2X1DZPI5gGAb+DJ4QMJHYxijZRbkXsquqVr5xROszo5a0lH9/C+fuBvpVG3r7HM6vn0ef5AfA558rAsOrS8TfO9h0zmF+/QKvd/s/wKZCtpbyOWY5HZDl8o3nzfM8ZOx/bpOGDyoIltcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img.png' title='' src='/static/a67dad59e6a37da0b5730238ef926ae2/ca1dc/index-tree.png' srcset='/static/a67dad59e6a37da0b5730238ef926ae2/e7570/index-tree.png 170w,\n/static/a67dad59e6a37da0b5730238ef926ae2/f46e7/index-tree.png 340w,\n/static/a67dad59e6a37da0b5730238ef926ae2/ca1dc/index-tree.png 680w,\n/static/a67dad59e6a37da0b5730238ef926ae2/02d09/index-tree.png 1020w,\n/static/a67dad59e6a37da0b5730238ef926ae2/9d567/index-tree.png 1360w,\n/static/a67dad59e6a37da0b5730238ef926ae2/f97d7/index-tree.png 2000w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>img.png</figcaption>\n  </figure></p>\n<p>Clusted Index는 구조적인 이유로 순차적인 Key 값을 넣을 때, 오버헤드가 가정 적고 가장 빠르다. 단순히 Index 트리 오른쪽 맨끝에 새로운 레코드를 삽입해주기만 하면 된다.<br>\n반면에 비순차적인 Key 값이 들어오게 되면 상황이 복잡해진다. Key 값이 기존 데이터 중간에 삽입될 수 있으므로 트리 구조를 변경사항에 맞게 갱신해야 한다.<br>\n또한, 리프 노드의 페이지 안에 있는 데이터의 순서도 조정이 필요하다. 기존 데이터 사이에 새 레코드의 적절한 위치를 찾고 공간을 확보해야 한다. 이로 인해 많은 데이터의 이동이 필요할 수 있고 페이지 분할로 단편화 문제가 발생할 수 있다.</p>\n<p>따라서 INSERT 속도가 중요한 테이블이라면 순차적인 값을 Primary Key로 선정하는 것이 유리하다.</p>\n<h2>Primary Key 유형</h2>\n<h3>자동 증가 (Auto Increment) Primary Key</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>Primary Key 채번을 DB에 위임하므로 관리 포인트가 줄어든다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>테이블의 대량 INSERT 작업 시, Auto Increament 에서 병목현상이 발생할 수 있다.</li>\n</ul>\n<h3>UID</h3>\n<p>클러스터형 인덱스 구조를 이해하면, UUID와 같은 랜덤 값이 Primary Key로 선정될 경우, 레코드 클러스터링에 필요한 오버헤드만 발생하고 크게 이점이 없음을 알 수 있다.\n그러나 랜덤 UID가 아닌 순차적인 UID를 생성하면 Auto Increment의 병목현상과 클러스터링 오버헤드를 모두 피할 수 있다.\n순차적인 UID는 (현재시각 + 일련번호) 또는 (epoch time + 일련번호)와 같은 조합으로 순서를 유지하는 UID를 만들 수 있다.</p>\n<p><strong>장점 (Sequential UID)</strong></p>\n<ul>\n<li>대량 INSERT 작업을 매우 빠르게 처리할 수 있다.</li>\n</ul>\n<p><strong>단점 (Sequential UID)</strong></p>\n<ul>\n<li>클라이언트에서 순차적인 UID를 만들기 위해 관리가 필요하다.</li>\n</ul>\n<h3>Composite key</h3>\n<p>논리 모델링과 물리 모델링의 격차가 적고, 사람이 이해하기 쉽다. 중복키 값이 들어올 수 있으므로 동시성 관리가 필요하다.</p>\n<p><strong>장점</strong></p>\n<ul>\n<li>공간적 지역성(Spatial Locality) 를 활용할 수 있다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>클라이언트에서 채번에 대한 동시성 관리가 필요하다.</li>\n</ul>\n<h2>대리키와 복합키 비교</h2>\n<p>Auto increament 와 UID 를 이용한 기본키 유형은 대리키로 일반화할 수 있다. Primary Key를 대리키로 구성한 방식과 복합키로 구성한 방식의 차이점을 비교해본다.</p>\n<h3>부모테이블의 기본키를 자식 테이블의 기본키로 쓰지 않고, 외래키로 사용하는 경우 (비식별관계)</h3>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/1f5e3d12fa6da564430f23e5ca41b243/b72ad/mysql_img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 27.647058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAy0lEQVR42pVQywqEMAzs//+aR0HB10FBREVsfT9ndwJZxNsGhrbJZKaJwR9xnheO4/iep+C+b8lf1/WDIeGZIOn51hzDWoe+77HvO5ZlQRzHCMMQzjnM84xhGGC6rpMiUVUVsiyT+ziOmKZJyBRlkBtFEXzfh+d5SNNUDJQrgkEQIM9zEWGztVaKBF2bppEG1ouiQJIkIlTXNdZ1lRVs2yYgx7RtK4Ja5DgKvunKfTEoTNOyLOX+Dtmh/kbHfoO/1B3SlAY6ImtPMPcB2IbQKDoxQukAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_1.png' title='' src='/static/1f5e3d12fa6da564430f23e5ca41b243/ca1dc/mysql_img_1.png' srcset='/static/1f5e3d12fa6da564430f23e5ca41b243/e7570/mysql_img_1.png 170w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/f46e7/mysql_img_1.png 340w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/ca1dc/mysql_img_1.png 680w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/02d09/mysql_img_1.png 1020w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/b72ad/mysql_img_1.png 1242w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_1.png</figcaption>\n  </figure></p>\n<p>Post, Comment 테이블 둘 다 Auto Increament 기본키를 사용하고, Comment 테이블에 post_id FK 를 두어 Post와 연관관계를 맺는 방식이다.\nPost 테이블이 Driving Table이고 Comment 테이블이 Driven Table 인 경우 두 테이블을 조인하게 되면 아래 그림와 같은 방식으로 데이터를 탐색하게 된다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/78873/mysql_img_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 58.235294117647065%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABJ0lEQVR42o2Sy4qGMAxG//d/NhfiQpcq4kJExfvdDCeQ4vyMOIUQ26QnX2I/8rC2bZNxHKXrOvXYuq4ufl2XnmVZJnEcS13XeufzBKyqSnzflzAMJQgC8TxP8jx38eM4pCgKSZJEjVjf938DqU6QqsMwSFmWauyJGRBDddu2+v2o8DxPmaZJk+d5VuiyLHp2B+77rnHGAuwVCIg5oRbP/htoCvl+BVIdDxCF30DOgP1q2aqwuQO5TCKwpml0hrRmQCvGfdQ7hfyhKIokTVOXfG8ZD4i/zp4YF1GHKuL8LKeQA4wqHLKoZvOzlgECBkRhmyEQch3Qhm2Pl1bwtGtAQLQMGAgqLc9G41qmIkGMWRKw54DZczF1XDJ1eHJe3+F/lqlEBIXMfgDl9Kcs3J4rhwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_2.png' title='' src='/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/ca1dc/mysql_img_2.png' srcset='/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/e7570/mysql_img_2.png 170w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/f46e7/mysql_img_2.png 340w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/ca1dc/mysql_img_2.png 680w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/02d09/mysql_img_2.png 1020w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/9d567/mysql_img_2.png 1360w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/78873/mysql_img_2.png 1520w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_2.png</figcaption>\n  </figure></p>\n<p>조인 연산을 수행하기 위해, Post 테이블의 기본키와 연결된 Comment 테이블의 Post<em>id 값으로 조인이 이루어진다. Comment 테이블의 post</em>id에는 이미 인덱스가 생성되어 있기 때문에, Index Range Scan을 사용하여 Post 테이블과 Comment 테이블을 맵핑할 수 있다.</p>\n<p>그 다음 단계에서는 SELECT 결과를 가져오기 위해 Comment 테이블의 레코드를 검색한다. 이 과정에서 Comment 레코드의 탐색을 위해 Random I/O가 발생하게 된다. Comment 테이블의 POST<em>ID</em>IDX 인덱스는 POST<em>ID별로 정렬되어 있어 같은 POST</em>ID를 가지더라도 COMMENT_ID는 멀리 떨어져있는 값을 가질 수 있다.</p>\n<p>예를 들어 위의 그림에서, Post 테이블에서 id=3인 레코드를 조회하면, Comment 테이블의 post_id와의 조인 결과로 Comment id (100, 200)이 반환된다. 페이지 당 50개 레코드가 저장된다고 가정하면 2개의 Comment 레코드를 가져오기 위해 총 2개의 페이지 읽기 작업이 필요하게 된다.</p>\n<h3>부모테이블의 기본키를 자식 테이블 기본키에 포함하는 경우 (식별관계)</h3>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/dc6ee2a60d393df21fcb393cd6e4ecdc/abff7/mysql_img_3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 29.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAx0lEQVR42pVR2QqEQAyb//8+QXxwwAtXZEbxdjyypFBZfNtCcChJmlaDP2rbNuz7jhACxnFE13VY11V6xHmeMErid1kWDMMgbwXFrOM44JwXDvlFUSCOY/R9L71pmgSmrj8yiWLvPbIse8yVqIZt2yJNU1hrcV2X9O/7fsC0hgZJkmCe5ye+mhHOORnAJE3TIM9zRFGEqqrEhMZqSL6hEUU04w24ItMomJBkmnITGpVlKQHekJX1oHrHN2iqxWEUUcz3r1Z/yhfJf9Dl20Hy0wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_3.png' title='' src='/static/dc6ee2a60d393df21fcb393cd6e4ecdc/ca1dc/mysql_img_3.png' srcset='/static/dc6ee2a60d393df21fcb393cd6e4ecdc/e7570/mysql_img_3.png 170w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/f46e7/mysql_img_3.png 340w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/ca1dc/mysql_img_3.png 680w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/02d09/mysql_img_3.png 1020w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/abff7/mysql_img_3.png 1267w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_3.png</figcaption>\n  </figure></p>\n<p>두번째 예에서는 Comment가 POST의 ID를 자신의 기본키에 포함시킨 Composite Key로 PK를 구성한 예이다. 마찬가지로 아래는 Post 테이블이 Driving Table이고 Comment 테이블이 Driven Table 인 경우 두 테이블을 조인할 때, 데이터 탐색 방식이다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/fdb57c196b73d47622224329f6014673/f0e87/mysql_img_4.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 57.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABJUlEQVR42nWS2QqEMAxF5///T3xQQV8UEfd9zXA6xOk4WgitTXq8N+1LHsZxHLKuq0zTJPM8y7ZtZs8e5LMskziOpWkak389waqqkiAIxHVdcRxHPM+Tuq5P6L7vBsQ+NWEYSlmW90AGySRJDJg5iiLJ8/wHiEKUD8NwurkFUtx1nYzjaKxwQIOcDaSGn7OmNY+W27Y1gU1mlPZ9/wcEAnBZlg/w2mgFchgLwFDB+grEripk/QO0wQrEIkDWKLyzDIj8adn3fSHSNP3rIQGQmQu5AgGQK4riq5Ae0XgSWqwKCVUIkJmDqFGQ5k+FwAgS+ohZ0xf2scq31untU8tFAELUqVCfg6phkwMc1H2+tQ4AQ5Xaz8a8Q+xpXG/6Luw+A7B/SrwBZvWna8XSdDQAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_4.png' title='' src='/static/fdb57c196b73d47622224329f6014673/ca1dc/mysql_img_4.png' srcset='/static/fdb57c196b73d47622224329f6014673/e7570/mysql_img_4.png 170w,\n/static/fdb57c196b73d47622224329f6014673/f46e7/mysql_img_4.png 340w,\n/static/fdb57c196b73d47622224329f6014673/ca1dc/mysql_img_4.png 680w,\n/static/fdb57c196b73d47622224329f6014673/02d09/mysql_img_4.png 1020w,\n/static/fdb57c196b73d47622224329f6014673/9d567/mysql_img_4.png 1360w,\n/static/fdb57c196b73d47622224329f6014673/f0e87/mysql_img_4.png 1554w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_4.png</figcaption>\n  </figure></p>\n<p>첫번째 방식과 유사하게, 조인이 발생했을 때 Comment 레코드를 읽어오기 위해 페이지 3을 두 번 참조하게 되지만, 이 경우 페이지 3은 이미 캐싱되어 있으므로 두 번째 참조는 추가적인 I/O를 발생시키지 않는다.</p>\n<p>두 방식에서 논리적 페이지 I/O는 2로 동일하지만, 물리적 페이지 I/O(캐시 적용 시)는 각각 2와 1로 다르다. 조인되는 데이터가 많아질수록 두 방식 사이의 물리적 I/O 차이는 더욱 커지게 된다.</p>\n<p>이러한 결과는 두 번째 케이스에서 식별관계를 사용해 기본키를 복합키로 구성했기 때문에 발생한다. POST<em>ID를 기준으로 조인을 수행할 때, 공간적 지역성(Spatial Locality)의 원리가 적용되었다고 볼 수 있다. 특정 Post에 속한 Comment 집합은 같은 논리적 영역에 속하는 인스턴스라고 볼 수 있다. POST</em>ID와 COMMENT<em>ID로 클러스터링하면, 물리적으로도 POST</em>ID에 속한 COMMENT 집합이 유사한 영역에 위치하게 되므로 캐싱 확률이 높아지게 된다.</p>\n<p>실제로 같은 페이지 번호에 저장되어 있는 레코드를 탐색하기 위해서 몇번의 I/O가 발생했는지 확인하기 위해서는 MySQL에서 제공하는 상태 변수 중 Innodb<em>buffer</em>pool_reads 값을 확인하여 물리적 I/O 발생량을 확인할 수 있다. 해당 상태변수는 버퍼풀에서 읽지못하고 디스크에서 직접 읽은 수를 의미하는 변수이다.</p>\n<h4>데이터를 읽기 전에 Innodb<em>buffer</em>pool_reads 값</h4>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">mysql<span class=\"token operator\">></span> SHOW <span class=\"token environment constant\">SESSION</span> STATUS LIKE <span class=\"token string\">'Innodb_buffer_pool_reads%'</span><span class=\"token punctuation\">;</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Variable_name            <span class=\"token operator\">|</span> Value <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Innodb_buffer_pool_reads <span class=\"token operator\">|</span> <span class=\"token number\">1652</span>  <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token number\">1</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin class-name\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.03</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<h4>멀리 떨어진 두 개의 Record를 두 건 읽는 경우 (레코드의 페이지가 다른 경우)</h4>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> *\n-<span class=\"token operator\">></span> from <span class=\"token variable\"><span class=\"token variable\">`</span>MARKETBOM2_SCHM<span class=\"token variable\">`</span></span>.BIZ_SLIP_TRADE\n-<span class=\"token operator\">></span> where BIZ_SLIP_TRADE.TRADE_SLIP_NO <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2000,3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nSHOW <span class=\"token environment constant\">SESSION</span> STATUS LIKE <span class=\"token string\">'Innodb_buffer_pool_reads%'</span><span class=\"token punctuation\">;</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Variable_name            <span class=\"token operator\">|</span> Value <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Innodb_buffer_pool_reads <span class=\"token operator\">|</span> <span class=\"token number\">1654</span>  <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token number\">1</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin class-name\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.04</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>PK가 2000, 3000 인 레코드 두 건을 읽었을 떄 Innodb<em>buffer</em>pool_reads 변수가 1652 → 1654 로 증가된 것을 확인할 수 있다. 2번의 Disk I/O가 발생하였다.</p>\n<h4>클러스터링으로 인접한 Record를 두 건 읽는 경우 (레코드 페이지가 같은 경우)</h4>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> *\n-<span class=\"token operator\">></span> from <span class=\"token variable\"><span class=\"token variable\">`</span>MARKETBOM2_SCHM<span class=\"token variable\">`</span></span>.BIZ_SLIP_TRADE\n-<span class=\"token operator\">></span> where BIZ_SLIP_TRADE.TRADE_SLIP_NO <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5000,5001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmysql<span class=\"token operator\">></span> SHOW <span class=\"token environment constant\">SESSION</span> STATUS LIKE <span class=\"token string\">'Innodb_buffer_pool_reads%'</span><span class=\"token punctuation\">;</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Variable_name            <span class=\"token operator\">|</span> Value <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Innodb_buffer_pool_reads <span class=\"token operator\">|</span> <span class=\"token number\">1655</span>  <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token number\">1</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin class-name\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>PK가 5000, 5001 인 레코드를 두 건 읽었을 때 Innodb<em>buffer</em>pool_read 변수가 1654 → 1655 로 증가된 것을 확인할 수 있다. 아까와 같이 레코드를 두 건 읽었지만 실제 Disk I/O 발생량은 1번인 것을 확인할 수 있다.</p>\n<h2>정리</h2>\n<p>MySQL의 고성능 Primary Key 설계를 위해서는 클러스터링 인덱스의 특성을 이해하고 테이블의 주 용도 및 액세스 패턴을 정확히 파악해야 한다.</p>\n<p>쓰기 중심의 작업에서는 순차적 ID를 사용하여 성능을 최적화할 수 있다. 이는 쓰기 작업 시 디스크 I/O를 효율적으로 하기 위함이다.</p>\n<p>읽기 중심의 작업에서는 Random I/O가 주로 발생한다면 대리키를, Join 많이 걸리거나 업무적으로 연관된 데이터 중심으로 조회가 많이 되는 경우라면 물리적으로 인접할 수 있도록 업무적인 복합키를 구성하는게 유리할 것 이다.</p>\n<p>실제 업무 시스템에서는 중요한 테이블(예: 이커머스의 주문 테이블)에 대해서는 쓰기와 읽기 작업 모두 빈번하게 발생한다. 이런 상황에서는 쓰기와 읽기 간의 트레이드 오프를 고려하여 결정해야한다. 대다수의 시스템에서 쓰기 대비 읽기의 비율이 8:2 또는 9:1로 나타나기 때문에, 읽기 작업에 최적화된 설계를 택하는 것이 대체로 유리할 것 이다.</p>\n<p>중요한것은 MySQL의 클러스터 인덱스와 세컨더리 인덱스 구조를 이해하고, 그 이해를 바탕으로 시스템 요구 사항에 가장 적합한  Primary Key를 선택할 수 있어야 한다.</p>","frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략","date":"August 06, 2023","update":"August 06, 2023","tags":["데이터베이스"],"series":null},"fields":{"slug":"/mysql-primary-key-design/","readingTime":{"minutes":14.46}}},"seriesList":{"edges":[{"node":{"id":"22d07d7d-18ae-5140-b700-6afb8adda7b0","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"897d9a67-24a9-59f9-aa19-71033b5e1d1b","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"c8e0da18-c3be-553e-92d5-2598a0e1ce83","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"0684164d-667c-51a2-8c58-1517361a3243","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"69cde3d4-8b44-5506-8844-24bbd20c63d5","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"9f4be72d-62c9-5907-ba92-3d88715e7a4f","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"fd027b15-4c0d-57eb-9a84-759fecdf0b78","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"ac932910-ca71-56ae-97f7-d15ae2381418","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"58455aee-c340-51cf-bceb-fd42ca376fad","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"4cd5e006-e9a2-592b-bc8d-651df314e59f","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"0199b798-4206-53ca-8a5a-9aa4e624e298","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"4b9ae8f4-7e36-5896-9039-22197a562eff","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"b86e7bae-198c-525a-bf53-9fb35db1afe6","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"bed09d78-b4be-5a64-9f97-ab30e9aac901","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"b34bff9b-e0ee-5038-a4ba-b50040bcdd2a","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"ee7cb342-656e-5cd3-be5d-4653460c2679","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"02015c5f-c992-5b88-a1a9-36f594b485b3","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"5d9422ea-90e5-5337-8b1b-3466f91c8804","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"85677df6-b9d4-5c1d-b3e6-a9fc5564ff07","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"d7ef20d8-74f4-5c32-93de-926edda896b5","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"e7fe3cb6-4ce3-5c59-a6d0-05eef92f6505","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"1e339f37-95b5-5510-ab63-bf6d80e6c393","fields":{"slug":"/\benabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"19fda853-336c-5380-8404-97d6685d50ab","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"b0f9150b-b03a-5207-89b9-60936e3cc578","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"75f3dc99-7d87-5d4e-adaa-a0066962034c","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"8ad33af7-49f4-58e2-9a2b-049b9f550f96","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"6afadd0e-8b95-5508-87f7-3061118bbae4","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"11ea05ce-4446-5775-bf6e-c3477d42d7c1","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"9b9bd5ca-dfcc-5d38-b278-1f205d612517","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"521d39b1-1b0f-58ed-98fd-4c9acece72d3","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"785c3945-b99c-570d-86e3-236475f4039f","fields":{"slug":"/java-concurrency/"},"frontmatter":{"title":"Java의 동시성 프로그래밍"}}},{"node":{"id":"c41bb674-d9fa-56b2-accd-85951b6565af","fields":{"slug":"/java-concurrency-model/"},"frontmatter":{"title":"웹 서버를 위한 동시성 프로그래밍 모델"}}}]},"previous":{"fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}},"next":{"fields":{"slug":"/java-concurrency/"},"frontmatter":{"title":"Java의 동시성 프로그래밍"}}},"pageContext":{"id":"521d39b1-1b0f-58ed-98fd-4c9acece72d3","series":null,"previousPostId":"9b9bd5ca-dfcc-5d38-b278-1f205d612517","nextPostId":"785c3945-b99c-570d-86e3-236475f4039f"}},"staticQueryHashes":[],"slicesMap":{}}