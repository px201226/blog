{"componentChunkName":"component---src-templates-post-jsx","path":"/behavior/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"bbcc04f9-2935-5753-9a7e-cd8fdfcc662c","excerpt":"디자인 패턴- 행동 패턴 어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘은 어느 객체에 정의하는 것이 좋은지 다룹니다. 객체들 간의 교류 방법에 대하여 정의한다. 행동 클래스 패턴 은 클래스 사이에 행동 책임을 분산하기 위해서 상속을 사용합니다. 행동 객체 패턴 은 상속보다는 복합을 통해서 객체 사이에 행동처리의 책임을 분산합니다. 전략 …","html":"<h2>디자인 패턴- 행동 패턴</h2>\n<ul>\n<li>어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘은 어느 객체에 정의하는 것이 좋은지 다룹니다.</li>\n<li>객체들 간의 교류 방법에 대하여 정의한다.</li>\n<li><strong>행동 클래스 패턴</strong> 은 클래스 사이에 행동 책임을 분산하기 위해서 상속을 사용합니다.</li>\n<li><strong>행동 객체 패턴</strong> 은 상속보다는 복합을 통해서 객체 사이에 행동처리의 책임을 분산합니다.</li>\n</ul>\n<!-- more -->\n<h2>전략 패턴</h2>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; '>\n      <a class='gatsby-resp-image-link' href='/static/480d5f2be7780c0795fbf788f0f65b2b/dface/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 44.705882352941174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiklEQVR42mVSy27CQAzk//+AY4+8DhTEQy2PFhWoEBQ1BamgSFCEgIRkA2QTSA5Te0MCVQ+jXY/HY+8jpes6NE3DdDqFYRhwXRfH41HhcDgo8P50OlHuROuNvwdr9vs9UhywyXZrYrlckalFgqgoCAIFxzliszFIY1CRDSkl8RdcLhHO57PSsWlKShemaePxsYOHhyIKhRbG4wl+fpYQQsCyLAwGM2Qyz0ins2i3v7Bem8rQ931lxmBjHiLFR5DSw25nkrFQk3IiDMOkQNO+0Wj00Wq9o9sdU6No+tiMdYkhj8lBGAYJOOZjxfA873qHrlp931N715VJ03+GnIiTnuergmgvFdiEzeNmccy66D6Dm2HcwbIEer0pyuUXlEptdDqfWCzWGI104l5RLLbo6EPM5yv6FQs0m0PiGqjXexgOZ7BtcTPkLqZpkaCJXK6GbLaGSuUNur5CtdqhR6kgn69T/gWz2Yru8oO4muIKhSf0+5PI0LbtP/+JY4YQ9h1nXTnxT8dwHCf5h7/2mZnyemIdXAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Untitled' title='' src='/static/480d5f2be7780c0795fbf788f0f65b2b/dface/img.png' srcset='/static/480d5f2be7780c0795fbf788f0f65b2b/e7570/img.png 170w,\n/static/480d5f2be7780c0795fbf788f0f65b2b/f46e7/img.png 340w,\n/static/480d5f2be7780c0795fbf788f0f65b2b/dface/img.png 600w' sizes='(max-width: 600px) 100vw, 600px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Untitled</figcaption>\n  </figure></p>\n<ul>\n<li>전략 패턴(Strategy Pattern)은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다.</li>\n<li>전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.</li>\n</ul>\n<h3>디자인 원칙</h3>\n<ul>\n<li>\n<p>애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분과 분리한다.</p>\n<ul>\n<li>달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 캡슐화한다.</li>\n<li>Context 달라지지 않는 부분, Strategy 달라지는 부분ㅔ</li>\n</ul>\n</li>\n<li>\n<p>구현보다는 인터페이스 맞춰서 프로그래밍 한다.</p>\n<ul>\n<li>Context의 행동은 인터페이스로 정의되어 구체적으로 구현하지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>상속보다는 구성을 활용한다.</p>\n<ul>\n<li>전략 패턴을 쓰지 않는다면 상속을 통해 서브 클래스에서 메서드를 오버라이딩 하여 행동을 바꿀 수 있다.</li>\n<li>Super 클래스에 의존성이 발생하고 필요하지 않은 부분도 상속해야 되는 문제점이 있다.</li>\n<li>구성(Composition)을 활용하면 시스템의 유연성을 크게 향상시킬 수 있다.</li>\n<li>알고리즘군을 별도의 클래스 집합으로 캡슐화할 수 있으며 구성 요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행 시에 행동을 바꿀 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h2>옵저버 패턴</h2>\n<ul>\n<li>옵저버 패턴(Observer Pattern)은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(One To Many) 의존성을 정의합니다.</li>\n</ul>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 461px; '>\n      <a class='gatsby-resp-image-link' href='/static/0e0265954cf0605d224a0a0b67e58b8a/31fe3/img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 62.94117647058823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnklEQVR42o2SR45CQQxE+/4XYgMsWLIgZ0TOOedQo+eZRg3SSFhqfX+HKid3PB61WCxUqVSUy+Xsy//hcNB6vVar1VImk9FsNtN4PDY7/lKppEKhoHK5bHYkEonI6U9IBHA4HOp2u+nxeGi1Wqnb7Wo+n6vZbKrX61ksfoB4+CkKicVicgB1Oh1zTCYTS6YKhO/1evWcGo1GajQaRor9+Xwa8el0Mn80GpUrFovK5/PWFsGAUwEC8/l8Np3k/X5vY9hut6aTxxdi4hiLw0lrzIUWwoTdbmcV/CfEfYqD2ZcOg9e93Vfn9VD8aN4AmQUA9/vdGD0gbWMLgbAR73OIJ8bbeA4W5si5pNNpe+jYSdhsNrbhwWBgo2Gu+LiIVCplPsYEcSKR+J0hm51Op6/vcrk0Zs4Esna7bYlcAQTMF2C2yzL8EuPxuBwVwZbNZl8n4ZNYyuVyebVMlRw0JMRSAMRvZ0MbBALEUti23zIvvEOqggAAyGgdHTtV9vt9OUDCYw6F4LDCb8TRNy+ZTKper6tWq9mrVqvWFi19KyzmB4zx3Makl9UPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Untitled' title='' src='/static/0e0265954cf0605d224a0a0b67e58b8a/31fe3/img_1.png' srcset='/static/0e0265954cf0605d224a0a0b67e58b8a/e7570/img_1.png 170w,\n/static/0e0265954cf0605d224a0a0b67e58b8a/f46e7/img_1.png 340w,\n/static/0e0265954cf0605d224a0a0b67e58b8a/31fe3/img_1.png 461w' sizes='(max-width: 461px) 100vw, 461px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Untitled</figcaption>\n  </figure></p>\n<ul>\n<li>Publish-Subscribe 패턴과는 다르다. Publish-Subscribe 패턴은 구독자가 서로 다른 유형의 메시지에 관심을 가질 수 있고 출판사와 구독자가 더 세세하게 분리할 수 있는 복잡한 패턴이다.</li>\n</ul>\n<h3>느슨한 결합의 위력</h3>\n<ul>\n<li>느슨한 결합(Loose Coupling)은 객체들이 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미한다.</li>\n<li>\n<p>주제(Subject)클래스는 옵저버가 특정 인터페이스(Observer 인터페이스)를 구현한다는 사실만 안다.</p>\n<ul>\n<li>옵저버의 구상 클래스가 무엇인지, 옵저버가 무엇을 하는지는 알 필요가 업삳.</li>\n</ul>\n</li>\n<li>\n<p>옵저버는 언제든지 새로 추가할 수 있다.</p>\n<ul>\n<li>주제는 Observer 인터페이스에만 의존하므로 언제든지 새로운 옵저버를 추가할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>새로운 형식의 옵저버를 추가할 때도 변경할 필요가 없다.</p>\n<ul>\n<li>옵저버의 구상 클래스가 새로 생기더라도 주제 클래스는 그것을 신경 쓸 필요가 없다. Observer 인터페이스만 구현한다면 어떤 객체와도 상호작용이 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>주제와 옵저버는 서로 독립적으로 재사용할 수 있다.</p>\n<ul>\n<li>둘이 서로 단단하게 결합되지 않기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p>주제나 업저버가 달라져도 서로에게 영향을 미치지 않는다.</p>\n<ul>\n<li>구현에 의존하지 않고 인터페이스 의존하기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<aside>\n💡 디자인 원칙   \n상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용한다.\n</aside>\n<h3>푸시 방식에서 풀 방식으로 바꾸기</h3>\n<ul>\n<li>주제가 옵저버에게 상태를 알리는 방식(푸시)는 Observer의 <code class=\"language-text\">update()</code> 메서드의 파라미터가 변경된다면 모든 구상 옵저버 클래스의 변경이 발생한다.</li>\n<li>옵저버가 주제로부터 상태를 끌어오는 방식(풀)로 바꾼다면 옵저버가 필요한 데이터를 골라서 가져올 수 있고 쉽게 확장할 수 있다.</li>\n</ul>\n<h4>주제에서 알림 보내기</h4>\n<ul>\n<li>옵저버의 update 메서드를 인자없이 호출하도록 주제 클래스의 <code class=\"language-text\">notifyObservers()</code> 메서드를 수정한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">nofifyObservers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Observer</span> observer <span class=\"token operator\">:</span> observers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tobserver<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 파라미터 없이 호출</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>옵저버에서 알림 받기</h4>\n<ul>\n<li>Observer 인터페이스에서 update() 메서드의 매개변수 제거</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Observer</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Concreate Observer 클래스의 update 메서드를 주제의 데이터를 가져오도록 수정</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>temperature <span class=\"token operator\">=</span> weatherData<span class=\"token punctuation\">.</span><span class=\"token function\">getTeperature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>humidity <span class=\"token operator\">=</span> weaterData<span class=\"token punctuation\">.</span><span class=\"token function\">getHumidity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>디자인 원칙</h3>\n<ul>\n<li>\n<p>애플리케이션에서 달리지는 부분을 찾아내고 달라지지 않는 부븐과 분리한다.</p>\n<ul>\n<li>옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수와 형식이다.</li>\n<li>주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있음</li>\n</ul>\n</li>\n<li>\n<p>구현보다는 인터페이스에 맞춰서 프로그래밍 한다.</p>\n<ul>\n<li>주제는 Subject 인터페이스로 Observer 인터페이스를 구현하는 객체들의 등록과 탈퇴를 관리하고 그런 객체들에게 상태를 알린다.</li>\n</ul>\n</li>\n<li>\n<p>상속보다는 구성을 사용한다.</p>\n<ul>\n<li>주제와 옵저버 사이의 관계는 상속이 아니라 구성으로 이루어진다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"디자인 패턴 - 행동 패턴","date":"April 02, 2022","update":"April 02, 2022","tags":["디자인 패턴"],"series":null},"fields":{"slug":"/behavior/","readingTime":{"minutes":7.5}}},"seriesList":{"edges":[{"node":{"id":"bad021b0-8468-5808-8daa-8cf3434c19ae","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"1c3bf38a-5822-589b-ae08-5e0182388d1a","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"68b667f0-fbb0-5312-bba3-7728df4a1d74","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"22d5ddb1-57c0-5f00-8699-cefd462d1666","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"137b1767-6e4e-5fdf-a9f9-0b3798cbe37e","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"7a8cd6aa-bb6e-55b4-9854-4288e54769ee","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"0d8cea97-6f8f-5e28-b4ad-7e48cc2d2e46","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"645ed70a-de7e-58f4-a2a3-cb643a99e30a","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"0cf94437-bd98-5772-bde9-914727aa343e","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"130946b3-e281-5f87-8dd1-cef00be4a774","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"34735664-ed59-5784-a071-1227717349e3","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"a2c4d2d8-b012-5449-9251-3bcc368876ea","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"ee53721c-3561-5f47-9065-76762ebce369","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"0ee045de-1f2e-5326-840b-f7513c16f2d7","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"b3880869-c0db-5d58-948e-92985250cf2d","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"cf31c6e7-91a8-55a7-beea-5dca2e2460fa","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"bbcc04f9-2935-5753-9a7e-cd8fdfcc662c","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"f3e9b018-dcf2-5066-be00-909086dcbff2","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"d7818847-fabd-52c1-94c6-4907e05a3490","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"c7e63a70-6b62-52e8-ac0f-d5dcdecd7147","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"1cda8db3-a1d2-56f9-85e0-29bac23a0650","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"09549337-253c-501f-ba42-533815a37e3c","fields":{"slug":"/\benabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcd2238-18eb-57ef-9cd3-c0177a3c1954","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"d814ac35-d925-5139-ac77-ee416f12dbcb","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"ff41f5b0-73ba-5595-aebb-35db1d98dc0b","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"814be12c-5d81-5869-910d-04f5c3fce410","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"784bc412-aba6-543c-bf75-23eaddb9ed64","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"d488972a-385d-5d13-bbfe-08c074fa8372","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"2dd75ae1-e168-5f46-a340-b7f8dd712d7a","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"2db7d058-3179-54bf-ac47-0b4f61b8e897","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"f1907721-044b-5781-8b3f-9df0fbf38ec8","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"bb461b3a-0c19-5caf-9d09-08989e720b7f","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}}]},"previous":{"fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}},"next":{"fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},"pageContext":{"id":"bbcc04f9-2935-5753-9a7e-cd8fdfcc662c","series":null,"previousPostId":"cf31c6e7-91a8-55a7-beea-5dca2e2460fa","nextPostId":"f3e9b018-dcf2-5066-be00-909086dcbff2"}},"staticQueryHashes":[],"slicesMap":{}}