{"componentChunkName":"component---src-templates-post-jsx","path":"/socket_option/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"3ffd46b0-5607-5617-bd21-e384edcf6c2b","excerpt":"Socket Option 소켓 옵션은 자바의 Socket 클래스가 사용하는 네트워크 소켓이 데이터를 어떻게 보내고 받을 것인지를 결정한다. 자바에서는 클라이언트 측 소켓에 대해 9가지 옵션이 존재한다. TCP_NODELAY SO_BINDADDR SO_TIMEOUT SO_LINGER SO_SNDBUF SO_RCVBUF SO_KEEPALIVE OOBINLIN…","html":"<h2>Socket Option</h2>\n<p>소켓 옵션은 자바의 Socket 클래스가 사용하는 네트워크 소켓이 데이터를 어떻게 보내고 받을 것인지를 결정한다. 자바에서는 클라이언트 측 소켓에 대해 9가지 옵션이 존재한다.</p>\n<ul>\n<li>TCP_NODELAY</li>\n<li>SO_BINDADDR</li>\n<li>SO_TIMEOUT</li>\n<li>SO_LINGER</li>\n<li>SO_SNDBUF</li>\n<li>SO_RCVBUF</li>\n<li>SO_KEEPALIVE</li>\n<li>OOBINLINE</li>\n<li>IP_TOS</li>\n</ul>\n<p>java.net.SocketOptions 인터페이스에 각 옵션이 정의되어 있고 socket 클래스의 메서드를 통해 옵션을 설정할 수 있다. 여기서는 주요 옵션들에 기능에 대해 정리한다.</p>\n<h2>TCP_NODELAY</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setTcpNoDelay</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> on<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">getTcpNoDelay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span></code></pre></div>\n<p>TCP는 기본적으로 Nagle’s 알고리즘을 사용하여 작은 패킷들을 합쳐서 하나의 큰 패킷으로 전송한다. 이렇게 하는 이유는 작은 패킷들을 하나씩 보내는 것보다, 여러 패킷을 하나의 큰 패킷으로 합쳐서 보내면 전송 효율이 높아지기 때문이다. Nagle’s 알고리즘은 데이터를 효율적으로 전송하기 좋은 방법이지만, 특정 상황에서는 좋은 방법이 아닐 수 있다. 예를 들면 실시간 빠른 응답이 필요한 애플리케이션(게임, GUI 프로그램 등)에서는 패킷이 지연 없이 바로 전송되어야 한다. TCP_NODELAY를 true로 설정하면, Nagle’s 알고리즘이 비활성화되어 작은 패킷도 즉시 전송된다.\n즉, 패킷을 버퍼링하지 않고 즉시 전송하는 것을 의미한다.</p>\n<h2>SO_LINGER</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSoLinger</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> on<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> seconds<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSoLinger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span></code></pre></div>\n<p>SO_LINGER 옵션은 소켓을 닫을 때 아직 전송되지 않은 패킷을 어떻게 처리될지를 결정한다.\n큰 파일을 다른 컴퓨터에게 전송하고 있는 상태에서 파일 전송이 완전히 끝나기 전에 close() 메서드를 호출하면 어떻게 될까? 기본적으로 close() 메서드를 호출하면 연결을 종료하려고 시도하고, 아직 전송되지 않은 데이터가 있다면 그 데이터를 원격지에 전송하려고 한다. 이렇게 하는 이유는 연결을 종료하기 전에 전송되지 않은 데이터를 안전하게 전송하기 위해서이다. 따라서, close() 메서드가 즉시 반환되었다고 시스템 내부 작업이 완전히 끝났다고 판단할 수는 없다. 이 옵션은 소켓을 close 할 때 처리를 세밀하게 조정할 수 있다.</p>\n<ul>\n<li>비활성화된 경우 (-1): 소켓은 바로 닫히며 아직 전송되지 않은 데이터가 있다면 시스템은 그 데이터를 전송하려고 한다. 이 때 얼마나 오랜 시간 동안 노력할지는 시스템의 기본 설정에 따라 다르다.</li>\n<li>활성화된 경우 (0 이상의 값): 설정된 시간(초) 동안 아직 전송되지 않은 데이터를 전송하려고 노력하고, 그 시간이 지나면 남은 데이터를 전송하지 않고 소켓을 close한다.</li>\n<li>0인 경우: 아직 전송되지 않은 모든 데이터는 버려지고 즉시 소켓이 close된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">socket<span class=\"token punctuation\">.</span><span class=\"token function\">setSoLinger</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// SO\\_LINGER 옵션 비활성화</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">setSoLinger</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// close() 후, 5분 동안 추가 데이터 전송을 허용</span></code></pre></div>\n<p>getSoLinger() 메서드는 SO_LINGER 옵션이 비활성화되어 있다면 -1을 반환하고, 그게 아니라면 현재 소켓의 \"linger\" 시간 즉, 닫히기 전에 남은 데이터를 전송하는 데 허용된 시간을 초 단위로 반환한다.</p>\n<h2>SO_TIMEOUT</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSoTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> milliseconds<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSoTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span></code></pre></div>\n<p>SO_TIMEOUT 옵션은 너무 오랫동안 데이터를 기다리지 않도록 할 수 있다.\nsockect.read() 메서드는 소켓에서 데이터를 읽을 때까지 블록킹된다. 이 옵션을  사용하면 read() 메서드가 무한정으로 블록킹 되지 않도록 타임아웃을 설정할 수 있다. 0 으로 설정할 경우 타임아웃이 없음을 의미하고 기본값으로 사용된다.\n예를 들어, 1분의 read timeout을 설정하고 싶다면 socket.setSoTimeout(60000); 로 설정한다.</p>\n<h2>SO_RCVBUF, SO_SNDBUF</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setReceiveBufferSize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IllegalArgumentException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getReceiveBufferSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSendBufferSize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IllegalArgumentException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSendBufferSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span></code></pre></div>\n<p>SO_RCVBUF는 네트워크 입력을 위한 버퍼 크기를, SO_SNDBUF는 네트워크 출력을 위한 버퍼 크기를 제어한다.\n파일 전송과 같은 상황에서는 큰 버퍼가 이점이 있지만, 게임과 같은 실시간 통신이 필요한 상황의 경우에는 버퍼를 사용할 경우 전송 지연이 발생할 수 있다. 운영체제 마다 다르지만 일반적으로 128바이트가 일반적인 기본값이다.\n버퍼 크기는 소켓의 최대 속도를 결정하는데, 최대 가능한 대역폭은 버퍼 크기를 지연시간으로 나눈 값이다.\n예를 들어, 두 호스트 간의 전송 지연시간이 0.5초에 버퍼 크기가 128바이트라면 128byte/0.5s = 256byte/1s가 된다. 지연시간은 애플리케이션이 제어할 수 없는 변수이므로 버퍼 사이즈를 두 배로 늘리면 대역폭도 두 배로 증가한다.\n물론 네트워크가 처리할 수 있는 대역폭은 제한되어 있기 때문에 그 보다 작게 설정해야 한다.</p>\n<p>java doc을 확인해보면 setReceiveBufferSize, setSendBufferSize 는 네트워크 I/O 버퍼를 설정하기 위한 크기에 대한 힌트로 사용된다.</p>\n<blockquote>\n<p>Sets the SO_SNDBUF option to the specified value for this Socket. The SO_SNDBUF option is used by the platform's networking code as a hint for the size to set the underlying network I/O buffers.</p>\n</blockquote>\n<p>이는 set으로 설정하더라도 실제 구현에서는 값이 달라질 수 있다는 얘기이다. 실제 버퍼가 어떤 크기로 설정되어 있는지 확인하기 위해 getSendBufferSize() 메서드로 확인할 수 있다.</p>\n<h2>SO_KEEPALIVE</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setKeepAlive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> on<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">getKeepAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span></code></pre></div>\n<p>SO_KEEPALIVE는 HTTP 프로토콜에 Keepalive 헤더와는 다른 옵션이다. SO_KEEPALIVE 옵션은 서버가 죽어있는지 헬스 체크를 확인하기 위해 주기적으로 패킷을 보내는 옵션이다. 서버가 이 패킷에 응답하지 않으면 클라이언트는 응답을 받을 때 까지 시도하다가 결국 응답을 받지 못하면 소켓을 close한다. 네트워크 연결이 적절히 종료되지 않고 클라이언트나 서버 중 한 쪽에서만 종료된 경우를 half open 연결이라고 하는데, SO_KEEPALIVE는 그 상태를 감지하기 위한 기능이다.</p>\n<p>TCP Keepalive의 상세 설정은 운영체제 파라미터를 통해 설정할 수 있다.\n아래는 Linux에서 keepalive 관련 설정값들이다.</p>\n<ul>\n<li>/proc/sys/net/ipv4/tcp_keepalive_time<br>\n이 파일에 저장된 값은 TCP keep-alive 패킷이 처음으로 전송되기 시작하는 시간을 초 단위로 나타낸다.\n일반적으로 기본값은 7200초(2시간)이다. 즉, 연결이 비활성 상태로 있을 때 2시간 후에 첫 번째 keep-alive 패킷이 전송된다.</li>\n<li>/proc/sys/net/ipv4/tcp_keepalive_intvl<br>\n이 파일에 저장된 값은 keep-alive 패킷 간의 간격을 초 단위로 나타낸다.\n예를 들어, 첫 번째 keep-alive 패킷에 대한 응답이 없으면 이 파일에 지정된 간격 후에 두 번째 패킷이 전송된다.\n일반적으로 기본값은 75초이다.</li>\n<li>/proc/sys/net/ipv4/tcp_keepalive_probes<br>\n이 파일에 저장된 값은 연속적으로 전송될 수 있는 keep-alive 패킷의 최대 횟수를 나타낸다.\n일반적으로 기본값은 9이다. 즉, keep-alive 패킷 9회 연속으로 응답이 없을 경우 연결이 끊어진다.</li>\n</ul>\n<h2>OOBINLINE</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sendUrgentData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setOOBInline</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> on<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">getOOBInline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span></code></pre></div>\n<p>TCP에는 긴급 데이터(Urgent Data)를 바로 전송하는 기능이 있다. sendUrgentData() 메서드를 사용하면 int data를 거의 바로 전송한다. 전송될 바이트는 data 파라미터의 최하위 8비트가 전송된다. OutputStream에 이미 데이터가 기록되어 있다면 이미 기록되어 있는 데이터 뒤에 전송된다.</p>\n<p>OOBINLINE 값이 true이면 소켓의 입력 스트림에 위치하게 되어 일반적인 방법으로 읽을 수 있다. 기본값은 false이다. Java에서는 긴급 데이터는 일반 데이터와 구별하지 않기 때문에 긴급 바이트를 처리하기가 어려운데, Ctrl-C 같은 특별한 의미를 갖는 바이트를 전송이 필요할 때 써볼 수 있다.</p>\n<h2>SO_REUSEADDR</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setReuseAddress</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> on<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">getReuseAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SocketException</span></code></pre></div>\n<p>SO_REUSEADDR 옵션은 소켓을 닫았을 때 해당 소켓의 포트를 즉시 다시 사용할 수 있게 해주는 역할은 한다.\n소켓 연결을 끊게 되면 먼저 연결을 끊는 쪽에서 TIME_WAIT 상태로 일정시간 유지되는데, 이는 네트워크 상에 아직 도착하지 않은 마지막 패킷들이 소켓에 도착할 시간을 확보하기 위한 것이다. 따라서, 소켓 연결이 끊어진다고 해서 그 포트가 즉시 재사용되지 않는다. 시스템은 이러한 늦게 도착한 패킷들을 처리하지 않지만, 그 패킷들이 같은 포트를 사용하는 다른 프로세스에게 잘못 전달되는 것을 방지하기 위해 일정시간을 대기한다.\nSO_REUSEADDR 옵션을 활성화하면, 이러한 대기 시간 없이 포트를 즉시 재사용할 수 있게 한다.</p>\n<p>TIME_WAIT 상태에 자세한 설명은 <a href=\"https://tech.kakao.com/2016/04/21/closewait-timewait/\">카카오 기술블로그</a>에 잘 정리된 것이 있으니 참고하길 바란다.</p>\n<p>setReuseAddress() 메서드가 작동하려면 소켓이 포트에 바인됭되기 전에 setReuseAddress() 호출해야 한다.\n즉 인자없는 생성자 new Socket() 을 통해 소켓을 생성한다음 setReuseAddress(true)를 호출하고 connect() 메서드를 통해 소켓을 연결해야 한다.</p>\n<h2>참조</h2>\n<ul>\n<li>TCP/IP Illustrated</li>\n<li>자바 네트워크 프로그래밍 4판</li>\n</ul>","frontmatter":{"title":"Java의 Socket Option 정리","date":"September 29, 2023","update":"September 29, 2023","tags":["Java"],"series":null},"fields":{"slug":"/socket_option/","readingTime":{"minutes":12.945}}},"seriesList":{"edges":[{"node":{"id":"22d07d7d-18ae-5140-b700-6afb8adda7b0","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"897d9a67-24a9-59f9-aa19-71033b5e1d1b","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"c8e0da18-c3be-553e-92d5-2598a0e1ce83","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"0684164d-667c-51a2-8c58-1517361a3243","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"69cde3d4-8b44-5506-8844-24bbd20c63d5","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"9f4be72d-62c9-5907-ba92-3d88715e7a4f","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"fd027b15-4c0d-57eb-9a84-759fecdf0b78","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"ac932910-ca71-56ae-97f7-d15ae2381418","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"58455aee-c340-51cf-bceb-fd42ca376fad","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"4cd5e006-e9a2-592b-bc8d-651df314e59f","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"0199b798-4206-53ca-8a5a-9aa4e624e298","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"4b9ae8f4-7e36-5896-9039-22197a562eff","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"b86e7bae-198c-525a-bf53-9fb35db1afe6","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"bed09d78-b4be-5a64-9f97-ab30e9aac901","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"b34bff9b-e0ee-5038-a4ba-b50040bcdd2a","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"ee7cb342-656e-5cd3-be5d-4653460c2679","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"02015c5f-c992-5b88-a1a9-36f594b485b3","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"5d9422ea-90e5-5337-8b1b-3466f91c8804","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"85677df6-b9d4-5c1d-b3e6-a9fc5564ff07","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"d7ef20d8-74f4-5c32-93de-926edda896b5","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"e7fe3cb6-4ce3-5c59-a6d0-05eef92f6505","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"1e339f37-95b5-5510-ab63-bf6d80e6c393","fields":{"slug":"/\benabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"19fda853-336c-5380-8404-97d6685d50ab","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"b0f9150b-b03a-5207-89b9-60936e3cc578","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"75f3dc99-7d87-5d4e-adaa-a0066962034c","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"8ad33af7-49f4-58e2-9a2b-049b9f550f96","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"6afadd0e-8b95-5508-87f7-3061118bbae4","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"11ea05ce-4446-5775-bf6e-c3477d42d7c1","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"9b9bd5ca-dfcc-5d38-b278-1f205d612517","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"521d39b1-1b0f-58ed-98fd-4c9acece72d3","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"96d8ea29-f513-54c2-93b3-26142a0ce1fc","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"3ffd46b0-5607-5617-bd21-e384edcf6c2b","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"b21ac7fc-284e-5536-bdc7-1705a044f58b","fields":{"slug":"/java-nio-buffer/"},"frontmatter":{"title":"Java NIO 파헤치기 - Buffer"}}},{"node":{"id":"827c7ba6-09c2-5240-a88e-499013d65833","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"0d7d38a2-3c38-586d-a50b-6c6164ba47fd","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}}]},"previous":{"fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}},"next":{"fields":{"slug":"/java-nio-buffer/"},"frontmatter":{"title":"Java NIO 파헤치기 - Buffer"}}},"pageContext":{"id":"3ffd46b0-5607-5617-bd21-e384edcf6c2b","series":null,"previousPostId":"96d8ea29-f513-54c2-93b3-26142a0ce1fc","nextPostId":"b21ac7fc-284e-5536-bdc7-1705a044f58b"}},"staticQueryHashes":[],"slicesMap":{}}