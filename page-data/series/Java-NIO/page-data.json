{"componentChunkName":"component---src-templates-series-jsx","path":"/series/Java-NIO/","result":{"data":{"posts":{"nodes":[{"excerpt":"버퍼 I/O 운영체제의 I/O는 모두 버퍼를 통해 이루어진다. 프로세스는 버퍼에서 데이터를 채우는 (쓰기) 또는 버퍼에 데이터를 비우는 (읽기) 작업을 운영 체제에 요청함으로써 I/O를 수행한다.\n모든 데이터는 이 메커니즘을 통해 프로세스 내부로 이동하거나 나간다.\n 위 그림에서 사용자 공간(user space)과 커널 공간(kernel space)의 개…","fields":{"slug":"/java-nio-buffer/"},"frontmatter":{"date":"October 03, 2023","update":"Oct 03, 2023","title":"Java NIO - Buffer","tags":["Java"]}},{"excerpt":"Channel Channel은 파일이나 소켓과 같은 엔티티 간에 데이터를 효율적으로 전송하는 통로이다.\n채널은 일반적으로 운영체제의 파일 디스크립터나 핸들러와 일대일 관계를 가진다.\n채널은 Java의 플랫폼 독립성을 유지하면서도 운영 체제의 네이티브 I/O 기능에 대한 추상화를 제공한다. 아래 그림은 Channel 클래스의 상속관계를 나타낸다.  계층구조…","fields":{"slug":"/java-nio-channel/"},"frontmatter":{"date":"October 14, 2023","update":"Oct 14, 2023","title":"Java NIO - Channel","tags":["Java"]}},{"excerpt":"Selector Buffer 편에서도 보았듯이, java.nio 는 기존 Java I/O의 한계를 극복하기 위해서 탄생되었다. \nC/C++의 경우에는 이미 POSIX 계열 OS의 select()나 poll() 같은 시스템 호출로 멀티플렉싱을 구현하였지만 기존 Java I/O는 이를 사용할 수 없었다. Selector는 멀티플렉싱 I/O를 가능하게 한다. …","fields":{"slug":"/java-nio-selector/"},"frontmatter":{"date":"October 19, 2023","update":"Oct 19, 2023","title":"Java NIO - Selector","tags":["Java"]}}]}},"pageContext":{"series":"Java NIO"}},"staticQueryHashes":[],"slicesMap":{}}