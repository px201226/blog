{"componentChunkName":"component---src-templates-post-jsx","path":"/tomcat-connection/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"d1df0b87-5078-5aa9-a1a5-560935978720","excerpt":"개요 지난 게시물에서는 Tomcat의 아키텍처와 클라이언트와의 연결 방식, 그리고 요청 처리 메커니즘에 대해 알아보았다.\n특히, NIO Connector의 Selector를 활용한 이벤트 루프 처리 방식은 BIO Connector에 비해 훨씬 더 많은 연결을 효율적으로 관리하면서 요청을 처리할 수 있게 만들었다. 이번 게시물에서는 Tomcat이 Selec…","html":"<h2>개요</h2>\n<p><a href=\"https://px201226.github.io/tomcat/\">지난 게시물</a>에서는 Tomcat의 아키텍처와 클라이언트와의 연결 방식, 그리고 요청 처리 메커니즘에 대해 알아보았다.\n특히, NIO Connector의 Selector를 활용한 이벤트 루프 처리 방식은 BIO Connector에 비해 훨씬 더 많은 연결을 효율적으로 관리하면서 요청을 처리할 수 있게 만들었다.</p>\n<p>이번 게시물에서는 Tomcat이 Selector를 통해 관리하는 수 많은 연결들을 타임아웃 관점에서 어떻게 관리하는지에 대해 살펴본다.</p>\n<h2>Tomcat의 타임아웃 관리</h2>\n<p>네트워크에서 발생할 수 있는 타임아웃에는 크게 3-way-handshake 중 발생하는 Connection Timeout, Read Timeout, Write Timeout 이 있다.\n이 중 톰캣과 같은 서버 측에서 Connection Timeout은 핸들링 할 수 없는데, 그 이유는 서버에서는 클라이언트 요청을 받기 위해 무한정 대기하고 핸드 쉐이크 중 에러가 발생하더라도\nTCP/IP 스택에서 자동으로 처리되기 때문이다.</p>\n<p>네트워크 상에서 Read/Write Timeout 의미는 데이터를 read/write 위해 최대 대기하는 시간을 의미한다.\n예를 들어 socket.read()에 타임아웃을 10초로 설정했다면, 이는 소켓에서 데이터를 읽기 시작하기 전에 최대 10초 동안 대기할 수 있다는 것을 의미한다.\n만약 9초에 첫 번째 패킷이 도착하고 15초에 모든 패킷 전송이 끝나더라도, socket.read()는 이미 데이터를 읽기 시작했기 때문에 타임아웃이 발생하지 않는다.\n즉, 타임아웃은 데이터가 처음으로 도착하기 전 최대 대기 시간을 말한다. 데이터가 도착하기 시작한 후에는 타임아웃은 적용되지 않는다.</p>\n<p>Spring/Tomcat 에서는 아래와 같은 Timeout 속성을 제공한다. </p>\n<ul>\n<li><strong>server.tomcat.connection-timeout</strong> : 연결을 수락한 후 요청 URI 줄이 제시될 때까지 얼마 동안 기다릴지를 밀리초 단위로 정한다. -1을 사용하면 시간 제한이 없다는 의미다. 기본값은 60초이다.   </li>\n<li><strong>server.tomcat.keep-alive-timeout</strong> : 다른 HTTP 요청을 기다리기 전에 연결을 닫을 때까지 얼마 동안 기다릴지를 밀리초 단위로 정한다. 기본값은 connectionTimeout 속성에 설정된 값을 사용한다. -1 값을 사용하면 시간 제한이 없다는 의미다.</li>\n</ul>\n<p>Tomcat에서는 별도의 Read/Write Timeout 속성은 제공하지 않고 connection-timeout 속성을 제공한다.\nAcceptor 스레드에서 클라이언트 연결이 이루어지면 해당 소켓의 Read/Write Timeout을  connection-timeout으로 설정하고 Poller 에 등록된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">setReadTimeout</span><span class=\"token punctuation\">(</span><span class=\"token function\">getConnectionTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">setWriteTimeout</span><span class=\"token punctuation\">(</span><span class=\"token function\">getConnectionTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그 후, Poller는 이벤트 루프를 돌면서 해당 소켓이 타임아웃이 발생하였는지 검사한다.\n아래는 Poller의 이벤트 루프 로직을 단순화 한 것 이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">boolean</span> hasEvents <span class=\"token operator\">=</span> <span class=\"token function\">events</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        keyCount <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectNow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n        <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> iterator <span class=\"token operator\">=</span>\n            keyCount <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t  <span class=\"token function\">processKey</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> socketWrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\t\t\t\t\n        <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span>keyCount<span class=\"token punctuation\">,</span>hasEvents<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Process timeouts</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">processKey(sk, socketWrapper)</code> 에서 준비된 소켓의 처리가 이루어지고 <code class=\"language-text\">timeout(keyCount,hasEvents)</code> 에서 타임아웃 관련 처리가 이루어진다.   </p>\n<h3>timeout(keyCount,hasEvents)</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> keyCount<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> hasEvents<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>timeout 메서드는 현재 selector에 등록된 모든 키의 수인 keyCount와 등록된 채널에서 관심 있는 이벤트가 발생했는 지 여부인 hasEvents 를 인수로 받는다.</p>\n<h4>조건 검사</h4>\n<p>timeout 메서드가 실행되면 첫 번째로 아래의 조건을 검사한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextExpiration <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>keyCount <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> hasEvents<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>now <span class=\"token operator\">&lt;</span> nextExpiration<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>close<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">nextExpiration > 0 &amp;&amp; (now &lt; nextExpiration)</code> : 현재 시간이 nextExpiration까지 아직 경과하지 않았다면</li>\n<li><code class=\"language-text\">(keyCount > 0 || hasEvents)</code> : polling 큐나 selector에 이벤트가 대기 중이라면</li>\n<li><code class=\"language-text\">!close</code> : 서버 소켓이 아직 닫히지 않았다면</li>\n</ul>\n<p>여기서 nextExpiration은 <code class=\"language-text\">System.currentTimeMillis() + socketProperties.getTimeoutInterval()</code>로 계산된다.</p>\n<p>조건의 핵심은 계산된 nextExpiration과 현재 시간을 비교해서 타임아웃 로직을 계속할지 결정하는 것이다.</p>\n<p><code class=\"language-text\">socketProperties.getTimeoutInterval()</code>의 기본 값은 1초로, 이 때문에 무한루프 내에서 1초마다 타임아웃을 검사하게 된다.\n이런 방식은 busy wait로 동작하는데, 짧은 간격으로 계속 실행되기 때문에 스레드 컨텍스트 스위칭 같은 작업 스케줄링 오버헤드를 줄여 성능을 향상시키려는 의도로 보인다.</p>\n<h4>연결되어 있는 모든 소켓 확인</h4>\n<p>Selector에 등록된 모든 SelectionKey를 가져와 연결되어 있는 모든 소켓에 대해서 타임아웃 검사를 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SelectionKey</span> key <span class=\"token operator\">:</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    keycount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">NioSocketWrapper</span> socketWrapper <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">NioSocketWrapper</span><span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">attachment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 생략...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 소켓이 현재 read 작업에 관심이 있다면 readTimeout 판단</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">interestOpsHas</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OP_READ</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">long</span> delta <span class=\"token operator\">=</span> now <span class=\"token operator\">-</span> socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">getLastRead</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> timeout <span class=\"token operator\">=</span> socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">getReadTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeout <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> delta <span class=\"token operator\">></span> timeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        readTimeout <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 소켓이 현재 write 작업에 관심이 있다면 writeTimeout 판단</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>readTimeout <span class=\"token operator\">&amp;&amp;</span> socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">interestOpsHas</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OP_WRITE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">long</span> delta <span class=\"token operator\">=</span> now <span class=\"token operator\">-</span> socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">getLastWrite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> timeout <span class=\"token operator\">=</span> socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">getWriteTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeout <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> delta <span class=\"token operator\">></span> timeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        writeTimeout <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Selector로 관리하는 각 연결의 정보는 SelectionKey에 담겨있다. 이 SelectionKey에서 socketWrapper를 가져와 연결 상태를 파악하고 조절한다.</p>\n<p>socketWrapper로 해당 소켓이 마지막으로 언제 데이터를 읽었는지 (getLastRead)와 썼는지 (getLastWrite) 확인한다.\n현재 시간과 마지막으로 데이터를 읽거나 쓴 시간 사이의 차이를 delta로 계산한다.\n이 delta가 설정된 timeout을 넘으면, 그 연결은 타임아웃으로 간주하고 관련 작업을 수행한다.</p>\n<h4>타임아웃 처리</h4>\n<p>위에서 설정된 writeTimeout, readTimeout 변수를 확인하여 타임아웃이라고 판단되면 cancelledKey 메서드를 호출한다.\ncancelledKey 메서드는 할당되어 있는 자원을 해제하고 소켓 연결을 종료한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readTimeout <span class=\"token operator\">&amp;&amp;</span> socketWrapper<span class=\"token punctuation\">.</span>readOperation <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>socketWrapper<span class=\"token punctuation\">.</span>readOperation<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">cancelledKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> socketWrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>writeTimeout <span class=\"token operator\">&amp;&amp;</span> socketWrapper<span class=\"token punctuation\">.</span>writeOperation <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>socketWrapper<span class=\"token punctuation\">.</span>writeOperation<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">cancelledKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> socketWrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">processSocket</span><span class=\"token punctuation\">(</span>socketWrapper<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SocketEvent</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ERROR</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">cancelledKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> socketWrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">socketWrapper.readOperation.process()</code> 및 <code class=\"language-text\">socketWrapper.writeOperation.process()</code><br>\nsocketWrapper의 readOperation, writeOperation 는 비동기 처리일 때 사용된다.\ntimeout이 발생했을 때 등록된 비동기 작업이 있으면 process() 를 통해 해당 작업을 처리한다.<br>\n만약 비동기 작업 처리에 실패한다면<code class=\"language-text\">(!socketWrapper.readOperation.process() == true) 인 경우</code> cancelledKey 을 호출하여 socket을 close 한다.</li>\n<li><code class=\"language-text\">processSocket(socketWrapper, SocketEvent.ERROR, true)</code><br>\n동기 HTTP 요청 처리을 처리할 때 선택되는 로직이다. processSocket 메서드에 SocketEvent.ERROR라는 Enum 타입을 전달하면 해당 메서드 내에서 SocketEvent의 값에 따라 처리 로직이 분기된다.\nprocessSocket은 Worker threadPool에서 스레드 하나를 할당받아 소켓 이벤트를 처리하게 된다.\n즉, 워커 스레드를 하나 할당받아 socket close 작업을 진행한다.<br>\n만약 Worker Pool에서 스레드 할당에 실패하면 <code class=\"language-text\">(!processSocket(socketWrapper, SocketEvent.ERROR, true) == true)</code> 현재의 Main Thread(Poller Thread)에서 cancelledKey를 호출하여 socket을 close 한다.</li>\n</ul>\n<h2>Persistent Connection</h2>\n<p>HTTP 프로토콜은 기본적으로 비연결성(connectionless)를 기반으로 한다. 이는 매 요청마다 3-way-handshake를 맺어야 하는 오버헤드가 발생한다.\n그래서 HTTP/1.1 부터는 매 요청마다 새로운 연결을 맺는 것이 아니라 기존 연결을 재사용할 수 있는 keep-alive 메커니즘을 제공한다.</p>\n<p>그렇다면 tomcat에서는 어떻게 Persistent Connection을 관리할까? 기본적으로 Tomcat 8.0 이후부터는 java.nio의 Selector를 이용하여 소켓을 관리한다.\nSelector를 사용하여 싱글 스레드로도 대량의 Connection들을 관리할 수 있다. 여기서는 Tomcat의 코드 레벨에서 Persistent Connection (Keep-Alive Connection) 과 Non-Persistent Connection (Close Connection) 처리의 차이를 분석해보려고 한다.</p>\n<p>Tomcat의 Http11Processor는 HTTP 프로토콜의 핵심 부분을 구현하는데, Keep-alive 처리 역시 여기서 이루어진다.\nHttp11Processor의 <code class=\"language-text\">service()</code> 메서드는 소켓을 통해 들어오는 HTTP 요청을 처리한다. 요청 헤더를 파싱하고 서블릿으로 요청을 위임하고 요청 상태에 따라 소켓 상태를 결정하여 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">SocketState</span> <span class=\"token function\">service</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SocketWrapperBase</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> socketWrapper<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">SocketState</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token constant\">OPEN</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">CLOSED</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">LONG</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">ASYNC_END</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">SENDFILE</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">UPGRADING</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">UPGRADED</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">ASYNC_IO</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">SUSPENDED</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SocketState service(socketWrapper) {\n    요청 정보 및 플래그 초기화\n\n    while (다양한 조건들)\n        요청 헤더 파싱 시도\n        프로토콜 준비\n        서비스 일시 중지 확인\n        요청 헤더 파싱\n        업그레이드 요청 확인\n        요청 준비 및 처리\n        요청 종료 처리\n        요청 카운터 업데이트\n        sendfile 상태 처리\n\n   return 소켓 상태 결정 및 반환\n}</code></pre></div>\n<h3>Non-Persistent Connection 처리</h3>\n<p>HTTP 요청이 Non-persistent 인 경우 service 메서드는 SocketState.CLOSED 를 반환하게 된다.\n워커 스레드는 이 소켓 처리 결과가 SocketState.CLOSED일 경우, 소켓 연결을 종료하고 관련 자원을 해제한다. 아래 코드는 이러한 작업을 수행하는 부분이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handshake <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">SocketState</span> state<span class=\"token operator\">=</span><span class=\"token class-name\">SocketState</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OPEN</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Process the request from this socket</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>event<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      state <span class=\"token operator\">=</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>socketWrapper<span class=\"token punctuation\">,</span><span class=\"token class-name\">SocketEvent</span><span class=\"token punctuation\">.</span><span class=\"token constant\">OPEN_READ</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n      state <span class=\"token operator\">=</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>socketWrapper<span class=\"token punctuation\">,</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>state<span class=\"token operator\">==</span><span class=\"token class-name\">SocketState</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CLOSED</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      poller<span class=\"token punctuation\">.</span><span class=\"token function\">cancelledKey</span><span class=\"token punctuation\">(</span><span class=\"token function\">getSelectionKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>socketWrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 <code class=\"language-text\">getHandler().process()</code>는 Http11Processor의 process 메서드를 호출하는 부분이다.\n코드 마지막의 if문에서 process 메서드의 반환값이 SocketState.CLOSED일 때, <code class=\"language-text\">poller.cancelledKey()</code>를 호출해 연결을 종료하는 것을 확인할 수 있다.</p>\n<p>HTTP 요청이 Non-persistent 인지 판단하는 조건은 여러 가지 있는데 Non-persistent에 해당하는 조건이면 keepAlive 변수를 false로 변경하고 service() 메서드의 반환값으로 SocketState.CLOSED 를 리턴한다. 판단 조건은 대표적으로 아래와 같은 것들이 있다.</p>\n<h4>HTTP/1.0 으로 호출하는 경우</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>protocolMB<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Constants</span><span class=\"token punctuation\">.</span><span class=\"token constant\">HTTP_10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    http09 <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    http11 <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    keepAlive <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>   </code></pre></div>\n<h4>keep-alive 최대 요청이 1이거나 최대 요청을 초과한 경우</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> maxKeepAliveRequests <span class=\"token operator\">=</span> protocol<span class=\"token punctuation\">.</span><span class=\"token function\">getMaxKeepAliveRequests</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>maxKeepAliveRequests <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// keep-alive max=1 인 경우</span>\n    keepAlive <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>maxKeepAliveRequests <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> socketWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">decrementKeepAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// keep-alive max값 보다 요청을 더 많이 한 경우</span>\n    keepAlive <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>HTTP 응답 상태코드가 200 범위가 아닌 경우</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">checkExpectationAndResponseStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">hasExpectation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">isRequestBodyFullyRead</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n            <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span><span class=\"token function\">getStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">200</span> <span class=\"token operator\">||</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">getStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">299</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Client sent Expect: 100-continue but received a</span>\n        <span class=\"token comment\">// non-2xx final response. Disable keep-alive (if enabled)</span>\n        <span class=\"token comment\">// to ensure that the connection is closed. Some clients may</span>\n        <span class=\"token comment\">// still send the body, some may send the next request.</span>\n        <span class=\"token comment\">// No way to differentiate, so close the connection to</span>\n        <span class=\"token comment\">// force the client to send the next request.</span>\n        inputBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">setSwallowInput</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        keepAlive <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>요청 헤더에 Connection: close 로 명시한 경우</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">MimeHeaders</span> headers <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">getMimeHeaders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Check connection header</span>\n<span class=\"token class-name\">MessageBytes</span> connectionValueMB <span class=\"token operator\">=</span> headers<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Constants</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CONNECTION</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionValueMB <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>connectionValueMB<span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> tokens <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">TokenList</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseTokenList</span><span class=\"token punctuation\">(</span>headers<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Constants</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CONNECTION</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Constants</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CLOSE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        keepAlive <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Constants</span><span class=\"token punctuation\">.</span><span class=\"token constant\">KEEP_ALIVE_HEADER_VALUE_TOKEN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        keepAlive <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Persistent Connection 처리</h3>\n<p>Persistent Connection이 유지되는 조건은 위의 Non-Persistent 요청이 아니라면 Keep-Alive 가 동작하여 소켓 연결을 계속 유지한다.\n이는 HTTP 헤더에 <code class=\"language-text\">Connection: Keep-alive</code> 를 명시하지 않아도 기본값으로 Keep-alive가 동작된다는 얘기이다.\n대신 response 헤더에 <code class=\"language-text\">Connection: Keep-alive</code> 와 <code class=\"language-text\">Keep-Alive: timeout=60, max=1000</code>와 같은 헤더가 나오지 않으니 클라이언트를 위해 명시적으로 요청하는것이 좋다.</p>\n<p>Persistent Connection 은 <code class=\"language-text\">server.tomcat.keep-alive-timeout</code> 속성을 통해 이루어진다.\n만약 keep-alive-timeout 동안 어떤 read/write 활동도 없다면 해당 연결은 종료된다.</p>\n<p>그럼 keep-alive-timeout은 어떻게 처리될까?\nTomcat은 클라이언트와 처음 연결한 후, Read Timeout을 기준으로 타임아웃 여부를 판단한다.\nRead Timeout 내에 클라이언트로부터 데이터가 도착하면 요청을 정상적으로 처리하고 응답한다.\n만약 이 요청이 Persistent Connection 요청이라면, Read Timeout 값을 keep-alive-timeout으로 바꾼다.\n그리고 나서는 이전에 설명한 Read/Write 타임아웃 관리 방식으로 연결을 계속 유지하고 관리한다.</p>\n<p>만약 클라이언트의 요청이 keep-alive-timeout 내에 계속 들어온다면, 해당 연결의 타임아웃은 계속해서 초기화되어 연결이 지속된다.\n이는 타임아웃이 현재 시간과 소켓에서 마지막으로 Read/Write한 시간을 기준으로 계산되기 때문이다.</p>\n<p>서버에서 연결을 유지하려고 해도 클라이언트도 해당 연결을 유지해야 keep-alive가 제대로 작동한다.\n예를 들어, curl을 사용하여 keep-alive로 요청을 보내도 curl 프로그램이 종료될 때 클라이언트에서 소켓을 먼저 닫아버리기 때문에 Persistent Connection은 유지되지 않는다.</p>\n<p>그리고 keep-alive의 주요 목적은 이미 맺어진 연결을 재사용하는 것이다.\n따라서 클라이언트가 새로운 소켓을 통해 요청을 보내면, 서버와는 새로운 연결이 형성된다. 이 경우, 다른 소켓에서 유지되는 Persistent Connection과는 별개로 동작하므로 재사용할 수 없다.</p>\n<h2>정리</h2>\n<p>Tomcat에서는 연결들을 타임아웃의 관점에서 어떻게 관리하는지, 특히 Read/Write Timeout과 Persistent Connection에 초점을 맞춰 살펴보았다.\n이 과정에서 busy wait 방식을 사용하여 지속적으로 타임아웃을 검사하는 것을 확인했다.\n더불어, Tomcat에서는 <code class=\"language-text\">read-timeout</code> 또는 <code class=\"language-text\">write-timeout</code> 없이 <code class=\"language-text\">connection-timeout</code> 이라는 명칭으로 타임아웃 값을 설정하는데,\n이는 Persistent Connection의 경우 <code class=\"language-text\">keep-alive-timeout</code>으로 변경되기 때문에 <code class=\"language-text\">connection-timeout</code> 명칭을 쓰지 않았나 싶다.</p>","frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?","date":"October 07, 2023","update":"October 07, 2023","tags":["Tomcat"],"series":null},"fields":{"slug":"/tomcat-connection/","readingTime":{"minutes":17.165}}},"seriesList":{"edges":[{"node":{"id":"bad021b0-8468-5808-8daa-8cf3434c19ae","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"1c3bf38a-5822-589b-ae08-5e0182388d1a","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"68b667f0-fbb0-5312-bba3-7728df4a1d74","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"22d5ddb1-57c0-5f00-8699-cefd462d1666","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"137b1767-6e4e-5fdf-a9f9-0b3798cbe37e","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"7a8cd6aa-bb6e-55b4-9854-4288e54769ee","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"0d8cea97-6f8f-5e28-b4ad-7e48cc2d2e46","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"645ed70a-de7e-58f4-a2a3-cb643a99e30a","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"0cf94437-bd98-5772-bde9-914727aa343e","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"130946b3-e281-5f87-8dd1-cef00be4a774","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"34735664-ed59-5784-a071-1227717349e3","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"a2c4d2d8-b012-5449-9251-3bcc368876ea","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"ee53721c-3561-5f47-9065-76762ebce369","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"0ee045de-1f2e-5326-840b-f7513c16f2d7","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"b3880869-c0db-5d58-948e-92985250cf2d","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"cf31c6e7-91a8-55a7-beea-5dca2e2460fa","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"bbcc04f9-2935-5753-9a7e-cd8fdfcc662c","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"f3e9b018-dcf2-5066-be00-909086dcbff2","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"d7818847-fabd-52c1-94c6-4907e05a3490","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"c7e63a70-6b62-52e8-ac0f-d5dcdecd7147","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"1cda8db3-a1d2-56f9-85e0-29bac23a0650","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"09549337-253c-501f-ba42-533815a37e3c","fields":{"slug":"/\benabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcd2238-18eb-57ef-9cd3-c0177a3c1954","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"d814ac35-d925-5139-ac77-ee416f12dbcb","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"ff41f5b0-73ba-5595-aebb-35db1d98dc0b","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"814be12c-5d81-5869-910d-04f5c3fce410","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"784bc412-aba6-543c-bf75-23eaddb9ed64","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"d488972a-385d-5d13-bbfe-08c074fa8372","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"2dd75ae1-e168-5f46-a340-b7f8dd712d7a","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"2db7d058-3179-54bf-ac47-0b4f61b8e897","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"f1907721-044b-5781-8b3f-9df0fbf38ec8","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"bb461b3a-0c19-5caf-9d09-08989e720b7f","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"7db557d3-1629-5af3-8bd3-f8cfdfa845d7","fields":{"slug":"/java-nio-buffer/"},"frontmatter":{"title":"Java NIO 파헤치기 - Buffer"}}},{"node":{"id":"d1df0b87-5078-5aa9-a1a5-560935978720","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}}]},"previous":{"fields":{"slug":"/java-nio-buffer/"},"frontmatter":{"title":"Java NIO 파헤치기 - Buffer"}},"next":null},"pageContext":{"id":"d1df0b87-5078-5aa9-a1a5-560935978720","series":null,"previousPostId":"7db557d3-1629-5af3-8bd3-f8cfdfa845d7","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}