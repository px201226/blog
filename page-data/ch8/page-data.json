{"componentChunkName":"component---src-templates-post-jsx","path":"/ch8/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"645ed70a-de7e-58f4-a2a3-cb643a99e30a","excerpt":"분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 다르다. 뭔가 잘못될 수 있고 새롭고 흥미진진한 방법이 많다는 점이다. 이번장은 분산 시스템에서 잘못될지도 모르는 것에 관한 개요이다. 결함과 부분 장애 단일 컴퓨터에서 실행되는 소프트웨어는 하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다. 좋은 소프트웨어가 설…","html":"<ul>\n<li>\n<p>분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 다르다.</p>\n<ul>\n<li>뭔가 잘못될 수 있고 새롭고 흥미진진한 방법이 많다는 점이다.</li>\n</ul>\n</li>\n<li>이번장은 분산 시스템에서 잘못될지도 모르는 것에 관한 개요이다.</li>\n</ul>\n<!-- more -->\n<h2 id=\"결함과-부분-장애\" style=\"position:relative;\">결함과 부분 장애<a href=\"#%EA%B2%B0%ED%95%A8%EA%B3%BC-%EB%B6%80%EB%B6%84-%EC%9E%A5%EC%95%A0\" aria-label=\"결함과 부분 장애 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>단일 컴퓨터에서 실행되는 소프트웨어는 하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다.</li>\n<li>좋은 소프트웨어가 설치된 각각의 컴퓨터는 보통 완전하게 동작하거나 전체 장애가 발생하지 그 중간 상태가 되지는 않는다.</li>\n<li>네트워크로 연결된 여러 컴퓨터에서 실행되는 소프트웨어를 작성할 때는 근본적으로 상황이 다르다.</li>\n<li>분산 시스템에서는 시스템의 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장난다. 이를 <code class=\"language-text\">부분 장애(partial failure)</code>라고 한다. <code class=\"language-text\">부분 장애는 비결정적이라서 어렵다.</code></li>\n<li>비결정성과 부분 장애 가능성이 분산 시스템을 다루게 어렵게 한다.</li>\n</ul>\n<aside>\n💡  신뢰성 없는 구성 요서를 사용해 신뢰성 있는 시스템 구축하기 \n<p>네트워크의 오류 수정 코드, TCP 프로토콜이 대표적인 예이다.</p>\n<p>오류 수정 코드는 무선 네트워크에서 발생하는 전파 장애 등의 이유로 일부 비트가 잘못되는 통신 채널을 통해 디지털 데이터를 정확히 전송할 수 있게 한다.</p>\n<p>TCP는 신뢰성이 없는 IP 계층 위에서 손실된 패킷을 재전송하고 중복된 것은 제거하여 패킷을 보낸 수넛에 맞춰 재조립되도록 보장해준다.</p>\n</aside>\n<h2 id=\"신뢰성-없는-네트워크\" style=\"position:relative;\">신뢰성 없는 네트워크<a href=\"#%EC%8B%A0%EB%A2%B0%EC%84%B1-%EC%97%86%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC\" aria-label=\"신뢰성 없는 네트워크 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>분산 시스템을 구축하는 유일한 방법은 아니지만 몇 가지 이유로 인터넷 서비스로 구축하는 방법이 주된 방법이 됐다.</li>\n<li>인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크다.</li>\n<li>노드에서 다른 노드로 패킷을 보낼 수 있지만 네트워크는 패킷이 언제 도착할지 혹은 메시지가 도착하기는 할 것인지 보장하지 않는다.</li>\n<li>\n<p>요청을 보내고 응답을 기다릴 때 여러가지가 잘못될 수 있다.</p>\n<ul>\n<li>요청이 손실됐을 수 있다.</li>\n<li>요청이 큐에서 대기하다 나중에 전송될 수 있다.</li>\n<li>원격 노드의 장애</li>\n<li>원격 노드의 일시적인 중지</li>\n<li>원격 노드 응답의 손실</li>\n<li>원격 노드 응답의 지연</li>\n</ul>\n</li>\n<li>이런 문제를 다루는 흔한 방법은 <code class=\"language-text\">타임아웃</code>이다. 얼마 간의 시간이 지나면 응답 대기를 멈추고 응답이 도착하지 않는다고 가정한다.</li>\n</ul>\n<h4>현실의 네트워크 결함</h4>\n<ul>\n<li>아직 신뢰성 있는 네트워크를 만드는데 성공하지 못했다.</li>\n<li>네트워크 중단의 주요 원인인 인적 오류로부터 보호해주지 못하기 때문이다.</li>\n<li>네트워크 결함이 드물더라도 <strong>일어날 수 있고</strong> 소프트웨어가 이를 처리할 수 있어야 한다.</li>\n<li>반드시 네트워크 결함을 견뎌내도록 처리할 필요는 없다.</li>\n<li>네트워크가 평상시에는 상당히 믿을 만하다면 네트워크에 문제가 있을 때 그냥 사용자에게 오류 메시지를 보여주는 것도 타당한 방법이다.</li>\n</ul>\n<h4>결함 감지</h4>\n<ul>\n<li>\n<p>많은 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.</p>\n<ul>\n<li>로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다.</li>\n<li>단일 리더 복제를 사용한다면 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 한다.</li>\n</ul>\n</li>\n<li>하지만 네트워크에 관한 불확실성 때문에 노드가 동작 중인지 아닌지 구별하기 어렵다.</li>\n<li>뭔가 동작하지 않는다고 명시적으로 알려주는 피드백을 받을 수 있다.</li>\n</ul>\n<h3 id=\"타임아웃과-기약-없는-지연\" style=\"position:relative;\">타임아웃과 기약 없는 지연<a href=\"#%ED%83%80%EC%9E%84%EC%95%84%EC%9B%83%EA%B3%BC-%EA%B8%B0%EC%95%BD-%EC%97%86%EB%8A%94-%EC%A7%80%EC%97%B0\" aria-label=\"타임아웃과 기약 없는 지연 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>타임아웃만이 결함을 감지하는 확실한 수단이라면 타임아웃은 얼마나 길어야 될까?</li>\n<li>타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다.</li>\n<li>\n<p>타임아웃이 짧으면 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아진다.</p>\n<ul>\n<li>노드가 죽었다고 선언되면 그 노드의 책무를 다른 노드로 전달돼야 해서 다른 노드와 네트워크에 추가적인 부하를 준다.</li>\n</ul>\n</li>\n<li>비동기 네트워크는 패킷을 가능한 빨리 보내려고 하지만 패킷이 도착하는 데 걸리는 시간에 상한치는 없다.</li>\n<li>서버 구현은 대부분 어떤 최대 시간 내에 요청을 처리한다고 보장할 수 없다.</li>\n</ul>\n<h4>네트워크 혼잡과 큐 대기</h4>\n<ul>\n<li>자동차를 운전할 때 코통 체증 때문에 이동 시간이 달리지는 것 처럼 컴퓨터 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.</li>\n<li>여러 장비가 같은 목적지로 네트워크 트래픽을 보내면 스위치 큐가 가득찰 수 있다.</li>\n<li>\n<p>TCP는 타임아웃 안에 확인 응답을 받지 않으면 패킷이 손실됐다고 간주하고 손실된 패킷은 자동으로 재전송한다.</p>\n<ul>\n<li>애플리케이션에서는 패킷 손실이나 재전송이 보이지 않지만 그 결과로 생기는 지연은 보인다.</li>\n</ul>\n</li>\n<li>지연의 변동성이 얼마나 되는지 알아내는 방법은 어렵다.</li>\n<li>더 좋은 방법으로는 고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 그들의 변동성을 측정하고 관찰된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하게 하는 것이다. 카산드라가 사용한다.</li>\n</ul>\n<aside>\n💡 화상 회의나 인터넷 전화처럼 지연 시간에 민간함 애플리케이션은 TCP 대신 UDP를 사용한다.\n신뢰성과 지연 변동성 사이에 트레이드오프 관계가 있다. UDP는 흐름 제어를 하지 않고 손실된 패킷을 재전송하지 않으므로 네트워크 지연이 크게 변하게 하는 원인 중 일부를 제거한다.\n</aside>\n<h3 id=\"동기-네트워크-대-비동기-네트워크\" style=\"position:relative;\">동기 네트워크 대 비동기 네트워크<a href=\"#%EB%8F%99%EA%B8%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8C%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC\" aria-label=\"동기 네트워크 대 비동기 네트워크 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>동기식 네트워크가 대표적인 예는 고정 회선 전화 네트워크다.</p>\n<ul>\n<li>전화 네트워크는 극단적인 신뢰성을 지닌다.</li>\n<li>음성 프레임이 지연되거나 통화가 유실되는 일은 매우 드물다.</li>\n<li>통화를 할 때 회선(circuit)이 만들어지고 통화를 하는 두 명 사이에 있는 전체 경로를 따라서 그 통화에 대해 고정되고 보장된 양의 대역폭이 만들어진다.</li>\n<li>데이터가 여러 라우터를 거치더라도 큐 대기 문제를 겪지 않는다.</li>\n</ul>\n</li>\n<li>회선은 만들어져 있는 동안 다른 누구도 사용할 수 없는 고정된 양의 예약된 대역폭이지만 TCP 연결의 패킷은 가용한 네트워크 대역폭을 기회주의적으로 사용한다.</li>\n<li>\n<p>인터넷 네트워크는 회선 교환 방식으로 패킷을 교환한다.</p>\n<ul>\n<li>이들은 순간적으로 몰리는 트래픽에 최적화됐기 때문이다.</li>\n<li>통화는 초당 비트 개수가 고정돼지만 웹 페이지 요청은 가능하면 빨리 완료되기만 하면 된다.</li>\n<li>순간적으로 몰리는 데이터 전송에 전용 회선을 쓰면 네트워크 용량을 낭비하고 전송이 불필요하게 느려진다.</li>\n<li>TCP는 가용한 네트워크 용량에 맞춰 데이터 전송률을 동적으로 조절한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"신뢰성-없는-시계\" style=\"position:relative;\">신뢰성 없는 시계<a href=\"#%EC%8B%A0%EB%A2%B0%EC%84%B1-%EC%97%86%EB%8A%94-%EC%8B%9C%EA%B3%84\" aria-label=\"신뢰성 없는 시계 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>네트워크에 있는 개별 장비는 자신의 시계를 갖고 있다.</li>\n<li>이 장치는 정확하지 않아서 각 장비는 자신만의 시간 개념이 있으며 이는 다른 장비보다 약간 빠를 수도 느릴 수도 있다.</li>\n</ul>\n<h3 id=\"단조-시계-대-일-기준-시계\" style=\"position:relative;\">단조 시계 대 일 기준 시계<a href=\"#%EB%8B%A8%EC%A1%B0-%EC%8B%9C%EA%B3%84-%EB%8C%80-%EC%9D%BC-%EA%B8%B0%EC%A4%80-%EC%8B%9C%EA%B3%84\" aria-label=\"단조 시계 대 일 기준 시계 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>컴퓨터는 최소 두 가지 종류의 시계를 갖고 있다.</p>\n<ul>\n<li><strong>일 기준 시계(time-of-day clock)</strong></li>\n<li><strong>단조 시계(monotonic clock)</strong></li>\n</ul>\n</li>\n</ul>\n<h4><strong>일 기준 시계(time-of-day clock)</strong></h4>\n<ul>\n<li>\n<p>일 기준 시계는 현재 날짜와 시간을 반환한다.</p>\n<ul>\n<li>예를 들어 자바의 <code class=\"language-text\">System.currentTimeMillis()</code>는 <code class=\"language-text\">에포크(epoch</code>) 이래로 흐른 밀리초를 반환한다.</li>\n<li>에포크(epoch)란 UTC(협정세계시) 1970년 1월 1일 자정을 가르킨다.</li>\n</ul>\n</li>\n<li>일 기준 시계는 보통 NTP로 동기화 된다.</li>\n<li>로컬 시계가 NTP 서버 보다 너무 앞서면 강제로 리셋되어 과거 시점으로 거꾸로 뛰는 것처럼 보일 수 있다.</li>\n</ul>\n<h4><strong>단조 시계(monotonic clock)</strong></h4>\n<ul>\n<li>\n<p>단조 시계는 타임아웃이나 서비스 응답 시간 같은 시간 구간을 재는 데 적합하다.</p>\n<ul>\n<li>자바의 <code class=\"language-text\">System.nanoTime()</code> 이 있다.</li>\n</ul>\n</li>\n<li>\n<p>단조 시계란 이름은 항상 앞으로 흐른다는 사실에서 나왔다.</p>\n<ul>\n<li>일 기준 시계는 시간이 거꾸로 뛸 수도 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"시계-동기화와-정확도\" style=\"position:relative;\">시계 동기화와 정확도<a href=\"#%EC%8B%9C%EA%B3%84-%EB%8F%99%EA%B8%B0%ED%99%94%EC%99%80-%EC%A0%95%ED%99%95%EB%8F%84\" aria-label=\"시계 동기화와 정확도 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>단조 시계는 동기화가 필요 없지만 일 기준 시계는 NTP서버로 동기화되어야 한다.</li>\n<li>하드웨어 시계나 NTP 서버는 시계 정확도에 오차가 생길 수 있다.</li>\n<li>\n<p>충돌 해소 전략 중 하나인 <code class=\"language-text\">최종 쓰기 승리(last write wins, LWW)</code> 는 이런 시간의 오차로 문제가 발생할 수 도 있다.</p>\n<ul>\n<li>따라서 가장 최근 값을 유지하고 다른 것들을 버림으로써 충돌을 해소하고 싶어도 <strong>최근</strong>의 정의는 로컬 일 기준 시계에 의존하며 그 시계는 틀릴 수 있다는 것을 아는게 중요하다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"지식-진실-그리고-거짓말\" style=\"position:relative;\">지식, 진실, 그리고 거짓말<a href=\"#%EC%A7%80%EC%8B%9D-%EC%A7%84%EC%8B%A4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B1%B0%EC%A7%93%EB%A7%90\" aria-label=\"지식 진실 그리고 거짓말 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>분산 시스템에는 공유 메모리가 없고 지연 변동이 큰 신뢰할 수 없는 네트워크를 통해 메시지를 보낼 수 있을 뿐이며 부분 장애, 신뢰성 없는 시계, 프로세스 중단에 시달릴 수 있다.</li>\n<li>원격 노드가 응답하지 않으면 그 노드가 어떤 상태에 있는지 알 방법은 없다.</li>\n<li>분산 시스템에서 우리는 동작에 관해 정한 가정을 명시하고, 이런 가정을 만족시키는 방식으로 실제 시스템을 설계 할 수 있다.</li>\n<li>이번 장의 나머지 부분에서 분산 시스템의 지식과 진실에 관한  개념을 살펴본다.</li>\n</ul>\n<h3 id=\"진실은-다수결로-결정된다\" style=\"position:relative;\">진실은 다수결로 결정된다<a href=\"#%EC%A7%84%EC%8B%A4%EC%9D%80-%EB%8B%A4%EC%88%98%EA%B2%B0%EB%A1%9C-%EA%B2%B0%EC%A0%95%EB%90%9C%EB%8B%A4\" aria-label=\"진실은 다수결로 결정된다 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>분산 시스템은 한 노드에만 의존할 수는 없다. 노드에 언제든 장애가 나서 잠재적으로 시스템이 멈추고 복구할 수 없게 될 수 있기 때문이다.</li>\n<li>\n<p>여러 분산 알고리즘은 정족수, 즉 노드들 사이의 투표에 의존한다.</p>\n<ul>\n<li>특정한 노드 하나에 대한 의존을 줄이기 위해 결정을 하려면 여러 노드로부터 어떤 최소 개수의 투표를 받아야 한다.</li>\n</ul>\n</li>\n</ul>\n<h4>리더와 잠금</h4>\n<ul>\n<li>분산 시스템에서 어떤 노드를 선택하는 행위<code class=\"language-text\">(파티션의 리더, 잠금을 획득한 자, 사용자명을 차지는데 성공한 사용자의 요청)</code>는 주의해야한다.</li>\n<li>어떤 노드가 이전에 리더였더라도 시간이 흐른 사이에 다른 노드들이 그 노드가 죽었다고 선언하면 그 노드는 강등되고 다른 리더가 이미 선출됐을지도 모르기 때문이다.</li>\n<li>분산 잠금을 잘못 구현 : 클라이언트 1은 임차권이 마료됐는데도 여전히 유효하다고 생각해서 저장소에 있는 파일을 오염시킨다.</li>\n</ul>\n<h4>펜싱 토큰</h4>\n<ul>\n<li>위의 분산 잠금 문제를 해결하기 위해서는 자신이 <code class=\"language-text\">선택된 자</code>라고 잘못 믿고 있는 노드가 나머지 시스템을 방해할 수 없도록 보장해야 한다.</li>\n<li>이 목적을 달성하는 기법으로 <code class=\"language-text\">펜싱(fencing)</code>이 있다.</li>\n<li>\n<p>잠금 서버가 잠금이나 임차권을 승인할 때마다 <code class=\"language-text\">펜싱 토큰</code>도 반환하도록 한다.</p>\n<ul>\n<li>펜싱 토큰은 잠금이 될 때마다 증가하는 숫자다.</li>\n<li>클라이언트가 쓰기 요청을 할 때 이 펜싱 토큰을 함께 보내 현재 알고 있는 펜싱 토큰값과 비교하여 선택된 자를 식별할 수 있다.</li>\n</ul>\n</li>\n<li>이 메커니즘은 오래된 토큰을 사용해서 쓰는 것을 거부함으로써 토큰을 확인 역활을 한다.</li>\n</ul>\n<h3 id=\"비잔틴-결함\" style=\"position:relative;\">비잔틴 결함<a href=\"#%EB%B9%84%EC%9E%94%ED%8B%B4-%EA%B2%B0%ED%95%A8\" aria-label=\"비잔틴 결함 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>노드가 거짓말(임의의 결함이 있거나 오염된 응답을 보냄)을 할지도 모른다는 위험이 있다면 훨씬 더 어려워진다.</p>\n<ul>\n<li>펜신 토큰에서 클라이언트는 고의로 가짜 펜신 토큰을 보내면 시스템의 보장을 무너뜨릴 수 있다.</li>\n</ul>\n</li>\n<li>어떤 노드가 실제로는 받지 않은 메시지를 받았다고 주장할 수 있는데 이런 동작을 <code class=\"language-text\">비잔틴 결함(Byzantine fault)</code>라고 한다.</li>\n<li>이렇게 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 <code class=\"language-text\">비잔틴 장군 문제</code>라고 한다.</li>\n<li>일부 노드가 오동작하고 프로토콜을 준수하지 않거나 악의적인 공격자가 네트워크를 방해하더라도 시스템에 계속 올바르게 동작한다면 <code class=\"language-text\">비잔틴 내결함성을 지닌다</code>라고 한다.</li>\n<li>\n<p>웹 애플리케이션은 웹브라우저 같은 클라이언트 행동이 임의적이고 악의적이라고 예상해야 한다. 이는 입력 확인, 변환, 출력 이스케이핑이 중요한 이유다.</p>\n<ul>\n<li>예를 들어 SQL 인젝션이나 XSS 같은 해킹을 막아야 한다.</li>\n</ul>\n</li>\n<li>대부분의 비잔틴 내결함성 알고리즘은 노드의 2/3 이상의 다수가 올바르게 동작하기를 요구한다.</li>\n</ul>\n<h3 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>분산 시스템에서 나타날 수 있는 문제는 광범위하다.</p>\n<ul>\n<li>네트워크 결함</li>\n<li>노드 간 시계의 오차</li>\n<li>원격노드의 상태를 알 수 없는 문제</li>\n</ul>\n</li>\n<li>대부분의 분산 알고리즘은 원격 노드를 아직 쓸 수 있는지 결정하기 위해 타임아웃을 사용한다.</li>\n<li>분산 시스템에선 한 노드에만 의존할 수 없으므로 정족수를 이용하는 프로토콜이 필요하다.</li>\n</ul>","frontmatter":{"title":"8장 - 분산 시스템의 골칫거리","date":"February 02, 2022","update":"February 02, 2022","tags":["데이터 중심 애플리케이션 설계"],"series":null},"fields":{"slug":"/ch8/","readingTime":{"minutes":19.365}}},"seriesList":{"edges":[{"node":{"id":"bad021b0-8468-5808-8daa-8cf3434c19ae","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"1c3bf38a-5822-589b-ae08-5e0182388d1a","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"68b667f0-fbb0-5312-bba3-7728df4a1d74","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"22d5ddb1-57c0-5f00-8699-cefd462d1666","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"137b1767-6e4e-5fdf-a9f9-0b3798cbe37e","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"7a8cd6aa-bb6e-55b4-9854-4288e54769ee","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"0d8cea97-6f8f-5e28-b4ad-7e48cc2d2e46","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"645ed70a-de7e-58f4-a2a3-cb643a99e30a","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"0cf94437-bd98-5772-bde9-914727aa343e","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"130946b3-e281-5f87-8dd1-cef00be4a774","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"34735664-ed59-5784-a071-1227717349e3","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"a2c4d2d8-b012-5449-9251-3bcc368876ea","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"ee53721c-3561-5f47-9065-76762ebce369","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"0ee045de-1f2e-5326-840b-f7513c16f2d7","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"b3880869-c0db-5d58-948e-92985250cf2d","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"cf31c6e7-91a8-55a7-beea-5dca2e2460fa","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"bbcc04f9-2935-5753-9a7e-cd8fdfcc662c","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"f3e9b018-dcf2-5066-be00-909086dcbff2","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"d7818847-fabd-52c1-94c6-4907e05a3490","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"c7e63a70-6b62-52e8-ac0f-d5dcdecd7147","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"1cda8db3-a1d2-56f9-85e0-29bac23a0650","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"09549337-253c-501f-ba42-533815a37e3c","fields":{"slug":"/\benabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcd2238-18eb-57ef-9cd3-c0177a3c1954","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"d814ac35-d925-5139-ac77-ee416f12dbcb","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"ff41f5b0-73ba-5595-aebb-35db1d98dc0b","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"814be12c-5d81-5869-910d-04f5c3fce410","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"784bc412-aba6-543c-bf75-23eaddb9ed64","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"d488972a-385d-5d13-bbfe-08c074fa8372","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"2dd75ae1-e168-5f46-a340-b7f8dd712d7a","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"2db7d058-3179-54bf-ac47-0b4f61b8e897","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"f1907721-044b-5781-8b3f-9df0fbf38ec8","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"bb461b3a-0c19-5caf-9d09-08989e720b7f","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"d1df0b87-5078-5aa9-a1a5-560935978720","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"4e19ecdf-4b0a-5c17-b791-a4ef410644d8","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}},{"node":{"id":"0c587f26-df98-5bfd-8cfb-b25bd55ecd65","fields":{"slug":"/socket_internal/"},"frontmatter":{"title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅"}}}]},"previous":{"fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}},"next":{"fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},"pageContext":{"id":"645ed70a-de7e-58f4-a2a3-cb643a99e30a","series":null,"previousPostId":"0d8cea97-6f8f-5e28-b4ad-7e48cc2d2e46","nextPostId":"0cf94437-bd98-5772-bde9-914727aa343e"}},"staticQueryHashes":[],"slicesMap":{}}