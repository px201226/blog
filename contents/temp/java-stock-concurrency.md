
## 재고 관리로 보는 동시성 문제
동시성은 여러 작업을 '겉보기에' 동시에 처리하는 것을 의미한다.
이는 멀티스레딩과는 별개의 개념으로, 싱글 스레드 환경에서도 이벤트 루프나 콜백 등을 통해 구현할 수 있다.
동시에 병렬로 실행된다는 것과는 다르며, 단일 CPU 코어에서 작업이 빠르게 전환되면서 동시에 실행되는 것처럼 보일 수 있다.

동시성은 일반적으로 멀티스레딩과 관련이 있지만 멀티스레딩에서 발생하는 문제는 분산 시스템에서 발생하는 문제와 유사하다.
멀티스레딩이나 분산 시스템이나 결국에는 하나의 공통된 목적을 달성하기 위해 컴퓨팅 리소스를 최대한 활용하기 때문에 서로 겹치는 부분이 많을 수 밖에 없다.
그래서 여기서는 동시성을 멀티스레딩 환경에 국한하지 않으려고 한다.

동시성 시스템은 다양한 동시성 모델을 사용하여 구현할 수 있다.
동시성 모델은 쓰레드 또는 시스템 사이에서 상태를 공유하는 모델과 상태를 공유하지 않는 모델로 나눌 수 있다.   
![img_1.png](java-stock-concurrency%2Fimg_1.png)
![img_2.png](java-stock-concurrency%2Fimg_2.png)

공유 상태 모델은 경쟁 조건(Race Condition)이나 데드락 같은 문제가 발생할 수 있지만 구현이 쉬운 이유로 많은 시스템에서 사용하는 방식이다.
Java의 대부분의 동시성 유틸(Locking, Atomic, synchronized 등)이 공유 상태 모델을 구현하는데 사용된다.   
상태를 공유하지 않는 모델은 일반적인 동시성 문제를 피할 수 있지만 구현 난이도가 높은 편이다. 
스레드 간 상태 동기화는 메시지 전달(Message passing)을 통해 구현된다.
메시지 전달은 Queue, Pipe, Socket 통신 등을 통해 구현할 수 있다.



## 동시성과 락
### 전통적인 동시성 관리, 고유락(Intrinsic Lock)

### 고유락(Intrinsic Lock)의 문제점


## Lock-Free 알고리즘



## Compare And Swap(CAS) 알고리즘
