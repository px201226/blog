<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>6장 - 파티셔닝 | 끄적끄적 개발일지</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://www.googletagmanager.com/gtag/js?id=G-SE0BLFFFMG"></script>
    <meta name="description" content="Awesome description">
    
    <link rel="preload" href="/assets/css/0.styles.4bffb705.css" as="style"><link rel="preload" href="/assets/js/app.70752fd1.js" as="script"><link rel="preload" href="/assets/js/17.4dcf5890.js" as="script"><link rel="preload" href="/assets/js/30.c221f26d.js" as="script"><link rel="prefetch" href="/assets/js/10.1fe66b22.js"><link rel="prefetch" href="/assets/js/11.3e8e6dd5.js"><link rel="prefetch" href="/assets/js/12.96743d99.js"><link rel="prefetch" href="/assets/js/13.5cab9bdd.js"><link rel="prefetch" href="/assets/js/14.e412fb10.js"><link rel="prefetch" href="/assets/js/15.1da5e3dc.js"><link rel="prefetch" href="/assets/js/16.8ebbd2f8.js"><link rel="prefetch" href="/assets/js/18.5bfa6a85.js"><link rel="prefetch" href="/assets/js/19.12bd999a.js"><link rel="prefetch" href="/assets/js/2.0c177ed1.js"><link rel="prefetch" href="/assets/js/20.87648ee0.js"><link rel="prefetch" href="/assets/js/21.7fbb071c.js"><link rel="prefetch" href="/assets/js/22.3f3676f6.js"><link rel="prefetch" href="/assets/js/23.114b4211.js"><link rel="prefetch" href="/assets/js/24.7077956a.js"><link rel="prefetch" href="/assets/js/25.42ad01f0.js"><link rel="prefetch" href="/assets/js/26.c356a4d4.js"><link rel="prefetch" href="/assets/js/27.52a125bd.js"><link rel="prefetch" href="/assets/js/28.692ecc68.js"><link rel="prefetch" href="/assets/js/29.d205c4cb.js"><link rel="prefetch" href="/assets/js/3.6ee8ed88.js"><link rel="prefetch" href="/assets/js/31.65e9c8ce.js"><link rel="prefetch" href="/assets/js/32.7ddfb0f5.js"><link rel="prefetch" href="/assets/js/33.7f74862d.js"><link rel="prefetch" href="/assets/js/34.21b19958.js"><link rel="prefetch" href="/assets/js/35.428cdea5.js"><link rel="prefetch" href="/assets/js/36.ef46a37e.js"><link rel="prefetch" href="/assets/js/37.290a8b87.js"><link rel="prefetch" href="/assets/js/38.61002123.js"><link rel="prefetch" href="/assets/js/39.fbbd1cce.js"><link rel="prefetch" href="/assets/js/4.39bb3471.js"><link rel="prefetch" href="/assets/js/40.ee500a11.js"><link rel="prefetch" href="/assets/js/41.ce50acc7.js"><link rel="prefetch" href="/assets/js/42.b0e56f29.js"><link rel="prefetch" href="/assets/js/43.c4683cd4.js"><link rel="prefetch" href="/assets/js/44.4fd9959c.js"><link rel="prefetch" href="/assets/js/45.10201422.js"><link rel="prefetch" href="/assets/js/5.6b61195e.js"><link rel="prefetch" href="/assets/js/6.d4a6ae6d.js"><link rel="prefetch" href="/assets/js/7.8da69c67.js"><link rel="prefetch" href="/assets/js/8.8044f9c2.js"><link rel="prefetch" href="/assets/js/9.8e23472b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4bffb705.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light" style="background:#F3F5F7;"><div class="v-application--wrap"><div class="container pa-0" style="max-width:900px;"><link href="https://fonts.googleapis.com/css?family=Jura" rel="stylesheet"> <div class="text-center py-8 v-toolbar__title v-app-bar-title" style="font-family:'Jura';"><div class="v-app-bar-title__content"><h1 class="primary--text">끄적끄적 개발일지</h1></div><div class="v-app-bar-title__placeholder" style="visibility:visible;"><h1 class="primary--text">끄적끄적 개발일지</h1></div></div> <div role="list" class="v-list pa-0 v-sheet theme--light v-list--flat transparent"><div role="listbox" class="v-item-group theme--light v-list-item-group indigo--text"><div class="row mb-0 text-center no-gutters justify-center"><div class="col-lg-2 col"><a href="/" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2  v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Home</div></a></div> <div class="col-lg-2 col"><a href="/category" aria-current="page" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-item--active v-list-item--active v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Category</div></a></div> <div class="col-lg-2 col"><a href="/profiles" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Profiles</div></a></div></div></div></div> <hr role="separator" aria-orientation="horizontal" class="mb-3 v-divider theme--light"> <div><div data-v-52bca676><div class="px-0 col col-12" data-v-52bca676 data-v-52bca676><div class="pa-5 px-md-7 v-card v-sheet theme--light elevation-1" data-v-52bca676><div data-v-52bca676><a href="/category/db-oriented-design/ch6.html" aria-current="page" class="text-h4 font-weight-bold router-link-exact-active router-link-active" data-v-52bca676><div data-v-52bca676><!----></div>
          6장 - 파티셔닝
        </a> <br data-v-52bca676> <span class="text-caption grey--text text--darken-1 " data-v-52bca676>2022-01-28 &gt; 데이터 중심 애플리케이션 설계
        </span></div> <hr role="separator" aria-orientation="horizontal" class="mt-4 mb-4 v-divider theme--light" data-v-52bca676> <div class="theme-container" data-v-52bca676><div class="toc" data-v-52bca676><ul><li><a href="/category/db-oriented-design/ch6.html#파티셔닝과-복제">파티셔닝과 복제</a></li><li><a href="/category/db-oriented-design/ch6.html#키-값-데이터-파티셔닝">키-값 데이터 파티셔닝</a><ul><li><a href="/category/db-oriented-design/ch6.html#키-범위-기준-파티셔닝">키 범위 기준 파티셔닝</a></li><li><a href="/category/db-oriented-design/ch6.html#키의-해시값-기준-파티셔닝">키의 해시값 기준 파티셔닝</a></li><li><a href="/category/db-oriented-design/ch6.html#쏠린-작업부하와-핫스팟-완화">쏠린 작업부하와 핫스팟 완화</a></li></ul></li><li><a href="/category/db-oriented-design/ch6.html#파티셔닝과-보조-색인">파티셔닝과 보조 색인</a><ul><li><a href="/category/db-oriented-design/ch6.html#문서-기준-보조-색인-파티셔닝">문서 기준 보조 색인 파티셔닝</a></li><li><a href="/category/db-oriented-design/ch6.html#용어-기준-보조-색인-파티셔닝">용어 기준 보조 색인 파티셔닝</a></li></ul></li><li><a href="/category/db-oriented-design/ch6.html#파티션-재균형화">파티션 재균형화</a><ul><li><a href="/category/db-oriented-design/ch6.html#재균형화-전략">재균형화 전략</a></li><li><a href="/category/db-oriented-design/ch6.html#운영-자동-재균형화와-수동-재균형화">운영: 자동 재균형화와 수동 재균형화</a></li></ul></li><li><a href="/category/db-oriented-design/ch6.html#요청-라우팅">요청 라우팅</a><ul><li><a href="/category/db-oriented-design/ch6.html#병렬-질의-실행">병렬 질의 실행</a></li></ul></li><li><a href="/category/db-oriented-design/ch6.html#정리">정리</a><ul><li><a href="/category/db-oriented-design/ch6.html#파티셔닝-기법">파티셔닝 기법</a></li><li><a href="/category/db-oriented-design/ch6.html#보조-파티셔닝-기법">보조 파티셔닝 기법</a></li></ul></li></ul></div> <div class="theme-default-content custom post markdown-body content__default" data-v-52bca676><h2 id="파티셔닝과-복제"><a href="#파티셔닝과-복제" class="header-anchor">#</a> 파티셔닝과 복제</h2> <ul><li>데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로 부족하고 데이터를 파티션으로 쪼갤 필요가 있다. 이 작업을 <code>샤딩</code>이라고 한다.</li> <li>파티션을 나눌 때는 보통 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 한다.</li> <li>데이터 파티셔닝을 원하는 주된 이유는 <strong>확장성</strong>이다.</li> <li>보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.</li></ul> <aside>
💡 몽고DB, 엘라스틱서치, 솔라클라우드의 샤드(shared), HBase에서는 리전(region), 빅테이블에서는 태블릿(tablet), 카산드라, 리악에서는 브이노드(vnode), 카우치베이스에서는 브이버켓(vBucket)이라 부른다.
</aside> <h2 id="키-값-데이터-파티셔닝"><a href="#키-값-데이터-파티셔닝" class="header-anchor">#</a> 키-값 데이터 파티셔닝</h2> <ul><li>파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.</li> <li>파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 <strong>쏠렸다(skewed)</strong> 고 말한다.</li> <li>불균형하게 부하가 높은 파티션을 <code>핫스팟</code>이라고 한다.</li> <li>어떤 레코드를 어느 노드에 저장해야 할까?</li></ul> <h3 id="키-범위-기준-파티셔닝"><a href="#키-범위-기준-파티셔닝" class="header-anchor">#</a> 키 범위 기준 파티셔닝</h3> <ul><li>종이 백과사전처럼 각 파티션에 연속된 범위의 키를 할당한다.</li> <li>각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다.</li> <li>키 범위의 경계는 데이터에 맞춰 조정해야 한다. 데이터가 키 경계별로 고르게 분포하지 않을 수도 있기 때문이다.</li> <li>키 범위 기준 파티셔닝은 접근 패턴이 핫스팟을 유발할 수도 있다.
<ul><li>특정 키에만 부하가 물려 해당 파티션만 과부하가 걸리고 나머지 파티션은 유휴 상태로 남아 있을 수 있다.</li></ul></li> <li>빅테이블, HBase, 리싱크DB, 2.4버전 이전의 몽고DB에서 사용된다.</li></ul> <h3 id="키의-해시값-기준-파티셔닝"><a href="#키의-해시값-기준-파티셔닝" class="header-anchor">#</a> 키의 해시값 기준 파티셔닝</h3> <ul><li>쏠림과 핫스팟의 위험ㄷ 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는데 해시 함수를 사용한다.</li> <li>카산드라와 몽고DB는 MD5를 사용한다.</li> <li>각 파티션에 해시값 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당하면 된다.</li> <li>키의 해시값을 사용해서 파티셔닝을 하면 정렬 순서가 유지되지 않아 범위 질의를 처리하는데 불리해진다.</li> <li>리악, 카우치베이스,볼트모트에서는 기본키에 대한 범위 질의가 지원되지 않는다.</li> <li>카산드라는 두 가지 파티셔닝 전략 모두 사용한다.
<ul><li>카산드라에서 테이블을 선언할 때 여러 컬럼을 포함하는 <strong>복합키</strong>를 지정할 수 있다.</li> <li>키의 첫 부분만 해싱을 적용하고 나머지 컬럼은 SS테이블에서 데이터를 정렬하는 색인을 사용한다.</li> <li>첫 번째 컬럼에 대해서는 범위 질의를 쓸 수 없지만, 첫 번째 컬럼을 고정된 값으로 지정하면 다른 컬럼에 대해서는 범위 스캔을 수행할 수 있다.</li></ul></li></ul> <h3 id="쏠린-작업부하와-핫스팟-완화"><a href="#쏠린-작업부하와-핫스팟-완화" class="header-anchor">#</a> 쏠린 작업부하와 핫스팟 완화</h3> <ul><li>해시값 기준 파티셔닝은 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다.</li> <li>현대 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야 한다.
<ul><li>예를 들어, 요청이 쏠리는 키를 발견했을 때, 임의의 숫자 2개만 붙이더라도 작업이 100개의 다른 키로 균등하게 분산된다.</li> <li>어떤 키가 쪼개졌는지 추적할 방법도 있어야 한다.</li></ul></li></ul> <h2 id="파티셔닝과-보조-색인"><a href="#파티셔닝과-보조-색인" class="header-anchor">#</a> 파티셔닝과 보조 색인</h2> <ul><li>보조 색인은 보통 특정한 값이 발생한 항목을 검색하는 수단이다.</li> <li>보조 색인은 관계형 데이터베이스의 핵심 요소이며 솔라나 엘라스틱서치 같은 검색 서버에게는 <strong>존재의 이유</strong>다.</li> <li>보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다.</li></ul> <h3 id="문서-기준-보조-색인-파티셔닝"><a href="#문서-기준-보조-색인-파티셔닝" class="header-anchor">#</a> 문서 기준 보조 색인 파티셔닝</h3> <ul><li>고유 ID 기준으로 문서를 파티셔닝한다.</li> <li>각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다.</li> <li>데이터베이스에서 문서 추가, 삭제, 갱신 등의 쓰기 작업을 실행할 때는 쓰려고 하는 문서 ID를 포함하는 파티션만 다루면 된다.</li> <li>그러한 까닭에 문서 파티셔닝 색인은 <code>지역 색인(local index)</code> 라도도 부른다.</li> <li>보조 색인의 모든 데이터가 한 파티셔닝에 없을 수도 있다. 따라서 모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.</li> <li>이런식의 질의를 보내는 방법을 <code>스캐터/개더(scatter/gather)</code>라고 한다.</li> <li>몽고DB, 리악, 카산드라, 엘라스틱서치, 솔라클라우드, 볼트DB는 모두 문서 기준 보조 색인을 사용한다.</li></ul> <h3 id="용어-기준-보조-색인-파티셔닝"><a href="#용어-기준-보조-색인-파티셔닝" class="header-anchor">#</a> 용어 기준 보조 색인 파티셔닝</h3> <ul><li>예를 들어 보조 색인의 a-r 까지의 글자로 시작하면 파티션 0에, s-z까지의 글자로 시작하는 색깔은 파티션 1에 저장되도록 파티셔닝한다.</li> <li>찾고자 하는 용어에 따라 색인의 파티션이 결정되므로 이런 식의 색인을 용어 기준으로 파티셔닝됐다라고 한다.</li> <li><strong>용어</strong>라는 이름은 전문 색인에서 나왔는데 문서에 등장하는 모든 단어를 말한다.</li> <li>문서 파티셔닝 색인에 비해 <code>전역(용여 파티셔닝)</code> 색인이 갖는 이점은 읽기가 효율적이라는 것이다.</li> <li>하지만 전역 색인은 쓰기가 느리고 복잡하다는 단점이 있다.</li> <li>단일 문서를 쓸 때 해당 색인의 여러 파티셔네 영향을 줄 수 있기 때문이다.</li> <li>현실에서는 전역 보조 색인은 대게 비동기로 갱신된다.
<ul><li>아마존 다이나모DB는 정상적인 상황에는 전역 보조 색인을 갱신하는데 1초도 안걸린다.</li></ul></li></ul> <h2 id="파티션-재균형화"><a href="#파티션-재균형화" class="header-anchor">#</a> 파티션 재균형화</h2> <ul><li>시간이 지나면 데이터베이스에 변화가 생긴다.
<ul><li>질의 처리량이 증가해서 늘어난 부하를 처리하기 위해 CPU를 추가하고 싶다.</li> <li>데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가하고 싶다.</li> <li>장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비가 넘겨받아야 한다.</li></ul></li> <li>이런 변화가 생기면 데이터 요청이 한 노드에서 다른 노드로 옮겨야 하는데 이런 과정을 <code>재균형화(rebalancing)</code>라고 한다.</li> <li>재균형화가 실행될 때 만족시킬 것으로 기대되는 최소 요구사항이 있다.
<ul><li>재균형화 후, 부하가 노드 사이에 균등하게 분배돼야 한다.</li> <li>재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받으들여야 한다.</li> <li>재균형화가 빨리 샐행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안된다.</li></ul></li></ul> <h3 id="재균형화-전략"><a href="#재균형화-전략" class="header-anchor">#</a> 재균형화 전략</h3> <h4 id="쓰면-안되는-방법-해시값에-모드-n연산을-실행"><a href="#쓰면-안되는-방법-해시값에-모드-n연산을-실행" class="header-anchor">#</a> 쓰면 안되는 방법: 해시값에 모드 N연산을 실행</h4> <ul><li>해시값에 <code>mod</code> 연산을 쓰게 되면 노드 개수 N이 바꾸면 대부분의 키가 노드 사이에 옮겨져야 한다는 점이다.</li> <li>키가 자주 이동하면 재균형화 비용이 지나치게 커진다.</li></ul> <h4 id="파티션-개수-고정"><a href="#파티션-개수-고정" class="header-anchor">#</a> 파티션 개수 고정</h4> <ul><li>파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당하는 것이다.</li> <li>클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션 몇개를 뻇어올 수 있다.</li> <li>파티션은 노드 사이에서 통째로 이동하기만 한다. 파티션 개수는 바뀌지 않고 파티션에 할당된 키도 변경되지 않는다.</li> <li>이 방식을 사용할 때는 보통 데이터베이스가 처음 구축될 때 파티션 개수가 고정되고 이후에 변하지 않는다.</li> <li>파티션을 쪼개거나 합치는게 가능하지만 운영성 어려움이 많아 처음 설정하는 파티션 개수가 사용 가능한 노드 대수의 최대치가 되므로 미래에 증가될 것을 수용하기에 충분히 높은 값을 선택해야 한다.</li> <li>파티션이 너무 크면 재균형화를 실행할 때와 노드 장애로부터 복구할 때 비용이 크다. 파티션이 너무 작으면 오버헤드가 너무 커진다.</li> <li>파티션 크기가 적당할 때 성능이 가장 좋지만 파티션 개수는 고정돼 있고 데이터셋 크기는 변한다면 적절한 크기를 정하기 어렵다.</li></ul> <h4 id="동적-파티셔닝"><a href="#동적-파티셔닝" class="header-anchor">#</a> 동적 파티셔닝</h4> <ul><li>키 범위 파티셔닝에서 파티션의 경계와 개수가 고정돼 있는게 매우 불편하다. 이런 이유로 파티션을 동적으로 만든다.</li> <li>파티션 크기가 설정된 값을 넘어서면 파티션을 두 개로 쪼개 각각에 원래 파티션의 절반 정도의 데이터가 포함되게 한다.</li> <li>반대로 데이터가 많이 삭제되어 파티션 크기가 임계값 아래로 떨어지면 인접한 파티션과 합쳐질 수 있다.</li> <li>큰 파티션이 쪼개진 후 부하의 균형을 맞추기 위해 분할된 파티션 중 하나가 다른 노드로 이동될 수 있다.</li> <li>동적 파티셔닝은 파티션 개수가 전체 데이터에 맞춰 조정된다는 이점이 있다.
<ul><li>단, 데이터 셋이 작을 때는 모든 쓰기 요청이 하나의 노드에서 실행되고 다른 노드들은 유휴 상태에 머물게 된다.</li> <li>이 문제를 완하하기 위해서 몽고DB에서는 초기 파티션 집합을 설정할 수 있게 한다. (사전분할이라고 부른다)</li></ul></li> <li>동적 파티셔닝은 커 범위 파티셔닝뿐만 아니라 해시 파티셔닝에서도 똑같이 사용될 수 있다.</li></ul> <h4 id="노드-비례-파티셔닝"><a href="#노드-비례-파티셔닝" class="header-anchor">#</a> 노드 비례 파티셔닝</h4> <ul><li>카산드라와 케타마에서 사용되는 방법은 파티션 개수가 노드 대수에 비례하게 하는 것이다.</li> <li>노드 대수가 변함 없는 동안은 개별 파티션 크기가 데이터셋 크기에 비례해서 증가하지만 노드 대수를 늘리면 파티션 크기는 다시 작아진다.</li> <li>새 노드가 클러스터에 추가되면 고정된 개수의 파티션을 무작위로 선택해 분할하고 각 분할된 파티션의 절반은 그대로 두고 절반은 새 노드에 할당한다.</li></ul> <h3 id="운영-자동-재균형화와-수동-재균형화"><a href="#운영-자동-재균형화와-수동-재균형화" class="header-anchor">#</a> 운영: 자동 재균형화와 수동 재균형화</h3> <ul><li>완전 자동 재균형화<code>(시스템이 자동으로 언제 파티션을 노드 사이에 이동할지 결정함)</code>와 완전 수동 재균형화<code>(관리자가 명시적으로 파티션을 노드에 할당하도록 설정하고 관리자가 재설정할 때만 파티션 할당이 변경됨)</code> 사이에는 중간 지점이 있다.</li> <li>카우치베이스, 리악, 볼드모트는 자동으로 파티션 할당을 제안하지만 반영되려면 관리자가 확정해야 한다.</li> <li>완전 자동 개균형화는 유지보수에 손이 덜 가지만, 예측하기 어렵다.</li></ul> <h2 id="요청-라우팅"><a href="#요청-라우팅" class="header-anchor">#</a> 요청 라우팅</h2> <ul><li>클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속을 해야할까?
<ul><li>클라이언트가 아무 노드에 접속하게 한다.그 후, 요청을 처리할 노드로 전달해서 응답을 받는다.</li> <li>클라이언트의 모든 요청을 라우팅 계층으로 먼저 보낸다. 라우팅 계층에서는 각 요청을 처리할 노드를 알아내고 그에 따라 해당 노드에 요청을 전달한다.</li> <li>클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있게 한다.</li></ul></li> <li>모든 경우에 핵심 문제는 라우팅 결정을 내리는 구성요소<code>(노드 중 하나, 라우팅 계층, 클라이언트 측)</code>가 노드에 할당된 파티션의 변경 사항을 어떻게 아느냐다.</li> <li>많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 주키퍼 같은 별도의 코디네이션 서비스를 사용한다.
<ul><li>각 노드는 주키퍼에 자신을 등록하고 주키퍼는 파티션과 노드 사이의 신뢰성 있는 할당 정보를 관리한다.</li> <li>노드사 추가되거나 삭제되면 주키퍼는 라우팅 계층에 이를 알려서 라우터 정보를 최신화 한다.</li> <li>HBase, 솔라클라우드, 카프카 등</li></ul></li> <li><code>가십 프로토콜(gossip protocol)</code>을 사용해서 클러스터 상태 변화를 노드 사이에 전달하는 방식도 있다.
<ul><li>아무 노드나 요청을 받을 수 있고 요청을 받은 노드는 요청을 처리할 노드에게 요청을 전달한다.</li> <li>이 모델은 데이터베이스 노드에 복잡성은 더하지만 주키퍼 같은 외부 코디네이션 서비스에 의존하지 않는다.</li></ul></li></ul> <h3 id="병렬-질의-실행"><a href="#병렬-질의-실행" class="header-anchor">#</a> 병렬 질의 실행</h3> <ul><li>지금까지는 단일 키를 읽거나 간단한 질의에 대해서만 설명했다.</li> <li>그러나 분석용으로 자주 사용되는 <code>대규모 병렬 처리(MPP)</code> 관계형 데이터 베이스 제품은 훨씬 더 복잡한 종류의 질의를 지원한다.</li> <li>MPP 옵티마이저는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.</li></ul> <h2 id="정리"><a href="#정리" class="header-anchor">#</a> 정리</h2> <ul><li>저장과 처리할 데이터가 많아서 장비 한 대로 처리하는게 불가능해지면 파티셔닝이 필요하다.</li> <li>파티셔닝의 목적은 핫스팟이 생기지 않게 하면서 데이터와 질의 부하를 여러 장비에 균일하게 분배하는 것이다.</li> <li>그렇게 하려면 데이터에 적합한 파티셔닝 방식을 선택해야 하고 클러스터 노드에 추가되거나 제거될 때 파티션 재균형화를 실행해야 한다.</li></ul> <h3 id="파티셔닝-기법"><a href="#파티셔닝-기법" class="header-anchor">#</a> 파티셔닝 기법</h3> <h4 id="키-범위-파티셔닝"><a href="#키-범위-파티셔닝" class="header-anchor">#</a> 키 범위 파티셔닝</h4> <ul><li>키가 정렬돼 있고 개별 파티션은 키 범위 경계에 속한다.</li> <li>키가 정렬되어 있어 범위 질의에 효율적이지만 핫스팟이 생길 위험이 있다.</li> <li>파티션이 너무 커지면 키 범위를 두 개로 쪼개 동적으로 재균형화를 실행한다.</li></ul> <h4 id="해시-파티셔닝"><a href="#해시-파티셔닝" class="header-anchor">#</a> 해시 파티셔닝</h4> <ul><li>키에 해시 함수를 적용하여 키 범위 파티셔닝을 적용한다.</li> <li>범위 질의에 비효율적이지만 부하를 더욱 균일하게 분산할 수 있다.</li></ul> <h3 id="보조-파티셔닝-기법"><a href="#보조-파티셔닝-기법" class="header-anchor">#</a> 보조 파티셔닝 기법</h3> <h4 id="문서-파티셔닝-색인-지역-색인"><a href="#문서-파티셔닝-색인-지역-색인" class="header-anchor">#</a> 문서 파티셔닝 색인(지역 색인)</h4> <ul><li>보조 색인을 기본키와 값이 저장된 파티션에 저장한다.</li> <li>쓸 때는 파티션 하나만 갱신하면 되지만 보조 색인을 읽으려면 모든 파티션에 걸쳐서 스캐터/개더를 사용해야 한다.</li></ul> <h4 id="용어-파티셔닝-색인-전역-색인"><a href="#용어-파티셔닝-색인-전역-색인" class="header-anchor">#</a> 용어 파티셔닝 색인(전역 색인)</h4> <ul><li>색인된 값을 사용해서 보조 색인을 별도로 파티셔닝 한다.</li> <li>문서를 쓸 때는 보조 색인 여러 개를 갱신해야 하지만 읽기는 단일 파티션에서 실행될 수 있다.</li></ul></div></div></div></div> <div data-v-52bca676></div></div></div></div> <footer prime="" class="v-footer mt-2 v-sheet theme--light v-footer--padless" style="background:#F3F5F7;"><div class="col col-12"><div class="text-center v-card v-card--flat v-sheet theme--light rounded-0" style="background:#F3F5F7;"><div class="v-card__text"><p>Copyright © 2021 All Right <em>끄적끄적 개발일지</em></p> <p>
          px201226@gmail.com .
          <a href="https://github.com/px201226" target="_blank">GitHub</a>
          .
          <a href="http://px201226.github.io/blog" target="_blank">Blog</a>
          .
        </p></div></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.70752fd1.js" defer></script><script src="/assets/js/17.4dcf5890.js" defer></script><script src="/assets/js/30.c221f26d.js" defer></script>
  </body>
</html>
