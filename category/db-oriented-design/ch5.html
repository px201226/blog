<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>5장 - 복제 | 끄적끄적 개발일지</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://www.googletagmanager.com/gtag/js?id=G-SE0BLFFFMG"></script>
    <meta name="description" content="Awesome description">
    
    <link rel="preload" href="/assets/css/0.styles.4bffb705.css" as="style"><link rel="preload" href="/assets/js/app.70752fd1.js" as="script"><link rel="preload" href="/assets/js/17.4dcf5890.js" as="script"><link rel="preload" href="/assets/js/29.d205c4cb.js" as="script"><link rel="prefetch" href="/assets/js/10.1fe66b22.js"><link rel="prefetch" href="/assets/js/11.3e8e6dd5.js"><link rel="prefetch" href="/assets/js/12.96743d99.js"><link rel="prefetch" href="/assets/js/13.5cab9bdd.js"><link rel="prefetch" href="/assets/js/14.e412fb10.js"><link rel="prefetch" href="/assets/js/15.1da5e3dc.js"><link rel="prefetch" href="/assets/js/16.8ebbd2f8.js"><link rel="prefetch" href="/assets/js/18.5bfa6a85.js"><link rel="prefetch" href="/assets/js/19.12bd999a.js"><link rel="prefetch" href="/assets/js/2.0c177ed1.js"><link rel="prefetch" href="/assets/js/20.87648ee0.js"><link rel="prefetch" href="/assets/js/21.7fbb071c.js"><link rel="prefetch" href="/assets/js/22.3f3676f6.js"><link rel="prefetch" href="/assets/js/23.114b4211.js"><link rel="prefetch" href="/assets/js/24.7077956a.js"><link rel="prefetch" href="/assets/js/25.42ad01f0.js"><link rel="prefetch" href="/assets/js/26.c356a4d4.js"><link rel="prefetch" href="/assets/js/27.52a125bd.js"><link rel="prefetch" href="/assets/js/28.692ecc68.js"><link rel="prefetch" href="/assets/js/3.6ee8ed88.js"><link rel="prefetch" href="/assets/js/30.c221f26d.js"><link rel="prefetch" href="/assets/js/31.65e9c8ce.js"><link rel="prefetch" href="/assets/js/32.7ddfb0f5.js"><link rel="prefetch" href="/assets/js/33.7f74862d.js"><link rel="prefetch" href="/assets/js/34.21b19958.js"><link rel="prefetch" href="/assets/js/35.428cdea5.js"><link rel="prefetch" href="/assets/js/36.ef46a37e.js"><link rel="prefetch" href="/assets/js/37.290a8b87.js"><link rel="prefetch" href="/assets/js/38.61002123.js"><link rel="prefetch" href="/assets/js/39.fbbd1cce.js"><link rel="prefetch" href="/assets/js/4.39bb3471.js"><link rel="prefetch" href="/assets/js/40.ee500a11.js"><link rel="prefetch" href="/assets/js/41.ce50acc7.js"><link rel="prefetch" href="/assets/js/42.b0e56f29.js"><link rel="prefetch" href="/assets/js/43.c4683cd4.js"><link rel="prefetch" href="/assets/js/44.4fd9959c.js"><link rel="prefetch" href="/assets/js/45.10201422.js"><link rel="prefetch" href="/assets/js/5.6b61195e.js"><link rel="prefetch" href="/assets/js/6.d4a6ae6d.js"><link rel="prefetch" href="/assets/js/7.8da69c67.js"><link rel="prefetch" href="/assets/js/8.8044f9c2.js"><link rel="prefetch" href="/assets/js/9.8e23472b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4bffb705.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light" style="background:#F3F5F7;"><div class="v-application--wrap"><div class="container pa-0" style="max-width:900px;"><link href="https://fonts.googleapis.com/css?family=Jura" rel="stylesheet"> <div class="text-center py-8 v-toolbar__title v-app-bar-title" style="font-family:'Jura';"><div class="v-app-bar-title__content"><h1 class="primary--text">끄적끄적 개발일지</h1></div><div class="v-app-bar-title__placeholder" style="visibility:visible;"><h1 class="primary--text">끄적끄적 개발일지</h1></div></div> <div role="list" class="v-list pa-0 v-sheet theme--light v-list--flat transparent"><div role="listbox" class="v-item-group theme--light v-list-item-group indigo--text"><div class="row mb-0 text-center no-gutters justify-center"><div class="col-lg-2 col"><a href="/" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2  v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Home</div></a></div> <div class="col-lg-2 col"><a href="/category" aria-current="page" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-item--active v-list-item--active v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Category</div></a></div> <div class="col-lg-2 col"><a href="/profiles" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Profiles</div></a></div></div></div></div> <hr role="separator" aria-orientation="horizontal" class="mb-3 v-divider theme--light"> <div><div data-v-52bca676><div class="px-0 col col-12" data-v-52bca676 data-v-52bca676><div class="pa-5 px-md-7 v-card v-sheet theme--light elevation-1" data-v-52bca676><div data-v-52bca676><a href="/category/db-oriented-design/ch5.html" aria-current="page" class="text-h4 font-weight-bold router-link-exact-active router-link-active" data-v-52bca676><div data-v-52bca676><!----></div>
          5장 - 복제
        </a> <br data-v-52bca676> <span class="text-caption grey--text text--darken-1 " data-v-52bca676>2022-01-23 &gt; 데이터 중심 애플리케이션 설계
        </span></div> <hr role="separator" aria-orientation="horizontal" class="mt-4 mb-4 v-divider theme--light" data-v-52bca676> <div class="theme-container" data-v-52bca676><div class="toc" data-v-52bca676><ul><li><a href="/category/db-oriented-design/ch5.html#리더와-팔로워">리더와 팔로워</a><ul><li><a href="/category/db-oriented-design/ch5.html#동기식-대-비동기식-복제">동기식 대 비동기식 복제</a></li><li><a href="/category/db-oriented-design/ch5.html#새로운-팔로워-설정">새로운 팔로워 설정</a></li><li><a href="/category/db-oriented-design/ch5.html#노드-중단-처리">노드 중단 처리</a></li><li><a href="/category/db-oriented-design/ch5.html#복제-로그-구현">복제 로그 구현</a></li></ul></li><li><a href="/category/db-oriented-design/ch5.html#복제-지연-문제">복제 지연 문제</a><ul><li><a href="/category/db-oriented-design/ch5.html#자신이-쓴-내용-읽기">자신이 쓴 내용 읽기</a></li><li><a href="/category/db-oriented-design/ch5.html#단조-읽기">단조 읽기</a></li><li><a href="/category/db-oriented-design/ch5.html#일관된-순서로-읽기">일관된 순서로 읽기</a></li><li><a href="/category/db-oriented-design/ch5.html#복제-지연을-위한-해결책">복제 지연을 위한 해결책</a></li></ul></li><li><a href="/category/db-oriented-design/ch5.html#다중-리더-복제">다중 리더 복제</a><ul><li><a href="/category/db-oriented-design/ch5.html#다중-리더-복제의-사용-사례">다중 리더 복제의 사용 사례</a></li><li><a href="/category/db-oriented-design/ch5.html#쓰기-충돌-다루기">쓰기 충돌 다루기</a></li><li><a href="/category/db-oriented-design/ch5.html#다중-리더-복제-토폴리지">다중 리더 복제 토폴리지</a></li></ul></li><li><a href="/category/db-oriented-design/ch5.html#리더-없는-복제">리더 없는 복제</a><ul><li><a href="/category/db-oriented-design/ch5.html#노드가-다운됐을-때-데이터베이스에-쓰기">노드가 다운됐을 때 데이터베이스에 쓰기</a></li><li><a href="/category/db-oriented-design/ch5.html#정족수-일관성의-한계">정족수 일관성의 한계</a></li><li><a href="/category/db-oriented-design/ch5.html#느슨한-정족수와-암시된-핸드오프">느슨한 정족수와 암시된 핸드오프</a></li><li><a href="/category/db-oriented-design/ch5.html#동시-쓰기-감지">동시 쓰기 감지</a></li></ul></li><li><a href="/category/db-oriented-design/ch5.html#정리">정리</a></li></ul></div> <div class="theme-default-content custom post markdown-body content__default" data-v-52bca676><ul><li><strong>복제</strong> 란 네트워크로 연결된 여러 장비에 동일한 데이터 복사본을 유지한다는 의미이다.</li> <li>데이터 복제가 필요한 이유는 다음과 같다.
<ul><li>지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.</li> <li>시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.</li> <li>읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.</li></ul></li> <li>복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다.</li> <li>노드 간 복제를 위한 세 가지 인기 알고리즘이 있다.
<ul><li><strong>단일 리더 (single-leader)</strong></li> <li><strong>다중 리더 (multi-leader)</strong></li> <li><strong>리더 없는 (leaderless)</strong></li></ul></li></ul> <h2 id="리더와-팔로워"><a href="#리더와-팔로워" class="header-anchor">#</a> 리더와 팔로워</h2> <ul><li>데이터베이스의 복사본을 저장하는 각 노드를 <strong>복제 서버(replica)</strong> 라고 한다.</li> <li>모든 복제서버의 동일한 데이터를 유지하기 위해 데이터베이스의 모든 쓰기는 복제 서버에서 처리돼야 한다.</li> <li>이 문제를 위한 가장 일반적인 해결책은 <code>리더 기반 복제(마스터 슬레이브 복제</code>)이다. 동작은 다음과 같다.
<ul><li>클라이언트가 데이터베이스에 쓰기를 할 때 요청을 리더에게 보내야 한다.</li> <li>리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.</li> <li>리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송한다.</li> <li>각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.</li> <li><strong>클라이언트가 데이터베이스로부터 읽기를 할 때는 리더 또는 팔로워에게 질의할 수 있지만, 쓰기는 리더에게만 허용된다.</strong></li></ul></li></ul> <h3 id="동기식-대-비동기식-복제"><a href="#동기식-대-비동기식-복제" class="header-anchor">#</a> 동기식 대 비동기식 복제</h3> <ul><li>복제 시스템의 중요한 세부 사항은 복제가 <strong>동기식</strong>으로 발생하는지 <strong>비동기식</strong>으로 발생하는지 여부이다.</li> <li><code>팔로워 1</code>의 복제는 동기식 복제이다. 리더는 <code>팔로워 1</code>이 쓰기를 수신했느지 확인해 줄 때까지 기다린다.</li> <li><code>팔로워 2</code>의 복제는 비동기식이다. 리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다.</li> <li>동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.</li> <li>단점은 팔로워가 죽거나 다른 어떤 이유로 인해 동기 팔로워가 응답하지 않으면 쓰기가 처리될 수 없다는 뜻이다.</li> <li>현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 <strong>할로워 하나</strong>는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미한다.</li> <li>동기식 팔로워가 사용할 수 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 된다. 이런 설정을 <code>반동식(semi-synchronous)</code>이라 한다.</li></ul> <h3 id="새로운-팔로워-설정"><a href="#새로운-팔로워-설정" class="header-anchor">#</a> 새로운 팔로워 설정</h3> <ul><li>때대로 복제 서버수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다.</li> <li>클라이언트는 지속적으로 데이터베이스에 기록하고 데이터는 항상 유동적이기 때문에 표준 파일 복사본은 다른 시점에 데이터베이스의 다른 부분을 보게 된다.</li> <li>다행이 팔로워 설증은 대게 중단시간 없이 수행할 수 있다.
<ul><li>리더의 데이터베이스 스냅숏을 일정 시점에 가져온다.</li> <li>스냅숏을 새로운 노드에 복사한다.</li> <li>팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다. 이것은 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 한다. 이 위치의 명칭을 MySQL 에서는 <code>이진로그 좌표(binlog coordinate)</code> 라 부른다.</li> <li>팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두처리했을 때 따라잡았다고 한다.</li></ul></li></ul> <h3 id="노드-중단-처리"><a href="#노드-중단-처리" class="header-anchor">#</a> 노드 중단 처리</h3> <h4 id="팔로워-장애-따라잡기-복구"><a href="#팔로워-장애-따라잡기-복구" class="header-anchor">#</a> 팔로워 장애: 따라잡기 복구</h4> <ul><li>각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관한다.</li> <li>팔로워가 죽어 재시작하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 로그를 통해 쉽게 복구 할 수 있다.
<ul><li>먼저 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.</li> <li>트랜잭션 이후 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청한다.</li></ul></li></ul> <h4 id="리더-장애-장애-복구"><a href="#리더-장애-장애-복구" class="header-anchor">#</a> 리더 장애: 장애 복구</h4> <ul><li>팔로워 중 하나를 새로운 리더로 변경해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 <strong>장애 복구(failover)</strong> 라 한다.
<ul><li><strong>리더가 장애인지 판단한다.</strong> 대부분의 시스템은 타임아웃을 사용해 노드가 죽은 것으로 판단한다.</li> <li><strong>새로운 리더를 선택한다.</strong> 이전에 선출된 제어 노드(controller node)에 의해 새로운 리더가 임명될 수 있다. 보통 리더의 최신 데이터 변경사항을 가진 복제 서버가 된다.</li> <li><strong>새로운 리더 사용을 위해 시스템을 재설정한다.</strong> 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있게끔 해야 한다.</li></ul></li></ul> <h3 id="복제-로그-구현"><a href="#복제-로그-구현" class="header-anchor">#</a> 복제 로그 구현</h3> <h4 id="구문-기반-복제-statement-based-replication"><a href="#구문-기반-복제-statement-based-replication" class="header-anchor">#</a> 구문 기반 복제 (Statement-Based Replication)</h4> <ul><li>리더는 모든 쓰기 요청을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송한다.</li> <li>관계형 데이터베이스는 모든 INSERT, UPDATE, DELETE 구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에서 직접 받은 것처럼 SQL 구문을 파싱하고 실행한다.</li> <li>이 접근법은 복제가 깨질 수 있는 사례가 있다.
<ul><li><code>NOW(), RAND()</code> 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 수 있다.</li> <li>자동증가 컬럼을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존한다면 각 복제서버에서 정확히 같은 순서로 실행돼야 한다. 그렇지 않으면 효과가 달라질 수 있다.</li> <li>부수 효과를 가진 구문<code>(트리거, 스토어드 프로시저, 사용자 정의 함수)</code>은  부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.</li></ul></li> <li>해결책으로 리더는 구문을 기록할 때 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체할 수 있다.</li></ul> <aside>
💡 MySQL 5.1 이전 버전에서 구문 기반 복제가 사용되고 구문에 비결정성이 있다면 로구 기반 복제(row-based replication)으로 변경한다.
</aside> <h4 id="쓰기-전-로그-배송"><a href="#쓰기-전-로그-배송" class="header-anchor">#</a> 쓰기 전 로그 배송</h4> <ul><li>일반적으로 모든 쓰기는 로그에 기록된다.</li> <li>리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.</li> <li>팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제본이 만들어진다.</li> <li>이 복제 방식의 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다.
<ul><li>쓰기 전 로그(WAL)은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함한다.</li> <li>이렇게 하면 복제가 저장소 엔진과 밀접하게 엮이는 문제가 발생한다.</li></ul></li></ul> <h4 id="로우-기반-로그-복제"><a href="#로우-기반-로그-복제" class="header-anchor">#</a> 로우 기반 로그 복제</h4> <ul><li>복제 로그를 저장소 엔진 내부와 분리하기 위한 대안으로 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이다.</li> <li>이 같은 종류의 복제 로그를 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그라고 부른다.
<ul><li>삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.</li> <li>삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함한다.</li> <li>갱신된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보와 모든 칼럼의 새로운 값을 포함한다.</li></ul></li> <li>여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랙잭션이 커밋됐음을 레코드에 표시한다.</li> <li>논리적 로그는 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있고 다른 버전의 데이터베이스 소프트웨어나 심지어 다른 저장소 엔진을 실행할 수 있다.</li> <li>논리적 로그 형식은 외부 애플리케이션에서 파싱하기 더 쉽다. 색이이나 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다. 이 기술을 <code>변경 데이터 캡처(chage data capture)</code>라 부른다.</li></ul> <h4 id="트리거-기반-복제"><a href="#트리거-기반-복제" class="header-anchor">#</a> 트리거 기반 복제</h4> <ul><li>지금까지 설명한 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현된다.</li> <li>데이터의 서브셋만 복제하거나 데이터베이스를 다른 종류의 DB로 복제해야 하거나 충돌 해소 로직이 필요하다면 복제를 애플리케이션 층으로 옮겨야 한다.</li> <li>트리거난 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다.</li> <li>이 테이블로부터 데이터 변경을 외부 프로세스가 읽고 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.</li> <li>이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생하지만 유연성 때문에 유용하다.</li></ul> <h2 id="복제-지연-문제"><a href="#복제-지연-문제" class="header-anchor">#</a> 복제 지연 문제</h2> <ul><li>복제는 내결합성에만 필요한 것이 아니라 확장서으 지연시간 등의 이유로 필요할 수 있다.</li> <li>리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하고 읽기 전용 질의는 어떤 복제 서버에서도 가능하다.</li> <li>애플리케이션이  비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수 도 있다.</li> <li>하지만 데이터베이스에 쓰기를 멈추고 잠시 동안 기다린다면 팔로워는 결국 리더와 일치하게 되는데 이런 효과를 <strong>최종적 일관성</strong>이라고 한다.</li> <li>애플리케이션에서 지연이 크면 불일치 문제가 발생할 수 있고 해결 방법을 간략히 설명한다.</li></ul> <h3 id="자신이-쓴-내용-읽기"><a href="#자신이-쓴-내용-읽기" class="header-anchor">#</a> 자신이 쓴 내용 읽기</h3> <ul><li>비동기식 복제 방식에서 문제는 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터가 복제 서버에 반영되지 않아 사용자가 제출한 데이터가 유실된 것 처럼 보일 수 있다.</li> <li>이런 상황에서는 <code>쓰기 후 읽기 일관성</code>이 필요하다. 이것은 사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.</li> <li>쓰기 후 읽기 일관성을 구현하는 방법은 다음과 같다.
<ul><li>사용자가 수정한 내용을 읽을 때는 리더에서 읽고 그 밖에는 팔로워에서 읽는다.
<ul><li>실제로 질의하지 않고 무엇이 수정됐는지 알 수 있는 방법이 필요하다.</li> <li>예를 들어 SNS에서 항상 사용자 소유의 프로필은 리더에서 읽고 다른 사용자의 프로필은 팔로워에서 읽는 간단한 규칙을 사용한다.</li> <li>애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면 이 접근 방식은 효율적이지 않다.</li> <li>이런 경우에는 마지막 생신 시각을 찾아서 특정 시간동안은 리더에서 모든 읽기를 수행하도록 한다.</li> <li>또한 팔로워에서 복제 지연을 모니터링해 리더보다 특정 시간 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.</li></ul></li> <li>클라이언트가 가장 최그 쓰기의 타임스탬프를 기억할 수 있다.
<ul><li>시스템 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다.</li> <li>복제 서버가 최신 내용이 아닌 경우에는 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 질의를 대기시킬 수 있다.</li></ul></li></ul></li></ul> <h3 id="단조-읽기"><a href="#단조-읽기" class="header-anchor">#</a> 단조 읽기</h3> <ul><li>비동기식 복제 방식의 두번째 문제로 사용자가 <strong>시간이 거꾸로 흐르는 현상</strong>을 목격할 수 있다는 것이다.</li> <li>리더에서 쓰기 한 내용이 팔로워 1,2 에 반영되는 시점에 차이가 생기게 되면 최신 복제 서버를 읽었을 땐 데이터가 반환되지만 아직 쓰기가 반영되지 않은 복제 서버를 읽었을 땐 아무것도 반환되지 않을 수 있다.</li> <li><code>단조 읽기(monotonic read)</code>는 이런 종류의 이상 현상이 발생하지 않음을 보장한다.</li></ul> <h3 id="일관된-순서로-읽기"><a href="#일관된-순서로-읽기" class="header-anchor">#</a> 일관된 순서로 읽기</h3> <ul><li>각각의 팔로워의 지연 때문에 일련의 쓰기 순서가 바뀌는 이상 현상이 발생할 수 있다.</li> <li>이런 종류의 이상 현상을 방지하려면 <code>일관된 순서 읽기(Consistent Prfix Read)</code> 같은 보장이 필요하다.</li> <li>일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.</li></ul> <h3 id="복제-지연을-위한-해결책"><a href="#복제-지연을-위한-해결책" class="header-anchor">#</a> 복제 지연을 위한 해결책</h3> <ul><li>앞서 설명한 것처럼 애플리케이션이 기본 데이터베이스보다 더 강력한 보장을 제공하는 할 수 있지만 애플리케이션 코드에서 이 문제를 다루기에는 너무 복잡해서 잘못되기 쉽다. <code>(ex: 특정 종류의 리더에서 읽기 수행)</code></li> <li>트랜잭션은 애플리케이션이 더 단순해지기 위해 데이터베이스가 강력한 보장을 제공하는 방법이다.</li> <li>하지만 분산 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다.</li> <li>트랜잭션 성능과 가용성 측면에서 너무 비싸고, 확장 가능 시스템에서는 어쩔 수 없이 최종적 일관성을 사용해야 한다는 주장이 있다.</li> <li>남은 부분에서는 이 미묘한 차이를 다루고, 여러 대안 메커니즘을 설명한다.</li></ul> <h2 id="다중-리더-복제"><a href="#다중-리더-복제" class="header-anchor">#</a> 다중 리더 복제</h2> <ul><li>단일 리더 복제는 어떤 이유로 리더에 연결할 수 없다면 데이터베이스에 쓰기를 할 수 없다는 단점이 있다.</li> <li>리더 기반 복제 모델은 쓰기를 허용하는 노드를 하나 이상 두는 것으로 자연스럽게 확장된다.</li> <li>이 방식을 <strong>다중 리더</strong> 설정<code>(마스터/마스터)</code>라고 한다.</li></ul> <h3 id="다중-리더-복제의-사용-사례"><a href="#다중-리더-복제의-사용-사례" class="header-anchor">#</a> 다중 리더 복제의 사용 사례</h3> <h4 id="다중-데이터센터-운영"><a href="#다중-데이터센터-운영" class="header-anchor">#</a> 다중 데이터센터 운영</h4> <ul><li>각 데이터센터마다 리더와 팔로워를 가질 수 있다.</li> <li>데이터센터 내에는 리더 팔로워 복제를 사용하고 데이터센터 간에는 각 데이터센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제한다.</li> <li>단일 리더 설정과 다중 리더 설정이 다중 데이터센터에서의 비교이다.
<ul><li>다중 리더 설정에서 모든 쓰기는 로컬 데이터센터에서 처리한 다음 비동기 방식으로 다른 데이터센터에 복제한다. <strong>사용자가 인지하는 성능은 더 좋아진다.</strong></li> <li>단일 리더 설정에서는 리더가 있는 데이터센터가 고장 나면 장애 복구를 위해 다른 데이터센터에서 팔로워를 리더로 승진시킨다. 다중 리더 설정에서는 데이터센터가 독립적으로 동작하여 <strong>데이터센터 중단 내성을 가진다.</strong></li> <li>단일 리더 설정에서는 데이터센터 내 연결의 쓰기는 동기식이기 때문에 데이터센터 내 연결 문제에 매우 민감하다. 비동기 복제를 사용하는 다중 리더 설정은 네트워크 문제에 보다 잘 견딘다.</li></ul></li> <li>다중 리더 복제에는 이점이 있지만 큰 단점도 있다.
<ul><li>동일한 데이터를 다른 두 개의 데이터 센터에서 동시에 변경할 수 있다. 이때 발생하는 쓰기 충돌은 반드시 해걀해야 한다.</li></ul></li></ul> <h4 id="오프라인-작업을-하는-클라이언트"><a href="#오프라인-작업을-하는-클라이언트" class="header-anchor">#</a> 오프라인 작업을 하는 클라이언트</h4> <ul><li>다중 리더 복제가 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우다.</li> <li>오프라인 상태에서 데이터를 변경하면 디바이스가 다음에 온라인 상태가 됐을 때 서버와 다른 디바이스를 동기화해야 한다.</li> <li>이 경우 모든 디바이스에는 리더처럼 동작하는 로컬 데이터베이스가 있다.</li> <li>그리고 모든 디바이스 상에서 복제 서버 간 다중 리더 복제를 비동기 방식으로 수행하는 프로세스(동기화)가 있다.</li></ul> <h4 id="협업-편집"><a href="#협업-편집" class="header-anchor">#</a> 협업 편집</h4> <ul><li>동시에 여러 사람이 문서를 편집할 수 있는 애플리케이션을 실시간 협업 편집 애플리케이션이라고 한다.</li> <li>한 사용자가 문서를 편집할 때 변경 내용을 즉시 로컬 복제 서버에 적용하고 나서 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제한다.</li> <li>편집 충돌이 없음을 보장하려면 애플리케이션은 사용자가 편집하기 전에 문서의 잠금을 얻어야 한다.</li> <li>하지만 더 빠른 협업을 위해 변경 단위를 매우 작게(예를 들면 단일 키 입력) 해서 잠금을 피할 수 있다.</li></ul> <h3 id="쓰기-충돌-다루기"><a href="#쓰기-충돌-다루기" class="header-anchor">#</a> 쓰기 충돌 다루기</h3> <ul><li>다중 리더 복제에서 제일 큰 문제는 쓰기 충돌이 발생한다는 점이다.</li></ul> <h4 id="동기-대-비동기-충돌-감지"><a href="#동기-대-비동기-충돌-감지" class="header-anchor">#</a> 동기 대 비동기 충돌 감지</h4> <ul><li>단일 리더 데이터베이스에서 첫 번째 쓰기가 완료될 때까지 두 번째 쓰기를 차단해 기다리게 하거나 두 번째 쓰기 트랜잭션을 중단해버린다.</li> <li>반면 다중 리더 설정에서는 두 쓰기는 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지한다.</li></ul> <h4 id="충돌-회피"><a href="#충돌-회피" class="header-anchor">#</a> 충돌 회피</h4> <ul><li>충돌을 처리하는 제일 간단한 전략은 충돌을 피하는 것이다.</li> <li>특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다.</li> <li>예를 들어 애플리케이션에서 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅하고 데이터센터 내 리더를 사용해 읽기와 쓰기를 하게끔 보장할 수 있다.</li> <li>한 사용자 관점에서보면 구성은 기본적으로 단일 리더이다.</li></ul> <h4 id="일관된-상태-수렴"><a href="#일관된-상태-수렴" class="header-anchor">#</a> 일관된 상태 수렴</h4> <ul><li>다중 리더 설정에서는 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않다.</li> <li>단순하게 각 복제 서버가 쓰기를 본 순서대로 적용한다면 데이터베이스의 일관성은 없는 상태가 된다.</li> <li>충돌을 해소하는 방법은 다양하다.
<ul><li>각 쓰기에 고유 ID(타임스탬프, UUID 등)을 부여하고 가장 높은 ID를 가진 쓰기를 고른다.</li> <li>각 복제 서버에 고유 ID를 부여하고 높은 숫자의 복제 서버에서 생신 쓰기가 낮은 숫자의 복제 서벙서 생신 쓰기보다 항상 우선적으로 적용되게 한다.</li> <li>어떻게든 값을 병합한다. (예를 들면 사전순)</li> <li>명시적 데이터 구조에 충돌을 기록해 모든 정보를 기록한다. 나중에 충돌을 해소하는 애플리케이션 코드를 작성한다.</li></ul></li></ul> <h4 id="사용자-정의-충돌-해소-로직"><a href="#사용자-정의-충돌-해소-로직" class="header-anchor">#</a> 사용자 정의 충돌 해소 로직</h4> <ul><li>충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다르다.</li> <li>대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.
<ul><li>쓰기 수행 중
<ul><li>복제된 변경 사항 로그에서 데이터베이스 시스템이 충돌을 감지하자마자 충돌 핸들러를 호출한다.</li></ul></li> <li>읽기 수행 중
<ul><li>충돌을 감지하면 모든 충돌 쓰기를 저장한다.</li> <li>다음 번 데이터를 읽을 때 이런 여러 버전의 데이터가 애플리케이션에 반환된다.</li> <li>애플리케이션은 사용자에게 충돌 내용을 보여주거나 자동으로 충돌을 해소할 수 있다.</li></ul></li></ul></li></ul> <h3 id="다중-리더-복제-토폴리지"><a href="#다중-리더-복제-토폴리지" class="header-anchor">#</a> 다중 리더 복제 토폴리지</h3> <ul><li>복제 토폴리지는 쓰기를 한 도느에서 다른 노드로 전달하는 통신 경로를 설명한다.</li> <li>리더가 둘 이상이라면 다양한 토폴로지 구성이 가능하다.
<ul><li><strong>전체 연결(all-to-all)</strong> <ul><li>모든 리더가 각자의 쓰기를 다른 모든 리더에게 전송한다.</li></ul></li> <li><strong>원형 토폴리지(circular topology)</strong> <ul><li>각 노드가 한의 노드로부터 쓰기르 받고, 이 쓰기를 다른 한 노드에 전달한다.</li></ul></li> <li><strong>별 모양 토폴로지</strong> <ul><li>지정된 로트 노드 하나가 다른 모든 노드에 쓰기를 전달한다.</li></ul></li></ul></li> <li>원형과 별 모양 토폴리지의 문제점은 하나의 노드에 장애가 발생하면 장애가 다른 노드 간 복제 메시지 흐름에 방해를 준다.</li> <li>전체 연결 토폴로지는 여러 경로를 따라 이동할 수 있으며 단일 장애점을 피할 수 있기 때문에 내결함성이 좋다.</li> <li>하지만 일부 네트워크 연결이 다른 연결보다 빠르면 일부 복제 메시지가 다른 메시지를 추월하여 잘못된 순서로 메시지가 도착할 수 있다.</li></ul> <h2 id="리더-없는-복제"><a href="#리더-없는-복제" class="header-anchor">#</a> 리더 없는 복제</h2> <ul><li>일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다.</li> <li>리악, 카산드라, 볼드모트는 리더 없는 복제 모델의 오픈 소스 데이터스토어이고, 이런 종류의 데이터베이스를 다이나모 스타일이라고 한다.</li></ul> <h3 id="노드가-다운됐을-때-데이터베이스에-쓰기"><a href="#노드가-다운됐을-때-데이터베이스에-쓰기" class="header-anchor">#</a> 노드가 다운됐을 때 데이터베이스에 쓰기</h3> <ul><li>세 개의 복제 서버를 가진 데이터베이스가 있고 복제 서버 중 하나를 사용할 수 없다고 가정하자.
<ul><li>클라이언트가 쓰기를 세 개의 모든 복제 서버에 병렬로 전송한다.</li> <li>사용 가능한 두 개의 복제 서버는 쓰기를 받았지만 사용 불가능한 복제 서버는 쓰기를 놓쳤다.</li> <li>이제  사용할 수 없었던 노드가 온라인 상태가 되고 클라이언트가 이 노드에서 읽기를 시작한다.</li> <li>따라서 클라이언트가 해당 노드에서 데이터를 읽는 다면 <code>오래된 값</code>을 얻을 수 있다.</li></ul></li></ul> <h4 id="읽기-복구와-안티-엔트로피"><a href="#읽기-복구와-안티-엔트로피" class="header-anchor">#</a> 읽기 복구와 안티 엔트로피</h4> <ul><li>복제 계획은 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 한다.</li> <li>다이나모 스타일 데이터스토어는 다음 두 가지 방법을 주로 사용한다.
<ul><li><strong>읽기 복구</strong> <ul><li>클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다.</li> <li>클라이언트가 복제 서버에서 응답받은 값이 오래된 값이라는 사실을 알고 해당 복제 서버에 값을 다시 기록한다.</li> <li>거의 읽지 않는 값은 일부 복제본에서 누락돼 내구성이 떨어진다.</li></ul></li> <li><strong>안티 엔트로피 처리</strong> <ul><li>백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 다른 서버로 복사한다.</li> <li>리더 기반 복제에서의 로그와 달리 <strong>안티 엔트로피 처리</strong>는 특정 순서로 쓰기를 복사하기 때문에 상당한 지연이 있을 수 있다.</li></ul></li></ul></li></ul> <h4 id="읽기와-쓰기를-위한-정족수-quorum"><a href="#읽기와-쓰기를-위한-정족수-quorum" class="header-anchor">#</a> 읽기와 쓰기를 위한 정족수(Quorum)</h4> <ul><li>n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 쓰기가 확정되고 모든 읽기는 최소한 r개의 노드에 질의해야 한다. <code>w + r &gt; n</code> 이면 읽을 때 최신 값을 얻는 것으로 기대한다.</li> <li>최소한 r개의 노드 중 하나에서 최신 값을 읽을 수 있기 때문이다.</li> <li>이런 r 과 w를 따르는 읽기와 쓰기를 정속수(Quorum) 읽기와 쓰기라고 부른다.</li> <li>일반적인 선택은 n을 홀수(보통 3,5)로 하고 <code>w = r = (n+1) /2 (반올림)</code>로 설정한다.</li> <li>쓰기가 적고 읽기가 많은 작업부하는 <code>w=n, r= 1</code> 로 설정할 수 있다.</li></ul> <h3 id="정족수-일관성의-한계"><a href="#정족수-일관성의-한계" class="header-anchor">#</a> 정족수 일관성의 한계</h3> <ul><li><code>w + r &gt; n</code> 이 되게끔 w와 r을 선택한다면 일반적으로 모든 읽기는 최신 값을 반환할 것으로 기대한다.</li> <li>하지만 <code>w + r &gt; n</code> 인 경우에도 오래된 값을 반환하는 에지 케이스가 있다.
<ul><li>두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다.</li> <li>쓰기와 읽기가 동시에 발생하면 쓰기는 일부 복제 서버에만 반영될 수 있다.</li> <li>쓰기가 일부 복제 서버에서는 성공했지만 다른 복제 서버에서 실패해 전체 성공한 서버가 w 복제 서버 보다 적다면 읽기에 해당 쓰기 값이 반환될 수도 있고 아닐 수도 있다.</li> <li>새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 깨진다.</li></ul></li></ul> <h4 id="최신성-모니터링"><a href="#최신성-모니터링" class="header-anchor">#</a> 최신성 모니터링</h4> <ul><li>리더 기반 복제에서 데이터베이스는 복제 지연에 대한 지표를 모니터링 시스템에 제공된다.</li> <li>이것은 쓰기가 리더에 적용되고 같은 순서로 팔로워에도 적용되고 각 노드가 복제 로그의 위치를 가지기 때문에 가능하다.</li> <li>하지만 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 더 어렵다.</li> <li>최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 “최종적을”을 정량화할 수 있어야 한다.</li></ul> <h3 id="느슨한-정족수와-암시된-핸드오프"><a href="#느슨한-정족수와-암시된-핸드오프" class="header-anchor">#</a> 느슨한 정족수와 암시된 핸드오프</h3> <ul><li>쓰기 가용성을 높이기 위해 정족수 w를 만족하지 않아도 일단 연결 할 수 있는 노드에 기록하는 방식을 <code>느슨한 정족수</code>라고 부른다.</li> <li>네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 홈 노드로 전송하는 방식을 암시된 핸드오프(hinted handoff)라고 한다.</li> <li>느슨한 정족수는 쓰기 가용성을 높이는데 유용하지만 <code>w + r &gt; n</code>인 경우에도 키의 최신 값을 읽는다고 보장하지 않는다.</li></ul> <h3 id="동시-쓰기-감지"><a href="#동시-쓰기-감지" class="header-anchor">#</a> 동시 쓰기 감지</h3> <ul><li>다이나모 스타일 DB에서는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 종속수를 사용하더라도 충돌이 발생한다.</li> <li><strong>네트워크 지연과 부분적인 장애 때문에 쓰기 요청이 다른 노드에 다른 순서로 도착할 수 있다.</strong></li> <li>최종적인 일관성을 달성하기 위해 복제본들은 동일한 값이 돼야 한다.</li></ul> <h4 id="최종-쓰기-승리-last-write-wins-lww"><a href="#최종-쓰기-승리-last-write-wins-lww" class="header-anchor">#</a> 최종 쓰기 승리(Last Write Wins, LWW)</h4> <ul><li>각 복제본이 가진 예전 값을 버리고 가장 최신 값으로  덮어쓰는 방법이다.</li> <li>클라이언트가 쓰기 요청을 데이터베이스 노드에 전송할 때 다른 클라이언트에 대해서는 아는 것이 없기 때문에 “최신”인지 명확하게 결정하기 어렵다.</li> <li>그래서 자연적인 순서는 없지만 타임스탬프 같은 임의로 순서를 정할 수 있다.
<ul><li>LWW라 불리는 충돌 해소 알고리즘은 카산드라에서 유일하게 제공하는 충돌 해소 방법이다.</li></ul></li> <li>LWW는 지속성을 희생한다. 동일한 키에 여러 번의 동시 쓰기가 발생하면 쓰기 중 하나만 남고 다른 쓰기는 모두 무시된다.</li></ul> <h4 id="이전-발생-관계와-동시성"><a href="#이전-발생-관계와-동시성" class="header-anchor">#</a> “이전 발생” 관계와 동시성</h4> <ul><li>Insert 후 해당 데이터를 Update 하는 작업이 있을 때, Update 하는 작업은 Insert 작업 기반이기 때문에 B 작업은 나중에 발생해야 한다. 이를 B(update)는 A(insert)에 <code>인과성이 있다</code>고 한다.</li> <li>작업 B가 작업 A에 대해서 알거나 어떤 방식으로든 A에 의존적이라면 작업 A는 작업 B의 <code>이전 발생(heppens-befoe</code>이다.</li> <li>분산 시스템에서 두 작업이 정확히 같은 시각에 발생했는지 알기란 상당히 어렵다.</li> <li>동시성을 정의하기 위해 정확한 시각은 중요하지 않다. 두 작업이 발생한 물리적인 시각보다 각 작업이 서로 알지 못하면 단순히 두 작업은 동시에 수행됐다 말한다.</li></ul> <h4 id="이전-발생-관계-파악하기"><a href="#이전-발생-관계-파악하기" class="header-anchor">#</a> 이전 발생 관계 파악하기</h4> <ul><li>서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있다.
<ul><li>서버가 모든 키에 대한 버전 정보를 유지하고 키를 기록할 때마다 버전 정보를 증가시킨다.</li> <li>클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 쓰기 전에 키값도 반환한다.</li> <li>클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야하고 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다.</li> <li>서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어 쓸 수 있다. 이보다 높은 버전 번호의 모든 값은 유지해야 한다. 이 값들은 유입된 쓰기와 동시에 발생했기 때문이다.</li></ul></li></ul> <h4 id="동시에-쓴-값-병합"><a href="#동시에-쓴-값-병합" class="header-anchor">#</a> 동시에 쓴 값 병합</h4> <ul><li>여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야 한다. 이런 동시 값을 <code>형제(sibling) 값</code> 이라고 한다.</li> <li>간단한 접근 방식으로 버전 번호나 타임스탬프 기반으로 하나의 값을 선택하는 방법(LWW)이 있지만 데이터 손실이 생길 수 있다. 그래서 애플리케이션 코드 내에서 더욱 지능적으로 대처해야 한다.</li></ul> <h4 id="버전-벡터"><a href="#버전-벡터" class="header-anchor">#</a> 버전 벡터</h4> <h2 id="정리"><a href="#정리" class="header-anchor">#</a> 정리</h2> <ul><li><p>복제는 다양한 용도로 사용할 수 있다.</p> <ul><li><strong>고가용성</strong> <ul><li>한 장비가 다운될 때도 시스템이 계속 동작하게 된다.</li></ul></li> <li><strong>연결이 끊긴 작업</strong> <ul><li>네트워크 중단이 있을 때도 애플리케이션이 계속 동작할 수 있게 한다.</li></ul></li> <li><strong>지연 시간</strong> <ul><li>지리적으로 사용자에게 가까이 데이터를 배치해 사용자가 더 빠르게 작업할 수 있게 한다.</li></ul></li> <li><strong>확장성</strong> <ul><li>복제본에서 읽기를 수행해 단일 장비에서 다룰 수 있는 양보다 많은 양의 읽기 작업을 처리할 수 있다.</li></ul></li></ul></li> <li><p>복제에 대한 주요 접근 방식</p> <ul><li><strong>단일 리더 복제</strong> <ul><li>클라이언트는 모든 쓰기를 단일 리더로 전송하고 리더는 데이터 변경 이벤트 스트림을 다른 복제 서버로 전송한다. 팔로워의 읽기가 오래된 값일 수도 있다.</li> <li>이해하기 쉽고 충돌 해소에 대한  우려가 없어서 널리 사용된다.</li></ul></li> <li><strong>다중 리더 복제</strong> <ul><li>클라이언트의 각 쓰기가 여러 리더로 전송될 수 있고 각 리더는 다른 리더와 팔로워에게 전송한다.</li></ul></li> <li><strong>리더 없는 복제</strong> <ul><li>각 쓰기가 여러 노드로 전송할 수 있고, 클라이언트는 오래된 데이터를 감지하고 이를 바로잡기 위해 병렬로 여러 노드에서 읽는다.</li></ul></li></ul></li> <li><p>다중 리더 복제나 리더 없는 복제는 노드의 결함, 네트워크 중단, 지연 시간 급증이 있는 상황에서 견고하다. 하지만 어렵고 일관성이 거의 보장되지 않는다는 점이 단점이다.</p></li> <li><p>복제 지연으로 발생할 수 있는 이상 현상들</p> <ul><li><strong>쓰기 후 읽기 일관성</strong> <ul><li>사용자는 자신이 제출한 데이터를 항상 볼 수 있어야 한다.</li></ul></li> <li><strong>단조 읽기</strong> <ul><li>사용자가 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터는 나중에 볼 수 없다.</li></ul></li> <li><strong>일관된 순서로 읽기</strong> <ul><li>사용자는 인과성이 있는 상태의 데이터를 봐야 한다.</li></ul></li></ul></li></ul></div></div></div></div> <div data-v-52bca676></div></div></div></div> <footer prime="" class="v-footer mt-2 v-sheet theme--light v-footer--padless" style="background:#F3F5F7;"><div class="col col-12"><div class="text-center v-card v-card--flat v-sheet theme--light rounded-0" style="background:#F3F5F7;"><div class="v-card__text"><p>Copyright © 2021 All Right <em>끄적끄적 개발일지</em></p> <p>
          px201226@gmail.com .
          <a href="https://github.com/px201226" target="_blank">GitHub</a>
          .
          <a href="http://px201226.github.io/blog" target="_blank">Blog</a>
          .
        </p></div></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.70752fd1.js" defer></script><script src="/assets/js/17.4dcf5890.js" defer></script><script src="/assets/js/29.d205c4cb.js" defer></script>
  </body>
</html>
