<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>7장 - 트랜잭션 | 끄적끄적 개발일지</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://www.googletagmanager.com/gtag/js?id=G-SE0BLFFFMG"></script>
    <meta name="description" content="Awesome description">
    
    <link rel="preload" href="/assets/css/0.styles.4bffb705.css" as="style"><link rel="preload" href="/assets/js/app.70752fd1.js" as="script"><link rel="preload" href="/assets/js/17.4dcf5890.js" as="script"><link rel="preload" href="/assets/js/31.65e9c8ce.js" as="script"><link rel="prefetch" href="/assets/js/10.1fe66b22.js"><link rel="prefetch" href="/assets/js/11.3e8e6dd5.js"><link rel="prefetch" href="/assets/js/12.96743d99.js"><link rel="prefetch" href="/assets/js/13.5cab9bdd.js"><link rel="prefetch" href="/assets/js/14.e412fb10.js"><link rel="prefetch" href="/assets/js/15.1da5e3dc.js"><link rel="prefetch" href="/assets/js/16.8ebbd2f8.js"><link rel="prefetch" href="/assets/js/18.5bfa6a85.js"><link rel="prefetch" href="/assets/js/19.12bd999a.js"><link rel="prefetch" href="/assets/js/2.0c177ed1.js"><link rel="prefetch" href="/assets/js/20.87648ee0.js"><link rel="prefetch" href="/assets/js/21.7fbb071c.js"><link rel="prefetch" href="/assets/js/22.3f3676f6.js"><link rel="prefetch" href="/assets/js/23.114b4211.js"><link rel="prefetch" href="/assets/js/24.7077956a.js"><link rel="prefetch" href="/assets/js/25.42ad01f0.js"><link rel="prefetch" href="/assets/js/26.c356a4d4.js"><link rel="prefetch" href="/assets/js/27.52a125bd.js"><link rel="prefetch" href="/assets/js/28.692ecc68.js"><link rel="prefetch" href="/assets/js/29.d205c4cb.js"><link rel="prefetch" href="/assets/js/3.6ee8ed88.js"><link rel="prefetch" href="/assets/js/30.c221f26d.js"><link rel="prefetch" href="/assets/js/32.7ddfb0f5.js"><link rel="prefetch" href="/assets/js/33.7f74862d.js"><link rel="prefetch" href="/assets/js/34.21b19958.js"><link rel="prefetch" href="/assets/js/35.428cdea5.js"><link rel="prefetch" href="/assets/js/36.ef46a37e.js"><link rel="prefetch" href="/assets/js/37.290a8b87.js"><link rel="prefetch" href="/assets/js/38.61002123.js"><link rel="prefetch" href="/assets/js/39.fbbd1cce.js"><link rel="prefetch" href="/assets/js/4.39bb3471.js"><link rel="prefetch" href="/assets/js/40.ee500a11.js"><link rel="prefetch" href="/assets/js/41.ce50acc7.js"><link rel="prefetch" href="/assets/js/42.b0e56f29.js"><link rel="prefetch" href="/assets/js/43.c4683cd4.js"><link rel="prefetch" href="/assets/js/44.4fd9959c.js"><link rel="prefetch" href="/assets/js/45.10201422.js"><link rel="prefetch" href="/assets/js/5.6b61195e.js"><link rel="prefetch" href="/assets/js/6.d4a6ae6d.js"><link rel="prefetch" href="/assets/js/7.8da69c67.js"><link rel="prefetch" href="/assets/js/8.8044f9c2.js"><link rel="prefetch" href="/assets/js/9.8e23472b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4bffb705.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light" style="background:#F3F5F7;"><div class="v-application--wrap"><div class="container pa-0" style="max-width:900px;"><link href="https://fonts.googleapis.com/css?family=Jura" rel="stylesheet"> <div class="text-center py-8 v-toolbar__title v-app-bar-title" style="font-family:'Jura';"><div class="v-app-bar-title__content"><h1 class="primary--text">끄적끄적 개발일지</h1></div><div class="v-app-bar-title__placeholder" style="visibility:visible;"><h1 class="primary--text">끄적끄적 개발일지</h1></div></div> <div role="list" class="v-list pa-0 v-sheet theme--light v-list--flat transparent"><div role="listbox" class="v-item-group theme--light v-list-item-group indigo--text"><div class="row mb-0 text-center no-gutters justify-center"><div class="col-lg-2 col"><a href="/" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2  v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Home</div></a></div> <div class="col-lg-2 col"><a href="/category" aria-current="page" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-item--active v-list-item--active v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Category</div></a></div> <div class="col-lg-2 col"><a href="/profiles" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Profiles</div></a></div></div></div></div> <hr role="separator" aria-orientation="horizontal" class="mb-3 v-divider theme--light"> <div><div data-v-52bca676><div class="px-0 col col-12" data-v-52bca676 data-v-52bca676><div class="pa-5 px-md-7 v-card v-sheet theme--light elevation-1" data-v-52bca676><div data-v-52bca676><a href="/category/db-oriented-design/ch7.html" aria-current="page" class="text-h4 font-weight-bold router-link-exact-active router-link-active" data-v-52bca676><div data-v-52bca676><!----></div>
          7장 - 트랜잭션
        </a> <br data-v-52bca676> <span class="text-caption grey--text text--darken-1 " data-v-52bca676>2022-02-01 &gt; 데이터 중심 애플리케이션 설계
        </span></div> <hr role="separator" aria-orientation="horizontal" class="mt-4 mb-4 v-divider theme--light" data-v-52bca676> <div class="theme-container" data-v-52bca676><div class="toc" data-v-52bca676><ul><li><a href="/category/db-oriented-design/ch7.html#애매모호한-트랜잭션의-개념">애매모호한 트랜잭션의 개념</a><ul><li><a href="/category/db-oriented-design/ch7.html#acid의-의미">ACID의 의미</a></li><li><a href="/category/db-oriented-design/ch7.html#단일-객체-연산과-다중-객체-연산">단일 객체 연산과 다중 객체 연산</a></li></ul></li><li><a href="/category/db-oriented-design/ch7.html#완화된-격리-수준">완화된 격리 수준</a><ul><li><a href="/category/db-oriented-design/ch7.html#커밋-후-읽기">커밋 후 읽기</a></li><li><a href="/category/db-oriented-design/ch7.html#스냅숏-격리와-반복-읽기">스냅숏 격리와 반복 읽기</a></li><li><a href="/category/db-oriented-design/ch7.html#갱신-손실-방지">갱신 손실 방지</a></li><li><a href="/category/db-oriented-design/ch7.html#쓰기-스큐-write-skew-와-팬텀">쓰기 스큐(write skew)와 팬텀</a></li></ul></li><li><a href="/category/db-oriented-design/ch7.html#직렬성">직렬성</a><ul><li><a href="/category/db-oriented-design/ch7.html#실제적인-직렬-실행">실제적인 직렬 실행</a></li><li><a href="/category/db-oriented-design/ch7.html#_2단계-잠금-2pl">2단계 잠금(2PL)</a></li><li><a href="/category/db-oriented-design/ch7.html#직렬성-스냅숏-격리-serializable-snapshot-isolation-ssi">직렬성 스냅숏 격리(Serializable Snapshot Isolation, SSI)</a></li></ul></li><li><a href="/category/db-oriented-design/ch7.html#정리">정리</a></li></ul></div> <div class="theme-default-content custom post markdown-body content__default" data-v-52bca676><h2 id="애매모호한-트랜잭션의-개념"><a href="#애매모호한-트랜잭션의-개념" class="header-anchor">#</a> 애매모호한 트랜잭션의 개념</h2> <h3 id="acid의-의미"><a href="#acid의-의미" class="header-anchor">#</a> ACID의 의미</h3> <ul><li>트랜잭션이 제공하는 안정성 보장은 <strong>원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)</strong> 을 의미하는 <code>ACID</code> 로 잘 알려져 있다.</li> <li>그러나 현실에서는 데이터베이스마다 ACID 구현이 재각각이다. 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다.</li></ul> <h4 id="원자성"><a href="#원자성" class="header-anchor">#</a> 원자성</h4> <ul><li>원장성은 클라이언트가 쓰기 작업 몇 개를 실행하려고 하는데 그 중 일부만 처리된 후 결함이 생기면 무슨 일이 생기는지 설명한다.</li> <li>여러 쓰기 작업이 하나의 원자적 단위인 트랜잭션으로 묶여 있는데 결함 때문에 커밋될 수 없다면 어보트되고 지금까지 실행한 쓰기를 무시하거나 취소해야하 한다.</li> <li>원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려고 할 때 무슨 일이 생기는지 설명하지 않는다.</li> <li>오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 <code>어보트 능력(abortability)</code> 능력이 원자성의 결정적 특징이다.</li></ul> <h4 id="일관성"><a href="#일관성" class="header-anchor">#</a> 일관성</h4> <ul><li>일관성이란 단어는 굉장히 여러 의미로 쓰인다.
<ul><li>복제 일관성과 비동기식 복제되는 시스템에서 발생하는 최종적 일관성 문제</li> <li>일관성 해싱은 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝 방법</li> <li>CAP 정리에서 일관성은 선형성을 의미한다.</li> <li>ACID 맥락에서 일관성은 데이터베이스가 “좋은 상태”에 있어야 한다는 애플리케이션에 특화된 개념을 가르킨다.</li></ul></li> <li>일관성의의 아이디어는 데이터에 관한 어떤 불변식이 항상 진실이어야 한다는 것이다.</li> <li>트랜잭션이 이런 불변식이 유요한 데이터베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.</li> <li>일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다.</li> <li>데이터베이스 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다
<ul><li>외래 키, 기본키 제약 조건같은 특정 종류의 불변식을 지원하지만 일반적으로 애플리케이션에서 데이터가 유효한지 아닌지를 정의하고 데이터베이스는 데이터를 저장할 뿐이다.</li></ul></li></ul> <h4 id="격리성"><a href="#격리성" class="header-anchor">#</a> 격리성</h4> <ul><li>클라리언트들이 동일한 데이터베이스 레코드에 접근하면 동시성 문제가 발생한다.</li> <li>여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.</li></ul> <h4 id="지속성"><a href="#지속성" class="header-anchor">#</a> 지속성</h4> <ul><li>트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.</li></ul> <h3 id="단일-객체-연산과-다중-객체-연산"><a href="#단일-객체-연산과-다중-객체-연산" class="header-anchor">#</a> 단일 객체 연산과 다중 객체 연산</h3> <ul><li>ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 서술한다.</li> <li>다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션이 속하는지 알아낼 수단이 있어야 한다.</li> <li>관계형 데이터베이스에서 이것은 전형적으로 클라이언트와 데이터베이스 서버 사이의 TCP 연결을 기반으로 한다.</li> <li>어떤 특정 연결 내에서 <code>BEGIN TRANSACTION</code> 문과 <code>COMMIT</code> 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여긴다.</li> <li>반명 비관계형 데이터베이스는 한 연산 내에서 여러 키를 갱신하는 다중 객체 연산을 묶는 방법이 없는 경우가 많다.</li> <li>어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.</li></ul> <h4 id="단일-객체-쓰기"><a href="#단일-객체-쓰기" class="header-anchor">#</a> 단일 객체 쓰기</h4> <ul><li>저장소 엔진들은 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다.</li> <li>어떤 데이터베이스는 증가 연산처럼 더 복잡한 원자적 연산을 제공하기도 한다.</li> <li>이러한 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실을 방지하므로 유용하다.</li></ul> <h4 id="다중-객체-트랜잭션의-필요성"><a href="#다중-객체-트랜잭션의-필요성" class="header-anchor">#</a> 다중 객체 트랜잭션의 필요성</h4> <ul><li>다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기가 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문에 지원하기가 어렵다.</li> <li>단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례가 있다. 트랜잭션이 없더라도 이런 애플리케이션ㅇ들은 구현할 수 있다.</li> <li>하지만 원자성이 없으면 오츄 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.</li></ul> <h4 id="오류와-어보트-처리"><a href="#오류와-어보트-처리" class="header-anchor">#</a> 오류와 어보트 처리</h4> <ul><li>트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 아전하게 재시도할 수 있다는 것이다.</li> <li>하지만 리더 없는 복제를 사용하는 데이터스토어는 이러한 철학을 따르지 않는다. <code>최선을 다하는 원칙</code>을 기반으로 더 많은 일을 한다.</li></ul> <h2 id="완화된-격리-수준"><a href="#완화된-격리-수준" class="header-anchor">#</a> 완화된 격리 수준</h2> <ul><li>두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 병렬 실행 될 수 있다.</li> <li>동시성 문제(경쟁 조건)는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.</li> <li><code>트랜잭션 격리</code>를 제공함으로써 애플리케이션 개발들에게 동시성 문제를 감췄다.</li> <li>직렬성 격리는 성능 빙용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.</li> <li>따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는 완화된 격리 수준을 사용하는 시스템들이 흔하다.</li> <li>이번 절에서는 완화된(비직렬성) 격리 수준 몇 가지를 살펴보고 발생할 수 있는 경쟁 조건과 발생할 수 없는 경쟁 조건을 설명한다.</li></ul> <h3 id="커밋-후-읽기"><a href="#커밋-후-읽기" class="header-anchor">#</a> 커밋 후 읽기</h3> <ul><li>가장 기본적인 수준의 트랜잭션 격리는 <code>커밋 후 읽기(read committed)</code>다.
<ul><li>데이터베이스 읽을 때 커밋된 데이터만 보게 된다. (더티 읽기가 없음)</li> <li>데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)</li></ul></li></ul> <h4 id="더티-읽기-방지"><a href="#더티-읽기-방지" class="header-anchor">#</a> 더티 읽기 방지</h4> <ul><li>트랜잭션이 데이터베이스에 데이터를 썻지만 아직 커밋되거나 어보트되지 않았을 때, 다른 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있는 것을 더티 읽기라고 부른다.
<ul><li>트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다.</li> <li>커밋되지 않은 데이트를 볼 수 있다.</li></ul></li></ul> <h4 id="더티-쓰기-방지"><a href="#더티-쓰기-방지" class="header-anchor">#</a> 더티 쓰기 방지</h4> <ul><li>아직 커밋되지 않은 데이터에 다른 트랜잭션이 쓰기 작업을 하는 것을 <code>더티 쓰기(dirty write)</code>라고 한다.</li></ul> <h4 id="커밋후-읽기-구현"><a href="#커밋후-읽기-구현" class="header-anchor">#</a> 커밋후 읽기 구현</h4> <ul><li>더티 쓰기의 가장 흔한 방법으로 데이터베이스는 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.
<ul><li>트랜잭션에서 특정 객체(로우나 문서)를 변경하고 싶다면 먼저 해당 객체에 대한 잠금을 획득하고, 트랜잭션이 완려될 때까지 잠금을 보유하고 있어야 한다.</li> <li>다른 트랜잭션이 쓰기를 원한다면 첫 번째 트랜잭션이 완료되어 잠금을 얻어 진행할 수 있다.</li></ul></li> <li>더티 읽기는 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해제하게 하는 것 이다.
<ul><li>그러나 읽기 잠금은 트랜잭션들의 응답 시간에 해를 끼치며 운용성이 나쁘다.</li> <li>쓰여진 모든 객체에 대해 데이터베이스는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억한다.</li> <li>해당 트랜잭션이 그 객체를 읽으려고 하면 과거의 값을 읽게 된다.</li></ul></li></ul> <h3 id="스냅숏-격리와-반복-읽기"><a href="#스냅숏-격리와-반복-읽기" class="header-anchor">#</a> 스냅숏 격리와 반복 읽기</h3> <ul><li>커밋된 읽기 격리 수준을 사용하더라도 동시성 버그가 생길 수 있다.
<ul><li>앨리스는 두 계좌에 500달러 씩 있고, 한 계좌에서 다른 계좌로 100달러를 전송하는 트랜잭션을 실행한다.</li> <li>트랜잭션이 처리되고 있는 순간에 계좌 잔고를 보게 되면 입금되기 전 상태인 500달러, 출금된 후 상태인 400달러를 보게되어 총 900달러만 있는 것처럼 나온다.</li> <li>앨리스가 봤던 계좌 잔고들은 읽은 시점에 커밋된 상태였다.</li> <li>이런 현상을 <code>비반복 읽기(nonrepeatable read)</code>나 <code>읽기 스큐(read skew</code>)라고 한다.</li> <li>스냅</li></ul></li> <li>스냅숏 격리는 이런 문제의 가장 흔한 해결책이다.
<ul><li>각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다.</li> <li>즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.</li></ul></li></ul> <h4 id="스냅숏-격리-구현"><a href="#스냅숏-격리-구현" class="header-anchor">#</a> 스냅숏 격리 구현</h4> <ul><li>스냅숏 격리 구현은 커밋 후 읽기 격리처럼 쓰기 잠금을 사용한다. 그러나 읽을 때는 아무 잠금도 필요하지 않다.</li> <li>스냅숏 격리의 핵심 원리는 <code>읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는</code> 것이다.</li> <li>따라서 데이터베이스는 잠금 경쟁 없이 일관성 있는 스냅숏에 오래 실행되는 읽기 작업을 처리할 수 있다.</li> <li>여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야 할 수도 있기 때문에 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.</li> <li>이런 기법을 <code>다중 버전 동시성 제어(MVCC)</code>라고 한다.</li> <li>데이터베이스가 커밋 후 읽기 격리만 제공할 필요가 있다면 객체마다 커멋된 버전, 커멋되지 않은 버전 두 개씩만 유지하면 충분하다.
<ul><li>커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용하는 것이다.</li></ul></li></ul> <h3 id="갱신-손실-방지"><a href="#갱신-손실-방지" class="header-anchor">#</a> 갱신 손실 방지</h3> <ul><li>커밋 후 읽기와 스냅숏 격리 수준은 동시에 실행되는 쓰기 작업이 있을 때 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 보장과 관련된 것 이다.</li> <li>갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다.</li> <li>이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있다.</li></ul> <h4 id="원자적-쓰기-연산"><a href="#원자적-쓰기-연산" class="header-anchor">#</a> 원자적 쓰기 연산</h4> <ul><li>이 연산은 애플리케이션 코드에서 read-modify-write 주기를 구현할 필요를 없애 준다</li> <li>다음 명령은 대부분의 관계형 데이터베이스에서 동시성 안전(concurrency-safe)하다.</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token constant">UPDATE</span> conters <span class="token constant">SET</span> value <span class="token operator">=</span> value <span class="token operator">+</span> <span class="token number">1</span> <span class="token constant">WHERE</span> key <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>원자적 연산은 보통 객체를 읽을 때 독접적인(exclusive) 잠금을 획득해서 구현한다. 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못한다.</li> <li>ORM 프레임워크를 사용하면 데이터베이스가 원자적 연산을 사용하는 대신  read-modify-write 주기를 실행하는 코드를 작성하기 쉽다.</li></ul> <h4 id="명시적인-잠금"><a href="#명시적인-잠금" class="header-anchor">#</a> 명시적인 잠금</h4> <ul><li>데이터베이스에 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠금하는 것이다.</li> <li>read-modify-write 주기를 수행할 수 있고 다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 read-modify-write 주기가 완료될 때까지 기다리도록 강제된다.</li> <li><code>SELEFT FOR UPDATE</code> 절은 이 질의에 의해 반환된 모든 로우에 잠금을 획득해야 함을 가르킨다.</li></ul> <h4 id="갱신-손실-자동-감지"><a href="#갱신-손실-자동-감지" class="header-anchor">#</a> 갱신 손실 자동 감지</h4> <ul><li>지금까지 설명한 갱신 손실 방지 방법은 연산을 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법이다.</li> <li>대안으로 이들의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트 시키고 쓰기를 재시도하도록 강제하는 방법이 있다.</li> <li>Mysql의 반복 읽기는 갱신 손실을 감지하지 않는다.</li></ul> <h4 id="compare-and-set"><a href="#compare-and-set" class="header-anchor">#</a> Compare-and-set</h4> <ul><li>트랜잭션을 제공하지 않는 데이터베이스 중에는 원자적 compare-and-set 연산을 제공하는 것도 있다.</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token constant">UPDATE</span> wiki_pages <span class="token constant">SET</span> content <span class="token operator">=</span> <span class="token string">'new content'</span>
<span class="token constant">WHERE</span> id <span class="token operator">=</span> <span class="token number">1234</span> <span class="token constant">AND</span> content <span class="token operator">=</span> <span class="token string">'old content'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="충돌-해소와-복제"><a href="#충돌-해소와-복제" class="header-anchor">#</a> 충돌 해소와 복제</h4> <ul><li>복제가 적용된 데이터베이스에서 갱신 손실을 막는 것은 다른 차원의 문제다.</li> <li>여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하므로 데이터의 최신 복사본이 하나만 있으리라고 보장할 수 없다.</li> <li><strong>동시 쓰기 감지</strong> 처럼 여러 개의 충돌된 버전(sibling)을 생성하는 것을 허용하고 사후에 충돌을 해소하고 병합하는 것이다.</li></ul> <h3 id="쓰기-스큐-write-skew-와-팬텀"><a href="#쓰기-스큐-write-skew-와-팬텀" class="header-anchor">#</a> 쓰기 스큐(write skew)와 팬텀</h3> <ul><li>쓰기 스큐는 두 트랜잭션이 같은 객체들을 읽어서 그중 <code>일부</code>를 갱신할 때 나타날 수 있다.
<ul><li><code>동일한 객체를 갱신하는 경우</code> 더티 쓰기나 갱신 손실 이상 현상을 겪는다.</li></ul></li></ul> <h2 id="직렬성"><a href="#직렬성" class="header-anchor">#</a> 직렬성</h2> <ul><li>여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.</li> <li>즉 데이터베이스가 발생할 수 있는 <strong>모든</strong> 경쟁 조건을 막아준다.</li> <li>오늘날 직렬성을 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용한다.
<ul><li>트랜잭션을 순차적으로 실행하기</li> <li>2단계 잠금</li> <li>직렬성 스냅숏 격리 같은 낙관적 동시성 제어</li></ul></li></ul> <h3 id="실제적인-직렬-실행"><a href="#실제적인-직렬-실행" class="header-anchor">#</a> 실제적인 직렬 실행</h3> <ul><li>한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 된다.</li> <li>과거 30년 동안 높은 성능을 위해 다중 스레드 동시성이 필수적인 것으로 여겨졌지만 최근이 돼서야 단일 스레드 루프에서 트랜잭션을 실행하는 게 실현 가능하도고 결론지었다.
<ul><li>램 가격이 저렴해지면서 활성화된 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됐다.</li> <li>OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 알았다. 반대로 오래 실행되는 분석 질의는 직렬 실행 루프 밖에서 일관된 스냅숏을 사용해 실행할 수 있다.</li></ul></li></ul> <h4 id="트랜잭션을-스토어드-프로시저-안에-캡슐화하기"><a href="#트랜잭션을-스토어드-프로시저-안에-캡슐화하기" class="header-anchor">#</a> 트랜잭션을 스토어드 프로시저 안에 캡슐화하기</h4> <ul><li>트랜잭션이 사용자의 입력을 기다려야 한다면 데이터베이스는 대부분 유휴 상태일 것 이다.</li> <li>이를 효율적으로 처리할 수 없어서 거의 모든 OLTP 애플리케이션은 트랜잭션 내에서 사용자 응답을 대기하는 것을 회피함으로써 트랜잭션을 짧게 유지한다.</li> <li>애플리케이션에서 질의를 실행하고 그 결과를 읽고, 첫 번째 결과에 따라 다른 질의를 실행할 수 도 있다.</li> <li>이러한 상호작용식 트랜잭션을 데이터베이스에서 동시성을 허용하지 않으면 처리량은 끔직해 질 것 이다.</li> <li>트랜잭션 코드 전체를 스토어드 프로시저 형태로 데이터베이스에 미리 제출하여 사용할 수 있다.</li></ul> <h4 id="스토어드-프로시저의-장단점"><a href="#스토어드-프로시저의-장단점" class="header-anchor">#</a> 스토어드 프로시저의 장단점</h4> <ul><li>데이터베이스 벤더마다 제각각 스토어드 프로시저용 언어가 있다.</li> <li>데이터베이스에서 실행되는 코드는 관리하기 어렵다.</li> <li>데이터베이스 인스턴스 하나를 공유하기 때문에 잘못 작성된 스토어드 프로시저는 서버에 훨씬 민감하다.</li></ul> <h4 id="파티셔닝"><a href="#파티셔닝" class="header-anchor">#</a> 파티셔닝</h4> <ul><li>각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝할 수 있다면 각 파티셔닝은 다른 파티션과 독립적으로 실행되므로 처리량을 높일 수 있다.</li> <li>그러나 여러 파티션에 접근해야 하는 트랜잭션이 있다면 해당 트랜잭션이 접근하는 모든 타피션에 걸쳐서 코디네이션을 해야하므로 엄청나게 느려진다.</li></ul> <h4 id="직렬-실행-요약"><a href="#직렬-실행-요약" class="header-anchor">#</a> 직렬 실행 요약</h4> <ul><li>트랜잭션은 작고 빨라야 한다. 느린 트랜잭션이 모든 트랜잭션 처리를 지연시킬 수 있기 때문이다.</li> <li>활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.</li> <li>쓰기 처리량이 단일 CPU 코어에서 처리할 수 정도로 충분히 낮아야 한다.</li> <li>여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 엄격한 제한이 있다.</li></ul> <h3 id="_2단계-잠금-2pl"><a href="#_2단계-잠금-2pl" class="header-anchor">#</a> 2단계 잠금(2PL)</h3> <ul><li>데이터베이스 직렬성을 구현하는데 널리 쓰인 유일한 알고리즘이다.</li> <li>트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰기를 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다.(B가 A 몰래 갑자기 객체를 변경하지 못하도록 보장된다.)</li> <li>트랜잭션 A가 객체에 썻고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다.</li></ul> <aside>
💡 2단게 잠금(2PL)과 2단계 커밋(two-phase commit, 2PC)은 아주 비슷하게 들리지만 완전히 다르다.
</aside> <h4 id="_2단계-잠금-구현"><a href="#_2단계-잠금-구현" class="header-anchor">#</a> 2단계 잠금 구현</h4> <ul><li>2PL은 마이SQL 서버에서 직렬성 격리 수준을 구현하는데 사용된다.</li> <li>읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체의 잠금을 사용해 구현한다.
<ul><li>트랜잭션이 객체를 읽기를 원한다면 먼저 공유 모드로 잠금을 획득해야 한다. 동시에 여러 트랜잭션이 공유 모드로 잠금을 획득하는 것은 허용되지만 만약 그 객체에 이미 독점 모드로 잠금을 획든한 트랜잭션이 있으면 이 트랜잭션이 완료될 때까지 기다려야 한다.</li> <li>트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 한다. 다른 어떤 트랜잭션도 동시에 작므을 획득할 수 없으므로 그 객체에 작믁ㅁ이 존재한다면 트랜잭션은 대기해야 한다.</li> <li>트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드해야 한다. 업그레이드는 독점 잠금을 직접 획득할 때와 똑같이 동작한다.</li> <li>트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될때 까지 잠금을 갖고 있어야 한다. 2PL의 첫 번째 단계는 잠금을 획득할 때이고 두 번째 단계는 모든 잠금을 해제할 때다.</li> <li>트랜잭션이 서로 잠금을 해제하기를 기다리느라 멈춰 있는 상황을 <code>교착 상태</code>라고 한다.</li></ul></li></ul> <h3 id="직렬성-스냅숏-격리-serializable-snapshot-isolation-ssi"><a href="#직렬성-스냅숏-격리-serializable-snapshot-isolation-ssi" class="header-anchor">#</a> 직렬성 스냅숏 격리(Serializable Snapshot Isolation, SSI)</h3> <ul><li>직렬성 격리와 좋은 성능이 공종하는 <code>직렬성 스냅숏 격리</code>라는 알고리즘이 유망하다.</li></ul> <h4 id="비관적-동시성-제어-대-낙관적-동시성-제어"><a href="#비관적-동시성-제어-대-낙관적-동시성-제어" class="header-anchor">#</a> 비관적 동시성 제어 대 낙관적 동시성 제어</h4> <ul><li>2단계 잠금은 <code>비관적</code> 동시성 제어 메커니즘이다.
<ul><li>뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 한다.</li></ul></li> <li>직렬성 스냅숏 격리는 <code>낙관적</code> 동시성 제어 기법이다.
<ul><li>트랜잭션이 커밋되기를 원할 때 데이터베이스는 격리가 위반됐는지 확인한다.</li> <li>만약 그렇다면 트랜잭션은 어보트되고 재시도해야 한다.</li></ul></li> <li>낙관적 동시성 제어는 경쟁이 심하면 어보트시켜야 할 트랜잭션의 비율이 높아지므로 성능이 떨어진다.</li> <li>예비 용량이 충분하고 트랜잭션 사이의 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있다.</li> <li><code>SSI</code>는 스냅숏 격리를 기반으로 한다. 모든 읽기의 데이터는 데이터베이스의 일관된 스냅숏을 보게 된다.</li></ul> <h2 id="정리"><a href="#정리" class="header-anchor">#</a> 정리</h2> <h4 id="동시성-제어를-위한-격리-수준"><a href="#동시성-제어를-위한-격리-수준" class="header-anchor">#</a> 동시성 제어를 위한 격리 수준</h4> <ul><li><strong>더티 읽기</strong> <ul><li>한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 읽는다. 커밋 후 읽기 또는 그보다 강한 격리 수준은 더티 읽기를 방지한다.</li></ul></li> <li><strong>더티 쓰기</strong> <ul><li>한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 덮어쓴다. 거의 모든 트랜잭션 구현은 더티 쓰기를 방지한다.</li></ul></li> <li><strong>읽기 스큐(반복 읽기)</strong> <ul><li>클라이언트는 다른 시점에 데이터베이스의 다른 부분을 본다. 이 문제를 막기 위해 어느 시점의 일관된 스냅숏으로부터 읽는 스냅숏 격리를 가장 흔히 사용한다.</li></ul></li> <li><strong>갱신 손실</strong> <ul><li>두 클라이언트가 동시에 <code>read-modify-write</code> 주기를 실행한다. 다른 트랜잭션의 변경을 포함하지 않은 채로 쓴 내용을 덮어써서 데이터 손실이 일어난다.</li></ul></li> <li><strong>쓰기 스큐</strong> <ul><li>트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 데이터베이스에 쓴다. 그러나  쓰기를 실행하는 시점에는 결정의 전체가 더 이상 참이 아니다. 직렬성 격리만 이런 이상 현상을 막을 수 있다.</li></ul></li> <li><strong>팬텀 읽기</strong> <ul><li>트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행한다.</li></ul></li></ul> <h4 id="직렬성-트랜잭션을-구현하는-방법"><a href="#직렬성-트랜잭션을-구현하는-방법" class="header-anchor">#</a> 직렬성 트랜잭션을 구현하는 방법</h4> <ul><li>트랜잭션을 순서대로 실행하기
<ul><li>트랜잭션의 실행 시간이 아주 짧고 트랜잭션 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 트랜잭션 처리량이 낮다면 아주 간단하고 효과적인 선택이다.</li></ul></li> <li>2단계 잠금
<ul><li>수십년 동안 직렬성을 구현하는 표준적인 방법이지만 성능 특성 때문에 사용을 피하는 애플리케이션이 많다.</li></ul></li> <li>직렬성 스냅숏 격리
<ul><li>낙관적 방법을 사용해서 트랜잭션이 차단되지 않고 진행할 수 있게 한다. 트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬적이지 않으면 어보트시킨다.</li></ul></li></ul></div></div></div></div> <div data-v-52bca676></div></div></div></div> <footer prime="" class="v-footer mt-2 v-sheet theme--light v-footer--padless" style="background:#F3F5F7;"><div class="col col-12"><div class="text-center v-card v-card--flat v-sheet theme--light rounded-0" style="background:#F3F5F7;"><div class="v-card__text"><p>Copyright © 2021 All Right <em>끄적끄적 개발일지</em></p> <p>
          px201226@gmail.com .
          <a href="https://github.com/px201226" target="_blank">GitHub</a>
          .
          <a href="http://px201226.github.io/blog" target="_blank">Blog</a>
          .
        </p></div></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.70752fd1.js" defer></script><script src="/assets/js/17.4dcf5890.js" defer></script><script src="/assets/js/31.65e9c8ce.js" defer></script>
  </body>
</html>
