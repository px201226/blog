<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>5부 - 소스코드 최적화 | 끄적끄적 개발일지</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://www.googletagmanager.com/gtag/js?id=G-SE0BLFFFMG"></script>
    <meta name="description" content="Awesome description">
    
    <link rel="preload" href="/assets/css/0.styles.4bffb705.css" as="style"><link rel="preload" href="/assets/js/app.70752fd1.js" as="script"><link rel="preload" href="/assets/js/17.4dcf5890.js" as="script"><link rel="preload" href="/assets/js/41.ce50acc7.js" as="script"><link rel="prefetch" href="/assets/js/10.1fe66b22.js"><link rel="prefetch" href="/assets/js/11.3e8e6dd5.js"><link rel="prefetch" href="/assets/js/12.96743d99.js"><link rel="prefetch" href="/assets/js/13.5cab9bdd.js"><link rel="prefetch" href="/assets/js/14.e412fb10.js"><link rel="prefetch" href="/assets/js/15.1da5e3dc.js"><link rel="prefetch" href="/assets/js/16.8ebbd2f8.js"><link rel="prefetch" href="/assets/js/18.5bfa6a85.js"><link rel="prefetch" href="/assets/js/19.12bd999a.js"><link rel="prefetch" href="/assets/js/2.0c177ed1.js"><link rel="prefetch" href="/assets/js/20.87648ee0.js"><link rel="prefetch" href="/assets/js/21.7fbb071c.js"><link rel="prefetch" href="/assets/js/22.3f3676f6.js"><link rel="prefetch" href="/assets/js/23.114b4211.js"><link rel="prefetch" href="/assets/js/24.7077956a.js"><link rel="prefetch" href="/assets/js/25.42ad01f0.js"><link rel="prefetch" href="/assets/js/26.c356a4d4.js"><link rel="prefetch" href="/assets/js/27.52a125bd.js"><link rel="prefetch" href="/assets/js/28.692ecc68.js"><link rel="prefetch" href="/assets/js/29.d205c4cb.js"><link rel="prefetch" href="/assets/js/3.6ee8ed88.js"><link rel="prefetch" href="/assets/js/30.c221f26d.js"><link rel="prefetch" href="/assets/js/31.65e9c8ce.js"><link rel="prefetch" href="/assets/js/32.7ddfb0f5.js"><link rel="prefetch" href="/assets/js/33.7f74862d.js"><link rel="prefetch" href="/assets/js/34.21b19958.js"><link rel="prefetch" href="/assets/js/35.428cdea5.js"><link rel="prefetch" href="/assets/js/36.ef46a37e.js"><link rel="prefetch" href="/assets/js/37.290a8b87.js"><link rel="prefetch" href="/assets/js/38.61002123.js"><link rel="prefetch" href="/assets/js/39.fbbd1cce.js"><link rel="prefetch" href="/assets/js/4.39bb3471.js"><link rel="prefetch" href="/assets/js/40.ee500a11.js"><link rel="prefetch" href="/assets/js/42.b0e56f29.js"><link rel="prefetch" href="/assets/js/43.c4683cd4.js"><link rel="prefetch" href="/assets/js/44.4fd9959c.js"><link rel="prefetch" href="/assets/js/45.10201422.js"><link rel="prefetch" href="/assets/js/5.6b61195e.js"><link rel="prefetch" href="/assets/js/6.d4a6ae6d.js"><link rel="prefetch" href="/assets/js/7.8da69c67.js"><link rel="prefetch" href="/assets/js/8.8044f9c2.js"><link rel="prefetch" href="/assets/js/9.8e23472b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4bffb705.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light" style="background:#F3F5F7;"><div class="v-application--wrap"><div class="container pa-0" style="max-width:900px;"><link href="https://fonts.googleapis.com/css?family=Jura" rel="stylesheet"> <div class="text-center py-8 v-toolbar__title v-app-bar-title" style="font-family:'Jura';"><div class="v-app-bar-title__content"><h1 class="primary--text">끄적끄적 개발일지</h1></div><div class="v-app-bar-title__placeholder" style="visibility:visible;"><h1 class="primary--text">끄적끄적 개발일지</h1></div></div> <div role="list" class="v-list pa-0 v-sheet theme--light v-list--flat transparent"><div role="listbox" class="v-item-group theme--light v-list-item-group indigo--text"><div class="row mb-0 text-center no-gutters justify-center"><div class="col-lg-2 col"><a href="/" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2  v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Home</div></a></div> <div class="col-lg-2 col"><a href="/category" aria-current="page" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-item--active v-list-item--active v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Category</div></a></div> <div class="col-lg-2 col"><a href="/profiles" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Profiles</div></a></div></div></div></div> <hr role="separator" aria-orientation="horizontal" class="mb-3 v-divider theme--light"> <div><div data-v-52bca676><div class="px-0 col col-12" data-v-52bca676 data-v-52bca676><div class="pa-5 px-md-7 v-card v-sheet theme--light elevation-1" data-v-52bca676><div data-v-52bca676><a href="/category/learn-tuning/ch5.html" aria-current="page" class="text-h4 font-weight-bold router-link-exact-active router-link-active" data-v-52bca676><div data-v-52bca676><!----></div>
          5부 - 소스코드 최적화
        </a> <br data-v-52bca676> <span class="text-caption grey--text text--darken-1 " data-v-52bca676>2022-02-20 &gt; 실무로 배우는 시스템 성능 최적화
        </span></div> <hr role="separator" aria-orientation="horizontal" class="mt-4 mb-4 v-divider theme--light" data-v-52bca676> <div class="theme-container" data-v-52bca676><div class="toc" data-v-52bca676><ul><li><a href="/category/learn-tuning/ch5.html#_1-기본-방향">1. 기본 방향</a></li><li><a href="/category/learn-tuning/ch5.html#_2-불필요한-작업-제거">2. 불필요한 작업 제거</a><ul><li><a href="/category/learn-tuning/ch5.html#_2-1-로깅">2.1 로깅</a></li><li><a href="/category/learn-tuning/ch5.html#_2-2-불필요한-로직">2.2 불필요한 로직</a></li><li><a href="/category/learn-tuning/ch5.html#_2-3-반복-로직">2.3 반복 로직</a></li><li><a href="/category/learn-tuning/ch5.html#_2-4-불필요한-초기화-과정">2.4 불필요한 초기화 과정</a></li></ul></li><li><a href="/category/learn-tuning/ch5.html#_3-로직-최적화">3. 로직 최적화</a><ul><li><a href="/category/learn-tuning/ch5.html#_3-1-락-최소화">3.1 락 최소화</a></li><li><a href="/category/learn-tuning/ch5.html#_3-2-문자열-처리-개선">3.2 문자열 처리 개선</a></li><li><a href="/category/learn-tuning/ch5.html#_3-3-리플렉션-호출-제거">3.3 리플렉션 호출 제거</a></li><li><a href="/category/learn-tuning/ch5.html#_3-4-채번">3.4 채번</a></li><li><a href="/category/learn-tuning/ch5.html#_3-5-날짜-연산">3.5 날짜 연산</a></li><li><a href="/category/learn-tuning/ch5.html#_3-6-시간-문자열-처리">3.6 시간 문자열 처리</a></li><li><a href="/category/learn-tuning/ch5.html#_3-7-순차-검색-제거">3.7 순차 검색 제거</a></li><li><a href="/category/learn-tuning/ch5.html#_3-8-파일-입출력-단위">3.8 파일 입출력 단위</a></li><li><a href="/category/learn-tuning/ch5.html#_3-9-sql">3.9 SQL</a></li><li><a href="/category/learn-tuning/ch5.html#_3-10-bigdecimal">3.10 BigDecimal</a></li><li><a href="/category/learn-tuning/ch5.html#_3-11-비대기-입출력-사용">3.11 비대기 입출력 사용</a></li><li><a href="/category/learn-tuning/ch5.html#_3-12-엑셀-처리">3.12 엑셀 처리</a></li><li><a href="/category/learn-tuning/ch5.html#_3-13-기타-성능-개선">3.13 기타 성능 개선</a></li><li><a href="/category/learn-tuning/ch5.html#_3-14-코드-성능-측정">3.14 코드 성능 측정</a></li></ul></li><li><a href="/category/learn-tuning/ch5.html#_4-적극적인-캐시-사용">4. 적극적인 캐시 사용</a></li><li><a href="/category/learn-tuning/ch5.html#_5-효율적인-아키텍처-구성">5. 효율적인 아키텍처 구성</a><ul><li><a href="/category/learn-tuning/ch5.html#_5-1-병렬-처리">5.1 병렬 처리</a></li><li><a href="/category/learn-tuning/ch5.html#_5-2-통신전문">5.2 통신전문</a></li><li><a href="/category/learn-tuning/ch5.html#_5-3-고객정보-조회-이력-로깅과-마스킹">5.3 고객정보 조회 이력 로깅과 마스킹</a></li><li><a href="/category/learn-tuning/ch5.html#_5-4-대량-조회-프레임워크-구성">5.4 대량 조회 프레임워크 구성</a></li><li><a href="/category/learn-tuning/ch5.html#_5-5-내부-연계시스템">5.5 내부 연계시스템</a></li><li><a href="/category/learn-tuning/ch5.html#_5-6-수직확장과-수평확장">5.6 수직확장과 수평확장</a></li></ul></li></ul></div> <div class="theme-default-content custom post markdown-body content__default" data-v-52bca676><h2 id="_1-기본-방향"><a href="#_1-기본-방향" class="header-anchor">#</a> 1. 기본 방향</h2> <ul><li>소스코드 최적화 분석 시 중점적으로 체크할 항목
<ul><li>단순 정보성 로깅을 하는 부분이 있는가?</li> <li>로깅을 하지 않을 때 로깅을 위한 문자열이나 데이터가 만들어지고 있는가?</li> <li>전문 파싱이나 환경설정 로딩과 같은 작업이 반복 수행되는가?</li> <li>락 범위를 최소화하거나 락을 회피할 수 있는가?</li> <li>집합 데이터에 대한 검색 방식은 적절한가?</li> <li>문자열 처리에 오버헤드가 존재하는가?</li> <li>반복 처리 로직이 존재하는가?</li> <li>기능이 단순한 함수이지만 호출 횟수가 많아 성능에 영향을 미치고 있는가?</li> <li>영업일, 계정과목, 공통코드 같은 소량 테이블에 빈번한 조회가 발생하는가?</li> <li>배치 같은 경우 결과가 한정적인 데이터에 대한 반복조회가 많이 있는가?</li> <li>포털 화면에서 보여지는 게시물 목록 같은 것을 캐시할 수 있는가?</li> <li>프로그램 흐름상 병목이 존재하는가?</li> <li>대량건 조회는 가능한가?</li> <li>송수신 전문 포맷과 크기는 시스템 특성과 네트워크 환경에 적합한가?</li> <li>한 서비스 내에서 연계 시스템과 빈번하게 통신하는가?</li></ul></li></ul> <h2 id="_2-불필요한-작업-제거"><a href="#_2-불필요한-작업-제거" class="header-anchor">#</a> 2. 불필요한 작업 제거</h2> <h3 id="_2-1-로깅"><a href="#_2-1-로깅" class="header-anchor">#</a> 2.1 로깅</h3> <ul><li>로그는 시스템 관리자와 개발자에게 수행된 프로그램에 대한 추가 정보를 제공하기 위해 있는 것이지 로그가 있느냐 여부가 핵심 기능에 영향을 주는 것은 아니다.</li></ul> <h4 id="_2-1-1-잘못-사용된-로깅-수준"><a href="#_2-1-1-잘못-사용된-로깅-수준" class="header-anchor">#</a> 2.1.1 잘못 사용된 로깅 수준</h4> <ul><li>Log4J의 경우 <code>전체(ALL)</code>, <code>추적(Trace)</code>, <code>디버그(Debug)</code>, <code>정보(info)</code>, <code>경고(Warn)</code>, <code>에러(Error)</code>, <code>심각(Fatal)</code>, <code>끄기(Off)</code>라는 8가지 수준이 제공된다.</li> <li>운영 시에는 경고, 에러 수준으로 로깅을 설정한다.
<ul><li>운영 시스템의 로그 수준이 디버그로 낮게 설정돼 있으면 로깅을 위한 오버헤드 코드와 파일 입출력 병목으로 응답시간이 느려질 수 있다.</li></ul></li> <li>추적이나 디버그, 정보 성격의 로그를 에러나 심각으로 남기지 않는다.</li></ul> <h4 id="_2-1-2-로깅을-위한-불필요한-메시지-생성"><a href="#_2-1-2-로깅을-위한-불필요한-메시지-생성" class="header-anchor">#</a> 2.1.2 로깅을 위한 불필요한 메시지 생성</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>// CASE <span class="token number">1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>int <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i++<span class="token punctuation">)</span><span class="token punctuation">{</span>
	Log.debug.println<span class="token punctuation">(</span><span class="token string">&quot;파일 서버에 전송할 입력 매개변수 + &quot;</span> + output<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

// CASE <span class="token number">2</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>int <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i++<span class="token punctuation">)</span><span class="token punctuation">{</span>
	if<span class="token punctuation">(</span>Log.debug.isEnabled<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>
		Log.debug.println<span class="token punctuation">(</span><span class="token string">&quot;파일 서버에 전송할 입력 매개변수 + &quot;</span> + output<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li><code>CASE 1</code>은 println 내부에서 디버그에 대한 로깅 여부를 확인해 출력하지 않아도 자바에서는 <code>“String” + Object.toString()</code> 문자열을 만드는 작업이 수행된다.</li> <li><code>CASE 2</code>는 <code>if(Log.debug.isEnabled())</code> 조건문으로 로깅 코드를 감싸서 로깅 수준이 비활성화 상태면 문자열을 만드는 작업이 수행되지 않는다.</li></ul> <h4 id="_2-1-3-로깅을-효율적으로-하기-위한-개선"><a href="#_2-1-3-로깅을-효율적으로-하기-위한-개선" class="header-anchor">#</a> 2.1.3 로깅을 효율적으로 하기 위한 개선</h4> <ul><li>개발 서버에 로깅하는 양이 너무 많아 원하는 로그를 찾는데 시간이 걸리고 성능 저하가 발생한다면 개발 서버도 기본 로그 수준을 경고로 설정하고, 테스트하는 구간만 디버그 수준으로 설정할 수 있다.</li> <li>서비스 요청 단위로 로깅을 관리하면 특정 서비스 요청만 디버그 수준으로 설정해 해당 서비스 전체의 성능 저하 없이 셀제 운영환경에서 디버그를 수행할 수 있다.</li></ul> <h4 id="_2-1-4-트랜잭션-저널-로그"><a href="#_2-1-4-트랜잭션-저널-로그" class="header-anchor">#</a> 2.1.4 트랜잭션 저널 로그</h4> <h3 id="_2-2-불필요한-로직"><a href="#_2-2-불필요한-로직" class="header-anchor">#</a> 2.2 불필요한 로직</h3> <ul><li>불필요한 로직은 공통 모듈을 사용할 때 주로 나타난다.
<ul><li>대체로 공통 모듈은 다양한 경우에 대비해 여러 가지 값을 제공한다.</li> <li>어떤 로직에서는 필요하지 않은 정보도 함께 읽어오게 된다.</li></ul></li> <li>이를 방지하기 위해 포괄적인 정보 외에 사용 패턴을 고려해 세분화된 정보를 제공하는 함수도 다양하게 제공해야 한다.</li></ul> <h3 id="_2-3-반복-로직"><a href="#_2-3-반복-로직" class="header-anchor">#</a> 2.3 반복 로직</h3> <ul><li>성능에 영향을 주는 부분이 반복 작업으로 분석됐다면 맨 처음에 수행된 결괏값을 저장해 뒀다가 재사용할 수 있게 변수나 캐시를 둠으로써 성능 저하를 해결할 수 있다.</li> <li>반복의 예
<ul><li>통신전문에서 동일한 항목을 읽어내는 것임에도 파싱 작업을 한다.</li> <li><code>for</code>, <code>while</code> 문 안에서 매번 동일한 값으로 동일한 계산식을 수행하는 부분이 있다.</li> <li>외부 인터페이스를 호출할 때마다 관련 환경설정 파일을 매번 읽어 들인다.</li></ul></li></ul> <h3 id="_2-4-불필요한-초기화-과정"><a href="#_2-4-불필요한-초기화-과정" class="header-anchor">#</a> 2.4 불필요한 초기화 과정</h3> <ul><li>내부적으로 초기화 과정이 복잡하고 시간이 오래 걸리는 작업임에도 개발자 입장에서 코드를 작성하는 부분은 너무 단순해 모르고 넘어가는 경우가 있다.
<ul><li>자바의 JAXB와 스프링 프레임워크의 RestTemplate등 이 있다.</li></ul></li> <li>스레드 안전한 클래스라면 싱글톤으로 선언하여 재사용할 수 있다.</li> <li>스레드 안전하지 않다면 ThreadLocal 같은 기능을 사용해 스레드별로 만들어 사용할 수도 있다.</li></ul> <h2 id="_3-로직-최적화"><a href="#_3-로직-최적화" class="header-anchor">#</a> 3. 로직 최적화</h2> <h3 id="_3-1-락-최소화"><a href="#_3-1-락-최소화" class="header-anchor">#</a> 3.1 락 최소화</h3> <ul><li>애플리케이션에서도 여러 프로세스나 스레드가 동일 데이터에 접근함으로써 발생할 수 있는 오류를 방지하기 위해 락을 사용한다.</li> <li>C/C++는 세마포어, 뮤텍스, 크리티컬 섹션 등으로 락을 제공</li> <li>자바는 synchronized, wait/nofity 등 제어 구문 외에도 동시성을 제어하는 클래스를 제공한다.</li></ul> <h4 id="_3-1-1-락-범위-최소화"><a href="#_3-1-1-락-범위-최소화" class="header-anchor">#</a> 3.1.1 락 범위 최소화</h4> <ul><li>캐시를 구성할 때 보통 데이터 종류별로 하나의 메모리 구조로 설계하는 것이 일반적이다.</li> <li>이 경우 해당 메모리 전체에 대해서 싱글포인트락이 존재하는 경우 동시 대량 처리 시 락 경합이 발생할 수 있으므로 복수 개의 메모리 구조로 쪼개서 락 경합을 분산할 수 있다.</li></ul> <h4 id="_3-1-2-락-제거"><a href="#_3-1-2-락-제거" class="header-anchor">#</a> 3.1.2 락 제거</h4> <h3 id="_3-2-문자열-처리-개선"><a href="#_3-2-문자열-처리-개선" class="header-anchor">#</a> 3.2 문자열 처리 개선</h3> <h4 id="_3-2-1-string-format-메서드"><a href="#_3-2-1-string-format-메서드" class="header-anchor">#</a> 3.2.1 String.format 메서드</h4> <ul><li>StringBuilder 로 처리하는 것에 비해 String.format이 10배정도 느리다.</li></ul> <h4 id="_3-2-2-string-replaceall-메서드"><a href="#_3-2-2-string-replaceall-메서드" class="header-anchor">#</a> 3.2.2 String.replaceAll 메서드</h4> <ul><li>replaceAll 내부는 정규 표현식을 사용하는 형태로 구현돼 있어서 복잡하다.</li></ul> <h4 id="_3-2-3-문자열-합치기"><a href="#_3-2-3-문자열-합치기" class="header-anchor">#</a> 3.2.3 문자열 합치기</h4> <ul><li>자바 초기에는 “String” + 변수 + “String” 형태로 문자열을 처리하면 합치는 횟수만큼 객체가 생성되어 성능이 좋지 않았다.</li> <li>하지만 자바 버전이 올라가면서 컴파일러가 코드 최적화를 통해 StringBuilder로 대체하므로 개선 대상으로 고려하지 않아도 된다.</li></ul> <h3 id="_3-3-리플렉션-호출-제거"><a href="#_3-3-리플렉션-호출-제거" class="header-anchor">#</a> 3.3 리플렉션 호출 제거</h3> <ul><li>리플렉션 호출은 프로그램에 유연성과 확장성을 제공하지만 이를 구현하기 위해 객체를 생성하고 메서드를 호출하기 위한 준비 작업 하나하나가 직접 메서드를 호출하는 것과 맞먹는 비용이 든다.</li></ul> <h3 id="_3-4-채번"><a href="#_3-4-채번" class="header-anchor">#</a> 3.4 채번</h3> <ul><li>애플리케이션 코드 내에서 채번이 이뤄지는 경우에는 성능에 큰 영향이 없으나 DB 내에서 채번이 이뤄지는 경우에는 성능 저하의 원인이 되는 경우가 많다.</li> <li>DB 내 채번 방식
<ul><li>기존 최대값 조회 MAX+1
<ul><li>동시에 채번이 이뤄지는 경우 동일한 번호가 채번되어 후속 작업에서 에러가 발생할 수 있다.</li></ul></li> <li>채번 테이블
<ul><li>채번 테이블에 유형별 레코드로 채번 번호를 관리하는 방식</li></ul></li> <li>DB 채번 기능
<ul><li>DB에서 재공하는 채번 기능을 사용하는 것으로 세 가지 방식 중 가장 성능이 우수하다.</li></ul></li></ul></li> <li>매번 DB에서 채번하게 되면 10,000번 채번에 DB 호출이 10,000번 수행되어야 한다.</li> <li>하지만 채번 테이블의 채번 캐시 크기를  예를 10,00 단위로 사용하게 되면 10,000번 채번 1번당 DB 채번이 이뤄지므로 성능이 훨등히 개선된다.</li></ul> <h3 id="_3-5-날짜-연산"><a href="#_3-5-날짜-연산" class="header-anchor">#</a> 3.5 날짜 연산</h3> <h3 id="_3-6-시간-문자열-처리"><a href="#_3-6-시간-문자열-처리" class="header-anchor">#</a> 3.6 시간 문자열 처리</h3> <h3 id="_3-7-순차-검색-제거"><a href="#_3-7-순차-검색-제거" class="header-anchor">#</a> 3.7 순차 검색 제거</h3> <h3 id="_3-8-파일-입출력-단위"><a href="#_3-8-파일-입출력-단위" class="header-anchor">#</a> 3.8 파일 입출력 단위</h3> <ul><li>파일 처리는 입출력 단위가 큰 것이 성능에 유리하다.</li> <li>버퍼를 가지고 있는 입출력 클래스를 사용해 버퍼 단위로 입출력이 발생하게 하는 편이 우수한 성능을 발휘한다.</li> <li><code>BufferedOutpuStream</code>, <code>BufferedInputStream</code></li></ul> <h3 id="_3-9-sql"><a href="#_3-9-sql" class="header-anchor">#</a> 3.9 SQL</h3> <ul><li><strong>SQL 바인드 변수 처리</strong> <ul><li>SQL을 수행할 때는 PreparedStatement 객체를 사용하여 바인드 변수 처리하는 것이 기본 원칙이다.
<ul><li>SQL 캐시효과, 하드 파싱, 공유 풀 경합 등</li> <li>바인드 변수를 사용하지 않으면 필요 이상으로 많은 SQL이 공유 풀에 저장되어 메모리 사용량이 증가한다.</li></ul></li></ul></li> <li><strong>자원 반납</strong> <ul><li>SQL을 수행한 후 사용한 JDBC 자원을 반납하지 않으면 성능 저하나 장애가 유발된다.</li> <li>Statement를 반납하지 않으면 DB 프로세스 당 할당된 최대 커서 수에 도달해 더는 SQL을 처리할 수 없는 상황이 되고, 자바 메모리 누수 또한 발생한다.</li> <li>자원 반납은 ResultSet, Statement, Connection 순으로 수행한다.</li></ul></li> <li><strong>DB 연결 풀 사용</strong> <ul><li>DB는 새로운 연결을 맺을 때 많은 비용이 드므로 일반적으로 연결 풀을 사용한다.</li> <li>평상시 부하는 연결을 늘리지 않고도 처리할 수 있을 정도로 최소 연결 풀 개수를 유지한다.</li> <li>더미 쿼리를 사용해 주기적으로 연결을 테스트함으로써 DB 연결이 방화벽이나 운영체제 설정에 의해 끊어지지 않게 한다.</li></ul></li></ul> <h3 id="_3-10-bigdecimal"><a href="#_3-10-bigdecimal" class="header-anchor">#</a> 3.10 BigDecimal</h3> <ul><li>float 이나 double 숫자 타입은 정확성이 아닌 성능 위주로 설계된 부동 소수 형식을 사용하기 때문에 일부 값이 정확하지 않고 근사값으로 표현된다.</li> <li>BigDecimal을 생성할 때 new BigDecimal(double) 보다는 new BigDecimal(String)을 사용한다.</li> <li>double로 변환해야 하는 경우에는 BigDecimal.valueOf(double) 메서드를 사용한다.</li></ul> <h3 id="_3-11-비대기-입출력-사용"><a href="#_3-11-비대기-입출력-사용" class="header-anchor">#</a> 3.11 비대기 입출력 사용</h3> <ul><li>논블럭킹 I/O 를 사용하면 읽어내고자 하는 야보다 데이터가 적거나 전혀 없더라도 현재 있는 데이터 양만큼 읽고 나온다.</li></ul> <h3 id="_3-12-엑셀-처리"><a href="#_3-12-엑셀-처리" class="header-anchor">#</a> 3.12 엑셀 처리</h3> <ul><li>엑셀 포맷을 다룰 때 일반적으로 아파치의 POI를 사용한다.</li> <li>POI는 엑셀 파일을 다룰 때 크게 스트리밍과 인 메모리 트리라는 두 가지 방식을 사용한다.
<ul><li>인메모리 트리는 문서 내용 전체를 메모리에 유지하므로 메모리 사용량이 크고, 스트리밍에 비해 속도가 느리다.</li></ul></li> <li>버퍼드 스트리밍은 전체 데이터를 메모리에 가지고 있지 않고 일정 건수가 되면 디스크로 내리기 때문에 메모리 제약이 없어 큰 용량의 데이터 처리가 가능하다.</li></ul> <h3 id="_3-13-기타-성능-개선"><a href="#_3-13-기타-성능-개선" class="header-anchor">#</a> 3.13 기타 성능 개선</h3> <h3 id="_3-14-코드-성능-측정"><a href="#_3-14-코드-성능-측정" class="header-anchor">#</a> 3.14 코드 성능 측정</h3> <h2 id="_4-적극적인-캐시-사용"><a href="#_4-적극적인-캐시-사용" class="header-anchor">#</a> 4. 적극적인 캐시 사용</h2> <ul><li>성능 튜닝의 한 축은 서비스 간이나 서비스 내에서 반복되는 로직을 제거하는 것 이다.</li> <li>기존에 작업한 결과를 저장해 뒀다아 이후에 다시 동일한 작업이 수행됐을 때 결과를 재사용하면 반복되는 로직을 제거할 수 있다.</li></ul> <ol><li>브라우저</li> <li>도메인명에 대한 주소 캐시</li> <li>콘텐츠 캐시</li> <li>웹 서버</li> <li>환경설정 캐시</li> <li>콘텐츠 캐시</li> <li>WAS</li> <li>환경설정 캐시</li> <li>프로그램 모듈 캐시</li> <li>애플리케이션</li> <li>적극적인 사용이 요구되는 부분</li> <li>프레임 워크</li> <li>환경설정 캐시</li> <li>서비스와 프로그램 구성 캐시</li> <li>송수신 전문 구조 캐시</li> <li>SQL 캐시</li> <li>애플리케이션을 위한 캐시 제공</li> <li>DBMS</li> <li>환경설정 캐시</li> <li>테이블, 인덱스, 권한 등 구성정보 캐시</li> <li>SQL 실행계획 캐시</li> <li>데이터 캐시</li></ol> <h2 id="_5-효율적인-아키텍처-구성"><a href="#_5-효율적인-아키텍처-구성" class="header-anchor">#</a> 5. 효율적인 아키텍처 구성</h2> <h3 id="_5-1-병렬-처리"><a href="#_5-1-병렬-처리" class="header-anchor">#</a> 5.1 병렬 처리</h3> <ul><li>웹 기반 시스템은 각 구성 서버마다 병렬 처리를 설정할 수 있다.</li> <li>웹 서버는 사용자의 모든 서비스 요청을 받아들이는 곳으로, 한 사용자가 6개 이상의 병렬 스레드를 사용할 수도 있다.</li> <li>그러나 요청이 WAS 까지 도달하면 스레드를 한두 개 사용한다.</li> <li>DB 동시 작업은 애플리케이션 처리시간과 DB 연결 사용시간이 거의 일치하면 스레드 풀 설정과 거의 동등한 수준으로 DB 연결 풀을 사용한다.</li> <li>아키텍처를 스레드 병렬 구조로 만들 때는 반드시 앞쪽에 큐를 둬서 스레드가 작압 단위 간에 쉼 없이 연속해서 처리할 수 있도록 해야한다.</li></ul> <h3 id="_5-2-통신전문"><a href="#_5-2-통신전문" class="header-anchor">#</a> 5.2 통신전문</h3> <ul><li>XML의 경우에는 메모리 사용량과 전문 크기가 많다.</li> <li>이를 개선하기 위해 컬럼명을 레코드 첫 부분에 한번만 기술하고 이후 반복되는 레코드에서 컬럼명을 생략하고 데이터만 기술하는 변형된 형태의 JSON을 적용했다.</li> <li>따라서 고성능 시스템이 필요하거나 사용자가 원격지에 있어 데이터 전송량을 줄여 속도를 개선해야 하는 경우에는 다른 형식의 전문을 고려해야 한다.</li></ul> <h3 id="_5-3-고객정보-조회-이력-로깅과-마스킹"><a href="#_5-3-고객정보-조회-이력-로깅과-마스킹" class="header-anchor">#</a> 5.3 고객정보 조회 이력 로깅과 마스킹</h3> <h3 id="_5-4-대량-조회-프레임워크-구성"><a href="#_5-4-대량-조회-프레임워크-구성" class="header-anchor">#</a> 5.4 대량 조회 프레임워크 구성</h3> <ul><li>데이터를 대량으로 조회하다보면 메모리 부족으로 애플리케이션 서버가 다운되는 문제를 경함하게 된다.</li> <li>아래와 같은 방안으로 대량건 조회를 대처할 수 있다.
<ul><li>프레임워크 DAO에서 일정건이상 조회하면 예외를 발생시킨다.</li> <li>대량건 조회는 페이징 처리를 통해 메모리에 무리가 없는 단위로 나눠서 처리한다.</li> <li>대량 조회가 이뤄지지 않도록 조회 건수를 줄이는 필수 조건을 입력하도록 유도한다.</li> <li>일반 온라인 업무에 영향을 주지 않도록 대량 조회 전용 WAS 인스턴스를 구성한다.</li> <li>배치 같은 별도 프로세스에서 대량 건을 파일로 생성한 다음 파일을 다운로드하게 한다.</li></ul></li> <li>프레임워크에서 대량건 조회를 지원하기 위해서는 자바의 경우 JDBC ResultSet과 전문 생성 부분을 바로 연결해야 한다.</li></ul> <h3 id="_5-5-내부-연계시스템"><a href="#_5-5-내부-연계시스템" class="header-anchor">#</a> 5.5 내부 연계시스템</h3> <h3 id="_5-6-수직확장과-수평확장"><a href="#_5-6-수직확장과-수평확장" class="header-anchor">#</a> 5.6 수직확장과 수평확장</h3> <ul><li>성능 저하가 발생하면 서버를 늘리는 수평확장보다 CPU나 메모리를 증설하는 수직확장을 선호해 왔다.
<ul><li>수평확장은 서버간 동기화로 인한 성능 저하가 발생할 수 있기 때문에</li></ul></li> <li>수평확장이 가능하도록 아키텍처를 구성하려면 다음과 같은 사항을 고려해야 한다.</li></ul> <ol><li>데이터베이스 샤딩</li> <li>샤딩은 여러 DB에 데이터를 나눠서 저장하는 기술이다.</li> <li>파티션은 한 DB에 분산 저장하는 것이고, 샤딩은 복수 DB에 분산 저장한다.</li> <li>샤딩은 DBMS가 제공하는 기능이 아니므로 애플리케이션에서 로직으로 구현해서 적용한다.</li> <li>DB 샤딩에서 수평확장이 용이하게 하려면 초기 샤딩 아키텍처를 설계할 때 온라인 상태에서 DB 서버를 늘리고 데이터를 옮길 수 있는 방안을 마련해야 한다.</li> <li>DB 서버가 4대에서 6대로 증가할 때 샤딩된 기존 저장된 DB서버를 찾아가고 증가된 DB수에 따라 데이터 재배치가 이뤄질 수 있어야 한다.</li> <li>DB 샤딩의 한계는 구축하기가 어렵고, 샤딩된 데이터로 인해 테이블 간에 조인이 제한적이거나 불가능하다는 것이다.</li> <li>대량의 데이터 처리를 고려할 때 데이터 저장 솔루션으로 고려하는 것이 NoSQL 이다.</li> <li>NoSQL을 이용하면 자동분할과 노드 추가 시 자동 재분배, 이중화에 의한 장애 대응까지 솔류션이 지원하므로 유연한 수평확장이 가능하다.</li> <li>StatelessProcessing</li> <li>WAS에서 세션을 통해 사용자 인증 정보를 관리하는 경우가 많다.</li> <li>여러 대의 WAS 서버를 사용하는 경우 세션 클러스터링 기술을 사용한다.</li> <li>그런데 서버 수가 많아지면 이마저도 성능 저하 요인이 된다.</li> <li>시스템을 Stateless 아키텍처로 만들어지면 사용자 서비스 요청이 어떤 애플리케이션 서버에서도 처리할 수 있다.</li> <li>인메모리 데이터 그리드</li> <li>인메모리 데이터 그리드는 키캆 형식의 데이터 캐시 솔류션이다.</li> <li>DBMS에 저장된 데이터나 사용자 서비스 호출 간에 공유할 데이터를 캐시해서 성능을 개선할 목적으로 사용한다.</li> <li>상대적으로 데이터의 생명주기가 짧고 변경이 발생하지 않는 데이터에 대해 캐시하는 것이다.</li></ol></div></div></div></div> <div data-v-52bca676></div></div></div></div> <footer prime="" class="v-footer mt-2 v-sheet theme--light v-footer--padless" style="background:#F3F5F7;"><div class="col col-12"><div class="text-center v-card v-card--flat v-sheet theme--light rounded-0" style="background:#F3F5F7;"><div class="v-card__text"><p>Copyright © 2021 All Right <em>끄적끄적 개발일지</em></p> <p>
          px201226@gmail.com .
          <a href="https://github.com/px201226" target="_blank">GitHub</a>
          .
          <a href="http://px201226.github.io/blog" target="_blank">Blog</a>
          .
        </p></div></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.70752fd1.js" defer></script><script src="/assets/js/17.4dcf5890.js" defer></script><script src="/assets/js/41.ce50acc7.js" defer></script>
  </body>
</html>
