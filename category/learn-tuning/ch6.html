<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>6부 - SQL 최적화 | 끄적끄적 개발일지</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://www.googletagmanager.com/gtag/js?id=G-SE0BLFFFMG"></script>
    <meta name="description" content="Awesome description">
    
    <link rel="preload" href="/assets/css/0.styles.4bffb705.css" as="style"><link rel="preload" href="/assets/js/app.70752fd1.js" as="script"><link rel="preload" href="/assets/js/17.4dcf5890.js" as="script"><link rel="preload" href="/assets/js/42.b0e56f29.js" as="script"><link rel="prefetch" href="/assets/js/10.1fe66b22.js"><link rel="prefetch" href="/assets/js/11.3e8e6dd5.js"><link rel="prefetch" href="/assets/js/12.96743d99.js"><link rel="prefetch" href="/assets/js/13.5cab9bdd.js"><link rel="prefetch" href="/assets/js/14.e412fb10.js"><link rel="prefetch" href="/assets/js/15.1da5e3dc.js"><link rel="prefetch" href="/assets/js/16.8ebbd2f8.js"><link rel="prefetch" href="/assets/js/18.5bfa6a85.js"><link rel="prefetch" href="/assets/js/19.12bd999a.js"><link rel="prefetch" href="/assets/js/2.0c177ed1.js"><link rel="prefetch" href="/assets/js/20.87648ee0.js"><link rel="prefetch" href="/assets/js/21.7fbb071c.js"><link rel="prefetch" href="/assets/js/22.3f3676f6.js"><link rel="prefetch" href="/assets/js/23.114b4211.js"><link rel="prefetch" href="/assets/js/24.7077956a.js"><link rel="prefetch" href="/assets/js/25.42ad01f0.js"><link rel="prefetch" href="/assets/js/26.c356a4d4.js"><link rel="prefetch" href="/assets/js/27.52a125bd.js"><link rel="prefetch" href="/assets/js/28.692ecc68.js"><link rel="prefetch" href="/assets/js/29.d205c4cb.js"><link rel="prefetch" href="/assets/js/3.6ee8ed88.js"><link rel="prefetch" href="/assets/js/30.c221f26d.js"><link rel="prefetch" href="/assets/js/31.65e9c8ce.js"><link rel="prefetch" href="/assets/js/32.7ddfb0f5.js"><link rel="prefetch" href="/assets/js/33.7f74862d.js"><link rel="prefetch" href="/assets/js/34.21b19958.js"><link rel="prefetch" href="/assets/js/35.428cdea5.js"><link rel="prefetch" href="/assets/js/36.ef46a37e.js"><link rel="prefetch" href="/assets/js/37.290a8b87.js"><link rel="prefetch" href="/assets/js/38.61002123.js"><link rel="prefetch" href="/assets/js/39.fbbd1cce.js"><link rel="prefetch" href="/assets/js/4.39bb3471.js"><link rel="prefetch" href="/assets/js/40.ee500a11.js"><link rel="prefetch" href="/assets/js/41.ce50acc7.js"><link rel="prefetch" href="/assets/js/43.c4683cd4.js"><link rel="prefetch" href="/assets/js/44.4fd9959c.js"><link rel="prefetch" href="/assets/js/45.10201422.js"><link rel="prefetch" href="/assets/js/5.6b61195e.js"><link rel="prefetch" href="/assets/js/6.d4a6ae6d.js"><link rel="prefetch" href="/assets/js/7.8da69c67.js"><link rel="prefetch" href="/assets/js/8.8044f9c2.js"><link rel="prefetch" href="/assets/js/9.8e23472b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4bffb705.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light" style="background:#F3F5F7;"><div class="v-application--wrap"><div class="container pa-0" style="max-width:900px;"><link href="https://fonts.googleapis.com/css?family=Jura" rel="stylesheet"> <div class="text-center py-8 v-toolbar__title v-app-bar-title" style="font-family:'Jura';"><div class="v-app-bar-title__content"><h1 class="primary--text">끄적끄적 개발일지</h1></div><div class="v-app-bar-title__placeholder" style="visibility:visible;"><h1 class="primary--text">끄적끄적 개발일지</h1></div></div> <div role="list" class="v-list pa-0 v-sheet theme--light v-list--flat transparent"><div role="listbox" class="v-item-group theme--light v-list-item-group indigo--text"><div class="row mb-0 text-center no-gutters justify-center"><div class="col-lg-2 col"><a href="/" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2  v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Home</div></a></div> <div class="col-lg-2 col"><a href="/category" aria-current="page" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-item--active v-list-item--active v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Category</div></a></div> <div class="col-lg-2 col"><a href="/profiles" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Profiles</div></a></div></div></div></div> <hr role="separator" aria-orientation="horizontal" class="mb-3 v-divider theme--light"> <div><div data-v-52bca676><div class="px-0 col col-12" data-v-52bca676 data-v-52bca676><div class="pa-5 px-md-7 v-card v-sheet theme--light elevation-1" data-v-52bca676><div data-v-52bca676><a href="/category/learn-tuning/ch6.html" aria-current="page" class="text-h4 font-weight-bold router-link-exact-active router-link-active" data-v-52bca676><div data-v-52bca676><!----></div>
          6부 - SQL 최적화
        </a> <br data-v-52bca676> <span class="text-caption grey--text text--darken-1 " data-v-52bca676>2022-03-13 &gt; 실무로 배우는 시스템 성능 최적화
        </span></div> <hr role="separator" aria-orientation="horizontal" class="mt-4 mb-4 v-divider theme--light" data-v-52bca676> <div class="theme-container" data-v-52bca676><div class="toc" data-v-52bca676><ul><li><a href="/category/learn-tuning/ch6.html#_1-기본-방향">1. 기본 방향</a></li><li><a href="/category/learn-tuning/ch6.html#_2-sql-을-위한-기본-지식">2. SQL 을 위한 기본 지식</a><ul><li><a href="/category/learn-tuning/ch6.html#_2-1-데이터베이스의-기본-구조">2.1 데이터베이스의 기본 구조</a></li><li><a href="/category/learn-tuning/ch6.html#_2-2-블록-단위-처리">2.2 블록 단위 처리</a></li><li><a href="/category/learn-tuning/ch6.html#_2-3-캐시-io-대-물리-io">2.3 캐시 IO 대 물리 IO</a></li></ul></li><li><a href="/category/learn-tuning/ch6.html#_3-성능-개선-대상-식별">3. 성능 개선 대상 식별</a><ul><li><a href="/category/learn-tuning/ch6.html#_3-1-sql-수행-통계">3.1 SQL 수행 통계</a></li><li><a href="/category/learn-tuning/ch6.html#_3-2-실행-중인-세션-상태">3.2 실행 중인 세션 상태</a></li><li><a href="/category/learn-tuning/ch6.html#_3-3-수행-중인-sql의-수행-상태-확인">3.3 수행 중인 SQL의 수행 상태 확인</a></li><li><a href="/category/learn-tuning/ch6.html#_3-4-락-대기">3.4 락 대기</a></li><li><a href="/category/learn-tuning/ch6.html#_3-5-awr-보고서">3.5 AWR 보고서</a></li><li><a href="/category/learn-tuning/ch6.html#_3-6-statspack">3.6 StatsPack</a></li></ul></li><li><a href="/category/learn-tuning/ch6.html#_4-sql-실행계획">4. SQL 실행계획</a><ul><li><a href="/category/learn-tuning/ch6.html#_4-1-sql-실행계확과-수행-결과">4.1 SQL 실행계확과 수행 결과</a></li><li><a href="/category/learn-tuning/ch6.html#_4-2-실행계획의-이해">4.2 실행계획의 이해</a></li><li><a href="/category/learn-tuning/ch6.html#_4-3-인덱스">4.3 인덱스</a></li><li><a href="/category/learn-tuning/ch6.html#_4-4-테이블">4.4 테이블</a></li></ul></li></ul></div> <div class="theme-default-content custom post markdown-body content__default" data-v-52bca676><h2 id="_1-기본-방향"><a href="#_1-기본-방향" class="header-anchor">#</a> 1. 기본 방향</h2> <ul><li>SQL 튜닝 시 중점적으로 점검할 항목
<ul><li>통계
<ul><li>최적 실행계획이 수립되도록 테이블 통계 정보가 존재하고 주기적으로 갱신되는가?</li></ul></li> <li>인덱스
<ul><li>적절한 인덱스를 사용하는가?</li> <li>인덱스가 있음에도 사용하지 못하는가?</li> <li>인덱스 수가 많아서 INSERT 처리 시간이 오래걸리는가?</li></ul></li> <li>조인
<ul><li>처리하는 데이터 양과 연결 관계에 맞는 조인 방식이 선정됐는가?</li> <li>조인 관계에서 선행 테이블은 적합한가?</li></ul></li> <li>테이블
<ul><li>데이터 수정과 삭제로 테이블 조각화가 발생해 재구성할 필요는 있는가?</li> <li>파티션으로 INSERT 부하를 분산해 성능 개선이 가능한가?</li></ul></li></ul></li></ul> <h2 id="_2-sql-을-위한-기본-지식"><a href="#_2-sql-을-위한-기본-지식" class="header-anchor">#</a> 2. SQL 을 위한 기본 지식</h2> <h3 id="_2-1-데이터베이스의-기본-구조"><a href="#_2-1-데이터베이스의-기본-구조" class="header-anchor">#</a> 2.1 데이터베이스의 기본 구조</h3> <ul><li><p><strong>클라이언트</strong></p> <ul><li>클라이언트는 DB 솔루션에서 제공하는 클라이언트 모듈을 통해 데이터베이스에 저장된 데이터를 조회하거나 수정할 수 있는 기능을 제공한다.</li> <li>클라이언트 측면에서 중요 개선 사항
<ul><li>복구 건의 레코드를 한번의 호출로 집합 처리하거나 두 개 이상의 쿼리를 통합 처리함으로써 DB 호출 수를 줄인다.</li> <li>JDBC Statement를 캐시하거나 SQL 커서를 오픈한 상태로 유지함으로써 쿼리 소프트 파싱을 회피해 성능을 개선할 수 있다.</li> <li>패치 크기(Fetch Size)를 증가시켜 DB 엔진에서 클라이언트로 조회된 데이터를 전송 할 때 한번에 많은 데이터를 전송함으로써 성능을 개선할 수 있다.</li></ul></li></ul></li> <li><p><strong>데이터베이스 엔진</strong></p> <ul><li>엔진은 클라이언트 요청을 받아 파일시스템에 저장된 데이터를 조회하거나 수정하는 기능을 수행한다.</li> <li>엔진 내부에는 락 관리와 트랜잭션 관리가 이뤄진다.</li> <li>데이터베이스 엔진은 처리 성능 개선을 위해 동작에 필요한 기초 정보와 파일시스템에 저장된 데이터 중 일부를 메모리에 캐시하고 있어 큰 메모리를 필요로 한다.</li></ul></li> <li><p><strong>데이터베이스 엔진 메모리의 주요 용도</strong></p> <ul><li>데이터 캐시
<ul><li>파일시스템에 저장된 데이터가 조회되면 해당 데이터를 메모리 데이터 캐시에 저장해 이후 동일 데이터 조회 시 파일 시스템의 물리적인 입출력이 발생하지 않게 한다.</li></ul></li> <li>실행계획
<ul><li>SQL이 처음 호출되면 대상 데이터를 찾는 방법이 기술돼 있는 실행계획을 만들고 이후 동일한 SQL이 수행되면 기존에 만들어진 실행계획을 재사용한다.</li></ul></li> <li>DB 정보
<ul><li>테이블 구성 정보(메타 정보)와 통계를 저장하고 있으면서 SQL을 검증하고 실행계획을 수립할 때 참조한다.</li></ul></li> <li>복구 로그
<ul><li>복구 로그는 데이터 변경 전후 내역을 모두 저장해 데이터베이스에 장애가 발생했을 때 데이터를 복구하는 용도로 사용한다.</li></ul></li></ul></li> <li><p><strong>데이터베이스 서버 성능 개선을 위해서는 아래 사항에 유의해야 한다.</strong></p> <ul><li>데이터 캐시는 클수록 성능 개선 효과가 있지만 개선 효과가 메모리 크기에 비례해서 증가하지는 않는다. 어느 수준이상 증가하면 개선 효과가 감소되는 커브 곡선을 그리므로 캐시 적중률을 참고해서 적당한 크기를 찾아야 한다.</li> <li>바인드 변수를 사용하지 않으면 SQL의 조회 조건 값이 달리질 때마다 엔진은 서로 다른 SQL로 인식해 새로운 실행계획을 세우는 하드 파싱이 발생한다.</li> <li>테이블과 인덱스 전체 블록 개수, 데이터 건수, 항목별 선택도, 인덱스 현황 등 통계 정보를 기반으로 실행계획을 수립하는데 통계 정보가 없거나 오래되어 실제 데이터 분포와 다른 경우 잘못된 실행계획이 수립되어 성능 저하를 유발할 수 있다.</li></ul></li> <li><p><strong>파일 시스템(저장)</strong></p> <ul><li>데이터 조회 시 물리적 IO가 발생하므로 데이터베이스 구조에서 가장 느린 부분이다.</li></ul></li></ul> <h3 id="_2-2-블록-단위-처리"><a href="#_2-2-블록-단위-처리" class="header-anchor">#</a> 2.2 블록 단위 처리</h3> <ul><li>데이터베이스의 저장 구조는 데이터베이스, 테이블스페이스, 세그먼트, 익스텐트, 블록순으로 계층 관계를 이루고 있다.</li> <li>불록은 데이터 IO의 가장 작은 단위이며, 할당할 수 있는 최소 단위이기도 하다.</li> <li>SELECT를 실행했을 때 읽은 블록이 많다는 것은 레코드를 찾는 과정이 불합리하다는 것을 의미한다.</li> <li>SQL 튜닝을 간단하게 정의하면 읽는 블록 수를 줄여주는 것이다.</li></ul> <h3 id="_2-3-캐시-io-대-물리-io"><a href="#_2-3-캐시-io-대-물리-io" class="header-anchor">#</a> 2.3 캐시 IO 대 물리 IO</h3> <ul><li>데이터베이스 구조에서 성능에 가장 영향을 주는 부분은 파일시스템에서 발생하는 물리IO다.</li> <li>물리 IO가 주로 발생하는 쿼리인데 캐시로 인해 빠르게 조회되어 대상에서 제외될 수도 있다.
<ul><li>읽은 블록 수가 많다면 줄일 수 있는 방안을 강구하는 것이 먼저다.</li></ul></li></ul> <h2 id="_3-성능-개선-대상-식별"><a href="#_3-성능-개선-대상-식별" class="header-anchor">#</a> 3. 성능 개선 대상 식별</h2> <h3 id="_3-1-sql-수행-통계"><a href="#_3-1-sql-수행-통계" class="header-anchor">#</a> 3.1 SQL 수행 통계</h3> <h3 id="_3-2-실행-중인-세션-상태"><a href="#_3-2-실행-중인-세션-상태" class="header-anchor">#</a> 3.2 실행 중인 세션 상태</h3> <h3 id="_3-3-수행-중인-sql의-수행-상태-확인"><a href="#_3-3-수행-중인-sql의-수행-상태-확인" class="header-anchor">#</a> 3.3 수행 중인 SQL의 수행 상태 확인</h3> <h3 id="_3-4-락-대기"><a href="#_3-4-락-대기" class="header-anchor">#</a> 3.4 락 대기</h3> <h3 id="_3-5-awr-보고서"><a href="#_3-5-awr-보고서" class="header-anchor">#</a> 3.5 AWR 보고서</h3> <h3 id="_3-6-statspack"><a href="#_3-6-statspack" class="header-anchor">#</a> 3.6 StatsPack</h3> <h2 id="_4-sql-실행계획"><a href="#_4-sql-실행계획" class="header-anchor">#</a> 4. SQL 실행계획</h2> <h3 id="_4-1-sql-실행계확과-수행-결과"><a href="#_4-1-sql-실행계확과-수행-결과" class="header-anchor">#</a> 4.1 SQL 실행계확과 수행 결과</h3> <h4 id="_4-1-1-sql-실행계획-보기"><a href="#_4-1-1-sql-실행계획-보기" class="header-anchor">#</a> 4.1.1 SQL 실행계획 보기</h4> <h4 id="_4-1-2-sql-수행-결과-확인"><a href="#_4-1-2-sql-수행-결과-확인" class="header-anchor">#</a> 4.1.2 SQL 수행 결과 확인</h4> <h3 id="_4-2-실행계획의-이해"><a href="#_4-2-실행계획의-이해" class="header-anchor">#</a> 4.2 실행계획의 이해</h3> <ul><li>실행계획이란 옵티마이저가 특정 SQL을 실행하기 위해 수행할 일련의 동작을 트리형식으로 표현한 계획이다.</li></ul> <h4 id="_4-2-1-조인"><a href="#_4-2-1-조인" class="header-anchor">#</a> 4.2.1 조인</h4> <ul><li>기본 조인 방식으로는 내포 조인, 해시 조인, 병합 조인, 스타 조인이라는 방식이 있다.</li> <li><strong>내포 조인(Neated loops join)</strong> <ul><li>선행 테이블과 후행 테이블을 오가며 반복적으로 탐색해서 원하는 레코드를 찾는다.</li> <li>선행 테이블에서 탐색된 레코드 건수만큼 후행 테이블의 랜덤 엑세스 탐색이 일어난다.</li> <li>즉, 선행 테이블의 조회 건수가 조인의 전체 작업량을 좌우한다.</li> <li>선행 테이블과 연결고리가 되는 후행 테이블의 조인 항목은 꼭 인덱스가 있어야 한다.</li> <li>연골고리에 인덱스가 없는데 내포 조인이 사용되면 후행 테이블에 전체 범위 탐색(Full Scan)이 발생한다.</li></ul></li> <li><strong>병합 조인(Merge join)</strong> <ul><li>조인되는 두 테이블의 연결고리가 되는 항목에 대한 인덱스가 없거나 대량 데이터를 처리하는 경우 내포 조인에서 발생하는 후행 테이블의 랜덤 엑세스를 제거하기 위해 사용하는 조인 방식이다.</li> <li>조인되는 두 테이블은 조인에 앞서 대상 데이터를 줄이기 위해 각 테이블에 대한 WHERE 조건으로 레코드를 먼저 모두 조회한 후에 연결고리가 되는 항목을 기준으로 정렬한다.</li> <li>양쪽에 정렬된 레코드를 순차적으로 비교해 가면서 연결고리가 일치하는 레코드를 찾는다.</li> <li>선후행 테이블 어느 것이 되든 상관없다.</li> <li>정렬된 데이터를 조인하는 작업은 효과적이지만 정렬을 해야하는 부담이 있다.</li></ul></li> <li><strong>해시 조인(Hash join)</strong> <ul><li>선행 테이블에서 조인에 앞어 전체 범위 탐색으로 조인 대상 레코드를 모두 조회해서 연결고리인 항목에 대해 해시 맵을 만든다.</li> <li>그리고 후행 테이블은 내부 탐색 조건에 일치하는 레코드를 찾았을 때마다 해시 연산을 통해 해시 맵에 일치하는 레코드가 있는지 비교해서 조인을 수행한다.</li> <li>선행 테이블은 한 번에 전체 범위 탐색으로 데이터를 추출하고 후행 테이블은 순차적으로 부분 범위 탐색하므로 부분 범위 처리가 이뤄진다.</li> <li></li></ul></li></ul> <h4 id="_4-2-sql-실행계획의-동작"><a href="#_4-2-sql-실행계획의-동작" class="header-anchor">#</a> 4..2 SQL 실행계획의 동작</h4> <h3 id="_4-3-인덱스"><a href="#_4-3-인덱스" class="header-anchor">#</a> 4.3 인덱스</h3> <h4 id="_4-3-1-인덱스-구조"><a href="#_4-3-1-인덱스-구조" class="header-anchor">#</a> 4.3.1 인덱스 구조</h4> <ul><li>인덱스는 루트, 브랜치, 리프 블록으로 구성된다.</li></ul> <h4 id="_4-3-2-인덱스-종류"><a href="#_4-3-2-인덱스-종류" class="header-anchor">#</a> 4.3.2 인덱스 종류</h4> <h4 id="_4-3-3-인덱스-사용-원칙"><a href="#_4-3-3-인덱스-사용-원칙" class="header-anchor">#</a> 4.3.3 인덱스 사용 원칙</h4> <ul><li><strong>인덱스 생성 원칙</strong> <ul><li>1순위는 테이블의 기본 키다. 기본 키는 가장 빈도가 높은 테이블 엑세스 경로다.</li> <li>2순위는 테이블 간 연결고리로 사용되는 조인 항목 그룹이다. 온라인 SQL은 대부분 내포 조인을 사용하는데 후행 테이블의 연골고리에 인덱스가 없으면 성능에 치명적이다.</li> <li>3순위는 테이블 액세스 경로 상에 빈번하게 관찰되는 항목의 그룹이다. 항목 그룹은 해당 테이블을 조회하는 모든 SQL의 조회 조건에 사용된 항목들의 모임을 나열해서 그룹핑했을 때 가장 빈번하게 나타나느 항목 모임이다.</li> <li>인덱스를 만들 때는 선행 항목이 중요하다. 조회 조건에 선행 항목이 없으면 인덱스를 사용하지 못한다.</li> <li>BETWWEN, &lt; &gt; 등 범위를 지정하는 조건이 주로 주어지는 항목은 결합 인덱스에서 일치(=) 조건 항목 이후에 위치하도록 구성해야 인덱스 탐색 범위를 줄일 수 있다.</li></ul></li> <li>조회 조건에 쓰인 항목에 인덱스가 있는데도 아래와 같은 경우는 인덱스를 사용하지 못한다.
<ul><li>항목 변형 (<code>SUBSTR</code>, <code>VALUE * 10</code>)</li> <li>NULL 사용 (<code>VALUE IS NULL</code>)</li> <li>부정 표현 (<code>VALUE ≠ null</code>)</li> <li>앞 % 사용 (<code>VALUE LIKE = ‘%ABC’</code>)</li> <li>내부 형변환 (<code>NUMBER_VALUE = ‘1000’</code>)</li></ul></li></ul> <h4 id="_4-3-4-인덱스-탐색-방식"><a href="#_4-3-4-인덱스-탐색-방식" class="header-anchor">#</a> 4.3.4 인덱스 탐색 방식</h4> <ul><li><strong>인덱스 유일 탐색(Index Unique Scan)</strong> <ul><li>인덱스를 구성하는 모든 항목이 WHERE 절에 일치(=) 조건으로 들어왔을 때 레코드 한건을 찾아가는 탐색으로 가장 빠르다.</li></ul></li> <li><strong>인덱스 범위 탐색(Index Range Scan)</strong> <ul><li>인덱스의 일정한 범위를 읽어내는 인덱스 범위 탐색이다.</li> <li>한 개의 항목으로 구성된 일반 단일 인덱스가 있을 때 해당 항목이 WHERE 절에 일치 조건으로 있더라도 인덱스 탐색 방식은 범위 탐색을 수행한다. (유니크 인덱스가 아니기 때문에 동일한 레코드가 있을 수 있다)</li></ul></li> <li><strong>인덱스 전체 탐색(Index Full Scan)</strong> <ul><li>테이블 전체 탐색과 마찬가지로 인덱스를 순차적으로 처음부터 끝까지 읽어들이는 탐색 방식이다.</li></ul></li> <li><strong>인덱스 고속 전체 탐색(Index Fast Full Scan)</strong> <ul><li>고속 전체 탐색은 멀티 블록 IO로 순서에 관계없이 인덱스 전체를 탐색한다. 병철 처리를 할 수 있다는 점도 차이점이다.</li></ul></li> <li><strong>인덱스 스킵 탐색(Index Skip Scan)</strong> <ul><li>일반적으로 결합 인덱스의 선행 항목이 WHERE 절에 없으면 해당 인덱스를 사용하지 않는다.</li> <li>그러나 선행 항목의 선택도 값이 커서 유일한 값의 종류가 소수일 때는 인덱스를 사용해 탐색하는 것이 테이블 전체 탐색보다 효율적인 경우가 있다.</li></ul></li></ul> <h4 id="_4-3-5-인덱스-수와-성능"><a href="#_4-3-5-인덱스-수와-성능" class="header-anchor">#</a> 4.3.5 인덱스 수와 성능</h4> <ul><li>인덱스 수가 증가하면 INSERT나 UPDATE 처럼 데이터를 변경하는 DML에는 성능 저하가 발생한다.</li> <li>데이터 입력이 거의 없는 테이블은 인덱스를 추가하는 데 부담이 없으나 입력이 빈번한 거래 로그나 업무 처리용 테이블은 제약받을 수 밖에 없다.</li></ul> <h3 id="_4-4-테이블"><a href="#_4-4-테이블" class="header-anchor">#</a> 4.4 테이블</h3> <ul><li>테이블에서 데이터를 읽는 방식에는 두 가지가 있다.
<ul><li>인덱스 탐색을 통해 대상 레코드를 바로 찾아가서 읽는 방법</li> <li>전체 테이블을 읽어서 대상 레코드를 필터링해서 찾는 방법 (Table Full Scan)</li></ul></li> <li></li></ul> <h4 id="_4-4-1-direct-path와-conventional-path"><a href="#_4-4-1-direct-path와-conventional-path" class="header-anchor">#</a> 4.4.1 Direct-Path와 Conventional-Path</h4> <h4 id="_4-4-2-파티션-테이블"><a href="#_4-4-2-파티션-테이블" class="header-anchor">#</a> 4.4.2 파티션 테이블</h4> <ul><li>대용량 데이터베이스의 경우 한 테이블에 존재하는 레코드가 수십억 건을 저장하기도 한다.</li> <li>데이터가 분산돼 있어 조회 시 데이터 탐색 범위가 넓어져 성능 저하가 발생한다.</li> <li>이러한 문제를 해결하기 위해 데이터베이스는 관리와 조회 시에 중요한 역활을 담당하는 특정 컴럼을 기준으로 여러 개의 테이블로 나눠서 레코드를 저장, 관리하는 파티션이라는 기능이 있다.</li> <li>논리적으로는 하나의 테이블이지만 파티션 키 값에 따라 물리적으로 수 개에서 수천 개에 이르는 테이블을 나눠서 저장하게 된다.</li></ul></div></div></div></div> <div data-v-52bca676></div></div></div></div> <footer prime="" class="v-footer mt-2 v-sheet theme--light v-footer--padless" style="background:#F3F5F7;"><div class="col col-12"><div class="text-center v-card v-card--flat v-sheet theme--light rounded-0" style="background:#F3F5F7;"><div class="v-card__text"><p>Copyright © 2021 All Right <em>끄적끄적 개발일지</em></p> <p>
          px201226@gmail.com .
          <a href="https://github.com/px201226" target="_blank">GitHub</a>
          .
          <a href="http://px201226.github.io/blog" target="_blank">Blog</a>
          .
        </p></div></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.70752fd1.js" defer></script><script src="/assets/js/17.4dcf5890.js" defer></script><script src="/assets/js/42.b0e56f29.js" defer></script>
  </body>
</html>
