<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>고성능을 위한 MySQL Primary Key 설계 전략 | 끄적끄적 개발일지</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://www.googletagmanager.com/gtag/js?id=G-SE0BLFFFMG"></script>
    <meta name="description" content="Awesome description">
    
    <link rel="preload" href="/assets/css/0.styles.4bffb705.css" as="style"><link rel="preload" href="/assets/js/app.70752fd1.js" as="script"><link rel="preload" href="/assets/js/17.4dcf5890.js" as="script"><link rel="preload" href="/assets/js/8.8044f9c2.js" as="script"><link rel="prefetch" href="/assets/js/10.1fe66b22.js"><link rel="prefetch" href="/assets/js/11.3e8e6dd5.js"><link rel="prefetch" href="/assets/js/12.96743d99.js"><link rel="prefetch" href="/assets/js/13.5cab9bdd.js"><link rel="prefetch" href="/assets/js/14.e412fb10.js"><link rel="prefetch" href="/assets/js/15.1da5e3dc.js"><link rel="prefetch" href="/assets/js/16.8ebbd2f8.js"><link rel="prefetch" href="/assets/js/18.5bfa6a85.js"><link rel="prefetch" href="/assets/js/19.12bd999a.js"><link rel="prefetch" href="/assets/js/2.0c177ed1.js"><link rel="prefetch" href="/assets/js/20.87648ee0.js"><link rel="prefetch" href="/assets/js/21.7fbb071c.js"><link rel="prefetch" href="/assets/js/22.3f3676f6.js"><link rel="prefetch" href="/assets/js/23.114b4211.js"><link rel="prefetch" href="/assets/js/24.7077956a.js"><link rel="prefetch" href="/assets/js/25.42ad01f0.js"><link rel="prefetch" href="/assets/js/26.c356a4d4.js"><link rel="prefetch" href="/assets/js/27.52a125bd.js"><link rel="prefetch" href="/assets/js/28.692ecc68.js"><link rel="prefetch" href="/assets/js/29.d205c4cb.js"><link rel="prefetch" href="/assets/js/3.6ee8ed88.js"><link rel="prefetch" href="/assets/js/30.c221f26d.js"><link rel="prefetch" href="/assets/js/31.65e9c8ce.js"><link rel="prefetch" href="/assets/js/32.7ddfb0f5.js"><link rel="prefetch" href="/assets/js/33.7f74862d.js"><link rel="prefetch" href="/assets/js/34.21b19958.js"><link rel="prefetch" href="/assets/js/35.428cdea5.js"><link rel="prefetch" href="/assets/js/36.ef46a37e.js"><link rel="prefetch" href="/assets/js/37.290a8b87.js"><link rel="prefetch" href="/assets/js/38.61002123.js"><link rel="prefetch" href="/assets/js/39.fbbd1cce.js"><link rel="prefetch" href="/assets/js/4.39bb3471.js"><link rel="prefetch" href="/assets/js/40.ee500a11.js"><link rel="prefetch" href="/assets/js/41.ce50acc7.js"><link rel="prefetch" href="/assets/js/42.b0e56f29.js"><link rel="prefetch" href="/assets/js/43.c4683cd4.js"><link rel="prefetch" href="/assets/js/44.4fd9959c.js"><link rel="prefetch" href="/assets/js/45.10201422.js"><link rel="prefetch" href="/assets/js/5.6b61195e.js"><link rel="prefetch" href="/assets/js/6.d4a6ae6d.js"><link rel="prefetch" href="/assets/js/7.8da69c67.js"><link rel="prefetch" href="/assets/js/9.8e23472b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4bffb705.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light" style="background:#F3F5F7;"><div class="v-application--wrap"><div class="container pa-0" style="max-width:900px;"><link href="https://fonts.googleapis.com/css?family=Jura" rel="stylesheet"> <div class="text-center py-8 v-toolbar__title v-app-bar-title" style="font-family:'Jura';"><div class="v-app-bar-title__content"><h1 class="primary--text">끄적끄적 개발일지</h1></div><div class="v-app-bar-title__placeholder" style="visibility:visible;"><h1 class="primary--text">끄적끄적 개발일지</h1></div></div> <div role="list" class="v-list pa-0 v-sheet theme--light v-list--flat transparent"><div role="listbox" class="v-item-group theme--light v-list-item-group indigo--text"><div class="row mb-0 text-center no-gutters justify-center"><div class="col-lg-2 col"><a href="/" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2  v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Home</div></a></div> <div class="col-lg-2 col"><a href="/category" aria-current="page" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-item--active v-list-item--active v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Category</div></a></div> <div class="col-lg-2 col"><a href="/profiles" tabindex="0" block="" text="" role="option" aria-selected="false" class="py-2 v-list-item v-list-item--link theme--light primary--text"><div class="v-list-item__title">Profiles</div></a></div></div></div></div> <hr role="separator" aria-orientation="horizontal" class="mb-3 v-divider theme--light"> <div><div data-v-52bca676><div class="px-0 col col-12" data-v-52bca676 data-v-52bca676><div class="pa-5 px-md-7 v-card v-sheet theme--light elevation-1" data-v-52bca676><div data-v-52bca676><a href="/category/database/mysql-primary-key-design.html" aria-current="page" class="text-h4 font-weight-bold router-link-exact-active router-link-active" data-v-52bca676><div data-v-52bca676><!----></div>
          고성능을 위한 MySQL Primary Key 설계 전략
        </a> <br data-v-52bca676> <span class="text-caption grey--text text--darken-1 " data-v-52bca676>2023-08-06 &gt; 데이터베이스
        </span></div> <hr role="separator" aria-orientation="horizontal" class="mt-4 mb-4 v-divider theme--light" data-v-52bca676> <div class="theme-container" data-v-52bca676><div class="toc" data-v-52bca676><ul><li><a href="/category/database/mysql-primary-key-design.html#primary-key-설계의-중요성">Primary Key 설계의 중요성</a></li><li><a href="/category/database/mysql-primary-key-design.html#클러스터형-인덱스">클러스터형 인덱스</a></li><li><a href="/category/database/mysql-primary-key-design.html#primary-key-유형">Primary Key 유형</a><ul><li><a href="/category/database/mysql-primary-key-design.html#자동-증가-auto-increment-primary-key">자동 증가 (Auto Increment) Primary Key</a></li><li><a href="/category/database/mysql-primary-key-design.html#uid">UID</a></li><li><a href="/category/database/mysql-primary-key-design.html#composite-key">Composite key</a></li></ul></li><li><a href="/category/database/mysql-primary-key-design.html#대리키와-복합키-비교">대리키와 복합키 비교</a><ul><li><a href="/category/database/mysql-primary-key-design.html#부모테이블의-기본키를-자식-테이블의-기본키로-쓰지-않고-외래키로-사용하는-경우-비식별관계">부모테이블의 기본키를 자식 테이블의 기본키로 쓰지 않고, 외래키로 사용하는 경우 (비식별관계)</a></li><li><a href="/category/database/mysql-primary-key-design.html#부모테이블의-기본키를-자식-테이블-기본키에-포함하는-경우-식별관계">부모테이블의 기본키를 자식 테이블 기본키에 포함하는 경우 (식별관계)</a></li></ul></li><li><a href="/category/database/mysql-primary-key-design.html#정리">정리</a></li></ul></div> <div class="theme-default-content custom post markdown-body content__default" data-v-52bca676><h2 id="primary-key-설계의-중요성"><a href="#primary-key-설계의-중요성" class="header-anchor">#</a> Primary Key 설계의 중요성</h2> <p>InnoDB 기준으로 MySQL은 Primary Key를 기준으로 데이터를 클러스터링한다.
클러스터링이라는 용어는 인접한 키 값이 있는 레코드가 물리적으로도 인접하게 저장된다는 것을 말한다.
즉, 논리적인 PK 값에 의해 레코드의 물리적인 위치가 결정된다.
PK값이 변경된다면 해당 레코드의 물리적인 위치도 변경된다는 얘기다.</p> <p>모든 데이터베이스가 마찬가지겠지만 MySQL의 PK 설계는 다른 데이터베이스보다 더 중요하다고 볼 수 있다.
왜냐하면, 일부 데이터베이스에서는 클러스터링할 인덱스를 선택할 수 있지만 MySQL은 기본키로 고정되어 변경할 수 없다. (MySQL 8.x 기준)<br>
또한, MySQL은 Secondary Index의 Leaf Node에 오라클과 같이 물리적 위치에 대한 참조(ROWID)가 아닌 PK 값을 저장하고, PK 인덱스를 통해 실제 디스크 블록에 접근한다. 따라서, MySQL에서 PK 는 단순히 데이터를 식별하기 위한 식별자 역할뿐만 아니라 내부 구현에도 관여하기 때문에 그 중요성은 매우 크다고 볼 수 있다.</p> <h2 id="클러스터형-인덱스"><a href="#클러스터형-인덱스" class="header-anchor">#</a> 클러스터형 인덱스</h2> <p>고성능을 위한 Primary Key 를 설계하기 위해서는 Primary Key 의 저장 구조인 클러스터형 인덱스에 대한 이해가 필요하다.
아래의 그림은 Secondary Index <strong>(Non-Clusted Index)</strong> 와 Primary Key Index <strong>(Clusted Index)</strong> 의 저장 구조를 나타낸다.</p> <p>Secondary Index <strong>(Non-Clusted Index)</strong> 그림의 리프 노드를 보면 Index Key 값에 해당 하는 Primary Key 값을 저장하고 있는 것을 볼 수 있다.
Index Key 값은 정렬되어 있지만 Index Key 값에 맵핑되는 Primary Key들 사이에는 아무런 순서관계가 없다.</p> <p>Primary Key Index <strong>(Clusted Index)</strong> 그림의 리프 노드는 Index Key 값 기준으로 정렬되어 있고,
참조가 아닌 실제 레코드를 저장하는 페이지가 리프노드에 위치해 있다. 페이지 내에서도 Primary Index Key 값 기준으로 레코드가 물리적으로 정렬되어 있다.</p> <p><img src="/assets/img/index-tree.a67dad59.png" alt="img.png"></p> <p>Clusted Index는 구조적인 이유로 순차적인 Key 값을 넣을 때, 오버헤드가 가정 적고 가장 빠르다. 단순히 Index 트리 오른쪽 맨끝에 새로운 레코드를 삽입해주기만 하면 된다.<br>
반면에 비순차적인 Key 값이 들어오게 되면 상황이 복잡해진다. Key 값이 기존 데이터 중간에 삽입될 수 있으므로 트리 구조를 변경사항에 맞게 갱신해야 한다.<br>
또한, 리프 노드의 페이지 안에 있는 데이터의 순서도 조정이 필요하다. 기존 데이터 사이에 새 레코드의 적절한 위치를 찾고 공간을 확보해야 한다. 이로 인해 많은 데이터의 이동이 필요할 수 있고 페이지 분할로 단편화 문제가 발생할 수 있다.</p> <p>따라서 INSERT 속도가 중요한 테이블이라면 순차적인 값을 Primary Key로 선정하는 것이 유리하다.</p> <h2 id="primary-key-유형"><a href="#primary-key-유형" class="header-anchor">#</a> Primary Key 유형</h2> <h3 id="자동-증가-auto-increment-primary-key"><a href="#자동-증가-auto-increment-primary-key" class="header-anchor">#</a> 자동 증가 (Auto Increment) Primary Key</h3> <p><strong>장점</strong></p> <ul><li>Primary Key 채번을 DB에 위임하므로 관리 포인트가 줄어든다.</li></ul> <p><strong>단점</strong></p> <ul><li>테이블의 대량 INSERT 작업 시, Auto Increament 에서 병목현상이 발생할 수 있다.</li></ul> <h3 id="uid"><a href="#uid" class="header-anchor">#</a> UID</h3> <p>클러스터형 인덱스 구조를 이해하면, UUID와 같은 랜덤 값이 Primary Key로 선정될 경우, 레코드 클러스터링에 필요한 오버헤드만 발생하고 크게 이점이 없음을 알 수 있다.
그러나 랜덤 UID가 아닌 순차적인 UID를 생성하면 Auto Increment의 병목현상과 클러스터링 오버헤드를 모두 피할 수 있다.
순차적인 UID는 (현재시각 + 일련번호) 또는 (epoch time + 일련번호)와 같은 조합으로 순서를 유지하는 UID를 만들 수 있다.</p> <p><strong>장점 (Sequential UID)</strong></p> <ul><li>대량 INSERT 작업을 매우 빠르게 처리할 수 있다.</li></ul> <p><strong>단점 (Sequential UID)</strong></p> <ul><li>클라이언트에서 순차적인 UID를 만들기 위해 관리가 필요하다.</li></ul> <h3 id="composite-key"><a href="#composite-key" class="header-anchor">#</a> Composite key</h3> <p>논리 모델링과 물리 모델링의 격차가 적고, 사람이 이해하기 쉽다. 중복키 값이 들어올 수 있으므로 동시성 관리가 필요하다.</p> <p><strong>장점</strong></p> <ul><li>공간적 지역성(Spatial Locality) 를 활용할 수 있다.</li></ul> <p><strong>단점</strong></p> <ul><li>클라이언트에서 채번에 대한 동시성 관리가 필요하다.</li></ul> <h2 id="대리키와-복합키-비교"><a href="#대리키와-복합키-비교" class="header-anchor">#</a> 대리키와 복합키 비교</h2> <p>Auto increament 와 UID 를 이용한 기본키 유형은 대리키로 일반화할 수 있다. Primary Key를 대리키로 구성한 방식과 복합키로 구성한 방식의 차이점을 비교해본다.</p> <h3 id="부모테이블의-기본키를-자식-테이블의-기본키로-쓰지-않고-외래키로-사용하는-경우-비식별관계"><a href="#부모테이블의-기본키를-자식-테이블의-기본키로-쓰지-않고-외래키로-사용하는-경우-비식별관계" class="header-anchor">#</a> 부모테이블의 기본키를 자식 테이블의 기본키로 쓰지 않고, 외래키로 사용하는 경우 (비식별관계)</h3> <p><img src="/assets/img/mysql_img_1.1f5e3d12.png" alt="mysql_img_1.png"></p> <p>Post, Comment 테이블 둘 다 Auto Increament 기본키를 사용하고, Comment 테이블에 post_id FK 를 두어 Post와 연관관계를 맺는 방식이다.
Post 테이블이 Driving Table이고 Comment 테이블이 Driven Table 인 경우 두 테이블을 조인하게 되면 아래 그림와 같은 방식으로 데이터를 탐색하게 된다.</p> <p><img src="/assets/img/mysql_img_2.e16c9fb8.png" alt="mysql_img_2.png"></p> <p>조인 연산을 수행하기 위해, Post 테이블의 기본키와 연결된 Comment 테이블의 Post_id 값으로 조인이 이루어진다. Comment 테이블의 post_id에는 이미 인덱스가 생성되어 있기 때문에, Index Range Scan을 사용하여 Post 테이블과 Comment 테이블을 맵핑할 수 있다.</p> <p>그 다음 단계에서는 SELECT 결과를 가져오기 위해 Comment 테이블의 레코드를 검색한다. 이 과정에서 Comment 레코드의 탐색을 위해 Random I/O가 발생하게 된다. Comment 테이블의 POST_ID_IDX 인덱스는 POST_ID별로 정렬되어 있어 같은 POST_ID를 가지더라도 COMMENT_ID는 멀리 떨어져있는 값을 가질 수 있다.</p> <p>예를 들어 위의 그림에서, Post 테이블에서 id=3인 레코드를 조회하면, Comment 테이블의 post_id와의 조인 결과로 Comment id (100, 200)이 반환된다. 페이지 당 50개 레코드가 저장된다고 가정하면 2개의 Comment 레코드를 가져오기 위해 총 2개의 페이지 읽기 작업이 필요하게 된다.</p> <h3 id="부모테이블의-기본키를-자식-테이블-기본키에-포함하는-경우-식별관계"><a href="#부모테이블의-기본키를-자식-테이블-기본키에-포함하는-경우-식별관계" class="header-anchor">#</a> 부모테이블의 기본키를 자식 테이블 기본키에 포함하는 경우 (식별관계)</h3> <p><img src="/assets/img/mysql_img_3.dc6ee2a6.png" alt="mysql_img_3.png"></p> <p>두번째 예에서는 Comment가 POST의 ID를 자신의 기본키에 포함시킨 Composite Key로 PK를 구성한 예이다. 마찬가지로 아래는 Post 테이블이 Driving Table이고 Comment 테이블이 Driven Table 인 경우 두 테이블을 조인할 때, 데이터 탐색 방식이다.</p> <p><img src="/assets/img/mysql_img_4.fdb57c19.png" alt="mysql_img_4.png"></p> <p>첫번째 방식과 유사하게, 조인이 발생했을 때 Comment 레코드를 읽어오기 위해 페이지 3을 두 번 참조하게 되지만, 이 경우 페이지 3은 이미 캐싱되어 있으므로 두 번째 참조는 추가적인 I/O를 발생시키지 않는다.</p> <p>두 방식에서 논리적 페이지 I/O는 2로 동일하지만, 물리적 페이지 I/O(캐시 적용 시)는 각각 2와 1로 다르다. 조인되는 데이터가 많아질수록 두 방식 사이의 물리적 I/O 차이는 더욱 커지게 된다.</p> <p>이러한 결과는 두 번째 케이스에서 식별관계를 사용해 기본키를 복합키로 구성했기 때문에 발생한다. POST_ID를 기준으로 조인을 수행할 때, 공간적 지역성(Spatial Locality)의 원리가 적용되었다고 볼 수 있다. 특정 Post에 속한 Comment 집합은 같은 논리적 영역에 속하는 인스턴스라고 볼 수 있다. POST_ID와 COMMENT_ID로 클러스터링하면, 물리적으로도 POST_ID에 속한 COMMENT 집합이 유사한 영역에 위치하게 되므로 캐싱 확률이 높아지게 된다.</p> <h2 id="정리"><a href="#정리" class="header-anchor">#</a> 정리</h2> <p>&quot;고성능을 위한 MySQL Primary Key 설계 전략&quot;이라는 제목의 이 포스팅이 의미하는 것은 특정 케이스에 대해 어떤 Primary Key를 사용해야 한다는 수학 공식처럼 명확한 가이드라인을 제시하는 것이 아니다.</p> <p>앞서 언급한 조인 예제에서의 공간적 지역성(Spatial Locality)을 활용한 복합키 방식이 무조건적으로 우월하다는 것도 아니다. 예를 들어, 일반적인 게시판 시스템이 아니라 게시물과 댓글이 별도로 표시되고, 간간이 게시물과 댓글 사이에 조인이 발생하는 애플리케이션의 경우, 대리키 방식이 더 적절할 수 있다.</p> <p>중요한것은 MySQL의 클러스터 인덱스와 세컨더리 인덱스 구조를 이해하고, 그 이해를 바탕으로 시스템 요구 사항에 가장 적합한  Primary Key를 선택할 수 있어야 한다.</p></div></div></div></div> <div data-v-52bca676></div></div></div></div> <footer prime="" class="v-footer mt-2 v-sheet theme--light v-footer--padless" style="background:#F3F5F7;"><div class="col col-12"><div class="text-center v-card v-card--flat v-sheet theme--light rounded-0" style="background:#F3F5F7;"><div class="v-card__text"><p>Copyright © 2021 All Right <em>끄적끄적 개발일지</em></p> <p>
          px201226@gmail.com .
          <a href="https://github.com/px201226" target="_blank">GitHub</a>
          .
          <a href="http://px201226.github.io/blog" target="_blank">Blog</a>
          .
        </p></div></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.70752fd1.js" defer></script><script src="/assets/js/17.4dcf5890.js" defer></script><script src="/assets/js/8.8044f9c2.js" defer></script>
  </body>
</html>
