(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{415:function(v,_,a){"use strict";a.r(_);var t=a(21),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"애매모호한-트랜잭션의-개념"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#애매모호한-트랜잭션의-개념"}},[v._v("#")]),v._v(" 애매모호한 트랜잭션의 개념")]),v._v(" "),a("h3",{attrs:{id:"acid의-의미"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#acid의-의미"}},[v._v("#")]),v._v(" ACID의 의미")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션이 제공하는 안정성 보장은 "),a("strong",[v._v("원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)")]),v._v(" 을 의미하는 "),a("code",[v._v("ACID")]),v._v(" 로 잘 알려져 있다.")]),v._v(" "),a("li",[v._v("그러나 현실에서는 데이터베이스마다 ACID 구현이 재각각이다. 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다.")])]),v._v(" "),a("h4",{attrs:{id:"원자성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#원자성"}},[v._v("#")]),v._v(" 원자성")]),v._v(" "),a("ul",[a("li",[v._v("원장성은 클라이언트가 쓰기 작업 몇 개를 실행하려고 하는데 그 중 일부만 처리된 후 결함이 생기면 무슨 일이 생기는지 설명한다.")]),v._v(" "),a("li",[v._v("여러 쓰기 작업이 하나의 원자적 단위인 트랜잭션으로 묶여 있는데 결함 때문에 커밋될 수 없다면 어보트되고 지금까지 실행한 쓰기를 무시하거나 취소해야하 한다.")]),v._v(" "),a("li",[v._v("원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려고 할 때 무슨 일이 생기는지 설명하지 않는다.")]),v._v(" "),a("li",[v._v("오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 "),a("code",[v._v("어보트 능력(abortability)")]),v._v(" 능력이 원자성의 결정적 특징이다.")])]),v._v(" "),a("h4",{attrs:{id:"일관성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#일관성"}},[v._v("#")]),v._v(" 일관성")]),v._v(" "),a("ul",[a("li",[v._v("일관성이란 단어는 굉장히 여러 의미로 쓰인다.\n"),a("ul",[a("li",[v._v("복제 일관성과 비동기식 복제되는 시스템에서 발생하는 최종적 일관성 문제")]),v._v(" "),a("li",[v._v("일관성 해싱은 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝 방법")]),v._v(" "),a("li",[v._v("CAP 정리에서 일관성은 선형성을 의미한다.")]),v._v(" "),a("li",[v._v("ACID 맥락에서 일관성은 데이터베이스가 “좋은 상태”에 있어야 한다는 애플리케이션에 특화된 개념을 가르킨다.")])])]),v._v(" "),a("li",[v._v("일관성의의 아이디어는 데이터에 관한 어떤 불변식이 항상 진실이어야 한다는 것이다.")]),v._v(" "),a("li",[v._v("트랜잭션이 이런 불변식이 유요한 데이터베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.")]),v._v(" "),a("li",[v._v("일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다.")]),v._v(" "),a("li",[v._v("데이터베이스 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다\n"),a("ul",[a("li",[v._v("외래 키, 기본키 제약 조건같은 특정 종류의 불변식을 지원하지만 일반적으로 애플리케이션에서 데이터가 유효한지 아닌지를 정의하고 데이터베이스는 데이터를 저장할 뿐이다.")])])])]),v._v(" "),a("h4",{attrs:{id:"격리성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#격리성"}},[v._v("#")]),v._v(" 격리성")]),v._v(" "),a("ul",[a("li",[v._v("클라리언트들이 동일한 데이터베이스 레코드에 접근하면 동시성 문제가 발생한다.")]),v._v(" "),a("li",[v._v("여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.")])]),v._v(" "),a("h4",{attrs:{id:"지속성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#지속성"}},[v._v("#")]),v._v(" 지속성")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.")])]),v._v(" "),a("h3",{attrs:{id:"단일-객체-연산과-다중-객체-연산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#단일-객체-연산과-다중-객체-연산"}},[v._v("#")]),v._v(" 단일 객체 연산과 다중 객체 연산")]),v._v(" "),a("ul",[a("li",[v._v("ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 서술한다.")]),v._v(" "),a("li",[v._v("다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션이 속하는지 알아낼 수단이 있어야 한다.")]),v._v(" "),a("li",[v._v("관계형 데이터베이스에서 이것은 전형적으로 클라이언트와 데이터베이스 서버 사이의 TCP 연결을 기반으로 한다.")]),v._v(" "),a("li",[v._v("어떤 특정 연결 내에서 "),a("code",[v._v("BEGIN TRANSACTION")]),v._v(" 문과 "),a("code",[v._v("COMMIT")]),v._v(" 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여긴다.")]),v._v(" "),a("li",[v._v("반명 비관계형 데이터베이스는 한 연산 내에서 여러 키를 갱신하는 다중 객체 연산을 묶는 방법이 없는 경우가 많다.")]),v._v(" "),a("li",[v._v("어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.")])]),v._v(" "),a("h4",{attrs:{id:"단일-객체-쓰기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#단일-객체-쓰기"}},[v._v("#")]),v._v(" 단일 객체 쓰기")]),v._v(" "),a("ul",[a("li",[v._v("저장소 엔진들은 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다.")]),v._v(" "),a("li",[v._v("어떤 데이터베이스는 증가 연산처럼 더 복잡한 원자적 연산을 제공하기도 한다.")]),v._v(" "),a("li",[v._v("이러한 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실을 방지하므로 유용하다.")])]),v._v(" "),a("h4",{attrs:{id:"다중-객체-트랜잭션의-필요성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#다중-객체-트랜잭션의-필요성"}},[v._v("#")]),v._v(" 다중 객체 트랜잭션의 필요성")]),v._v(" "),a("ul",[a("li",[v._v("다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기가 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문에 지원하기가 어렵다.")]),v._v(" "),a("li",[v._v("단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례가 있다. 트랜잭션이 없더라도 이런 애플리케이션ㅇ들은 구현할 수 있다.")]),v._v(" "),a("li",[v._v("하지만 원자성이 없으면 오츄 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.")])]),v._v(" "),a("h4",{attrs:{id:"오류와-어보트-처리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#오류와-어보트-처리"}},[v._v("#")]),v._v(" 오류와 어보트 처리")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 아전하게 재시도할 수 있다는 것이다.")]),v._v(" "),a("li",[v._v("하지만 리더 없는 복제를 사용하는 데이터스토어는 이러한 철학을 따르지 않는다. "),a("code",[v._v("최선을 다하는 원칙")]),v._v("을 기반으로 더 많은 일을 한다.")])]),v._v(" "),a("h2",{attrs:{id:"완화된-격리-수준"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#완화된-격리-수준"}},[v._v("#")]),v._v(" 완화된 격리 수준")]),v._v(" "),a("ul",[a("li",[v._v("두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 병렬 실행 될 수 있다.")]),v._v(" "),a("li",[v._v("동시성 문제(경쟁 조건)는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.")]),v._v(" "),a("li",[a("code",[v._v("트랜잭션 격리")]),v._v("를 제공함으로써 애플리케이션 개발들에게 동시성 문제를 감췄다.")]),v._v(" "),a("li",[v._v("직렬성 격리는 성능 빙용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.")]),v._v(" "),a("li",[v._v("따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는 완화된 격리 수준을 사용하는 시스템들이 흔하다.")]),v._v(" "),a("li",[v._v("이번 절에서는 완화된(비직렬성) 격리 수준 몇 가지를 살펴보고 발생할 수 있는 경쟁 조건과 발생할 수 없는 경쟁 조건을 설명한다.")])]),v._v(" "),a("h3",{attrs:{id:"커밋-후-읽기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#커밋-후-읽기"}},[v._v("#")]),v._v(" 커밋 후 읽기")]),v._v(" "),a("ul",[a("li",[v._v("가장 기본적인 수준의 트랜잭션 격리는 "),a("code",[v._v("커밋 후 읽기(read committed)")]),v._v("다.\n"),a("ul",[a("li",[v._v("데이터베이스 읽을 때 커밋된 데이터만 보게 된다. (더티 읽기가 없음)")]),v._v(" "),a("li",[v._v("데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)")])])])]),v._v(" "),a("h4",{attrs:{id:"더티-읽기-방지"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#더티-읽기-방지"}},[v._v("#")]),v._v(" 더티 읽기 방지")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션이 데이터베이스에 데이터를 썻지만 아직 커밋되거나 어보트되지 않았을 때, 다른 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있는 것을 더티 읽기라고 부른다.\n"),a("ul",[a("li",[v._v("트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다.")]),v._v(" "),a("li",[v._v("커밋되지 않은 데이트를 볼 수 있다.")])])])]),v._v(" "),a("h4",{attrs:{id:"더티-쓰기-방지"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#더티-쓰기-방지"}},[v._v("#")]),v._v(" 더티 쓰기 방지")]),v._v(" "),a("ul",[a("li",[v._v("아직 커밋되지 않은 데이터에 다른 트랜잭션이 쓰기 작업을 하는 것을 "),a("code",[v._v("더티 쓰기(dirty write)")]),v._v("라고 한다.")])]),v._v(" "),a("h4",{attrs:{id:"커밋후-읽기-구현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#커밋후-읽기-구현"}},[v._v("#")]),v._v(" 커밋후 읽기 구현")]),v._v(" "),a("ul",[a("li",[v._v("더티 쓰기의 가장 흔한 방법으로 데이터베이스는 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.\n"),a("ul",[a("li",[v._v("트랜잭션에서 특정 객체(로우나 문서)를 변경하고 싶다면 먼저 해당 객체에 대한 잠금을 획득하고, 트랜잭션이 완려될 때까지 잠금을 보유하고 있어야 한다.")]),v._v(" "),a("li",[v._v("다른 트랜잭션이 쓰기를 원한다면 첫 번째 트랜잭션이 완료되어 잠금을 얻어 진행할 수 있다.")])])]),v._v(" "),a("li",[v._v("더티 읽기는 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해제하게 하는 것 이다.\n"),a("ul",[a("li",[v._v("그러나 읽기 잠금은 트랜잭션들의 응답 시간에 해를 끼치며 운용성이 나쁘다.")]),v._v(" "),a("li",[v._v("쓰여진 모든 객체에 대해 데이터베이스는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억한다.")]),v._v(" "),a("li",[v._v("해당 트랜잭션이 그 객체를 읽으려고 하면 과거의 값을 읽게 된다.")])])])]),v._v(" "),a("h3",{attrs:{id:"스냅숏-격리와-반복-읽기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#스냅숏-격리와-반복-읽기"}},[v._v("#")]),v._v(" 스냅숏 격리와 반복 읽기")]),v._v(" "),a("ul",[a("li",[v._v("커밋된 읽기 격리 수준을 사용하더라도 동시성 버그가 생길 수 있다.\n"),a("ul",[a("li",[v._v("앨리스는 두 계좌에 500달러 씩 있고, 한 계좌에서 다른 계좌로 100달러를 전송하는 트랜잭션을 실행한다.")]),v._v(" "),a("li",[v._v("트랜잭션이 처리되고 있는 순간에 계좌 잔고를 보게 되면 입금되기 전 상태인 500달러, 출금된 후 상태인 400달러를 보게되어 총 900달러만 있는 것처럼 나온다.")]),v._v(" "),a("li",[v._v("앨리스가 봤던 계좌 잔고들은 읽은 시점에 커밋된 상태였다.")]),v._v(" "),a("li",[v._v("이런 현상을 "),a("code",[v._v("비반복 읽기(nonrepeatable read)")]),v._v("나 "),a("code",[v._v("읽기 스큐(read skew")]),v._v(")라고 한다.")]),v._v(" "),a("li",[v._v("스냅")])])]),v._v(" "),a("li",[v._v("스냅숏 격리는 이런 문제의 가장 흔한 해결책이다.\n"),a("ul",[a("li",[v._v("각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다.")]),v._v(" "),a("li",[v._v("즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.")])])])]),v._v(" "),a("h4",{attrs:{id:"스냅숏-격리-구현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#스냅숏-격리-구현"}},[v._v("#")]),v._v(" 스냅숏 격리 구현")]),v._v(" "),a("ul",[a("li",[v._v("스냅숏 격리 구현은 커밋 후 읽기 격리처럼 쓰기 잠금을 사용한다. 그러나 읽을 때는 아무 잠금도 필요하지 않다.")]),v._v(" "),a("li",[v._v("스냅숏 격리의 핵심 원리는 "),a("code",[v._v("읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는")]),v._v(" 것이다.")]),v._v(" "),a("li",[v._v("따라서 데이터베이스는 잠금 경쟁 없이 일관성 있는 스냅숏에 오래 실행되는 읽기 작업을 처리할 수 있다.")]),v._v(" "),a("li",[v._v("여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야 할 수도 있기 때문에 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.")]),v._v(" "),a("li",[v._v("이런 기법을 "),a("code",[v._v("다중 버전 동시성 제어(MVCC)")]),v._v("라고 한다.")]),v._v(" "),a("li",[v._v("데이터베이스가 커밋 후 읽기 격리만 제공할 필요가 있다면 객체마다 커멋된 버전, 커멋되지 않은 버전 두 개씩만 유지하면 충분하다.\n"),a("ul",[a("li",[v._v("커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용하는 것이다.")])])])]),v._v(" "),a("h3",{attrs:{id:"갱신-손실-방지"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#갱신-손실-방지"}},[v._v("#")]),v._v(" 갱신 손실 방지")]),v._v(" "),a("ul",[a("li",[v._v("커밋 후 읽기와 스냅숏 격리 수준은 동시에 실행되는 쓰기 작업이 있을 때 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 보장과 관련된 것 이다.")]),v._v(" "),a("li",[v._v("갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다.")]),v._v(" "),a("li",[v._v("이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있다.")])]),v._v(" "),a("h4",{attrs:{id:"원자적-쓰기-연산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#원자적-쓰기-연산"}},[v._v("#")]),v._v(" 원자적 쓰기 연산")]),v._v(" "),a("ul",[a("li",[v._v("이 연산은 애플리케이션 코드에서 read-modify-write 주기를 구현할 필요를 없애 준다")]),v._v(" "),a("li",[v._v("다음 명령은 대부분의 관계형 데이터베이스에서 동시성 안전(concurrency-safe)하다.")])]),v._v(" "),a("div",{staticClass:"language-jsx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("UPDATE")]),v._v(" conters "),a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("SET")]),v._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("+")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("WHERE")]),v._v(" key "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[v._v("'foo'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br")])]),a("ul",[a("li",[v._v("원자적 연산은 보통 객체를 읽을 때 독접적인(exclusive) 잠금을 획득해서 구현한다. 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못한다.")]),v._v(" "),a("li",[v._v("ORM 프레임워크를 사용하면 데이터베이스가 원자적 연산을 사용하는 대신  read-modify-write 주기를 실행하는 코드를 작성하기 쉽다.")])]),v._v(" "),a("h4",{attrs:{id:"명시적인-잠금"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#명시적인-잠금"}},[v._v("#")]),v._v(" 명시적인 잠금")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스에 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠금하는 것이다.")]),v._v(" "),a("li",[v._v("read-modify-write 주기를 수행할 수 있고 다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 read-modify-write 주기가 완료될 때까지 기다리도록 강제된다.")]),v._v(" "),a("li",[a("code",[v._v("SELEFT FOR UPDATE")]),v._v(" 절은 이 질의에 의해 반환된 모든 로우에 잠금을 획득해야 함을 가르킨다.")])]),v._v(" "),a("h4",{attrs:{id:"갱신-손실-자동-감지"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#갱신-손실-자동-감지"}},[v._v("#")]),v._v(" 갱신 손실 자동 감지")]),v._v(" "),a("ul",[a("li",[v._v("지금까지 설명한 갱신 손실 방지 방법은 연산을 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법이다.")]),v._v(" "),a("li",[v._v("대안으로 이들의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트 시키고 쓰기를 재시도하도록 강제하는 방법이 있다.")]),v._v(" "),a("li",[v._v("Mysql의 반복 읽기는 갱신 손실을 감지하지 않는다.")])]),v._v(" "),a("h4",{attrs:{id:"compare-and-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compare-and-set"}},[v._v("#")]),v._v(" Compare-and-set")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션을 제공하지 않는 데이터베이스 중에는 원자적 compare-and-set 연산을 제공하는 것도 있다.")])]),v._v(" "),a("div",{staticClass:"language-jsx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("UPDATE")]),v._v(" wiki_pages "),a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("SET")]),v._v(" content "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[v._v("'new content'")]),v._v("\n"),a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("WHERE")]),v._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[v._v("1234")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("AND")]),v._v(" content "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[v._v("'old content'")]),v._v("\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br")])]),a("h4",{attrs:{id:"충돌-해소와-복제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#충돌-해소와-복제"}},[v._v("#")]),v._v(" 충돌 해소와 복제")]),v._v(" "),a("ul",[a("li",[v._v("복제가 적용된 데이터베이스에서 갱신 손실을 막는 것은 다른 차원의 문제다.")]),v._v(" "),a("li",[v._v("여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하므로 데이터의 최신 복사본이 하나만 있으리라고 보장할 수 없다.")]),v._v(" "),a("li",[a("strong",[v._v("동시 쓰기 감지")]),v._v(" 처럼 여러 개의 충돌된 버전(sibling)을 생성하는 것을 허용하고 사후에 충돌을 해소하고 병합하는 것이다.")])]),v._v(" "),a("h3",{attrs:{id:"쓰기-스큐-write-skew-와-팬텀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#쓰기-스큐-write-skew-와-팬텀"}},[v._v("#")]),v._v(" 쓰기 스큐(write skew)와 팬텀")]),v._v(" "),a("ul",[a("li",[v._v("쓰기 스큐는 두 트랜잭션이 같은 객체들을 읽어서 그중 "),a("code",[v._v("일부")]),v._v("를 갱신할 때 나타날 수 있다.\n"),a("ul",[a("li",[a("code",[v._v("동일한 객체를 갱신하는 경우")]),v._v(" 더티 쓰기나 갱신 손실 이상 현상을 겪는다.")])])])]),v._v(" "),a("h2",{attrs:{id:"직렬성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#직렬성"}},[v._v("#")]),v._v(" 직렬성")]),v._v(" "),a("ul",[a("li",[v._v("여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.")]),v._v(" "),a("li",[v._v("즉 데이터베이스가 발생할 수 있는 "),a("strong",[v._v("모든")]),v._v(" 경쟁 조건을 막아준다.")]),v._v(" "),a("li",[v._v("오늘날 직렬성을 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용한다.\n"),a("ul",[a("li",[v._v("트랜잭션을 순차적으로 실행하기")]),v._v(" "),a("li",[v._v("2단계 잠금")]),v._v(" "),a("li",[v._v("직렬성 스냅숏 격리 같은 낙관적 동시성 제어")])])])]),v._v(" "),a("h3",{attrs:{id:"실제적인-직렬-실행"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#실제적인-직렬-실행"}},[v._v("#")]),v._v(" 실제적인 직렬 실행")]),v._v(" "),a("ul",[a("li",[v._v("한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 된다.")]),v._v(" "),a("li",[v._v("과거 30년 동안 높은 성능을 위해 다중 스레드 동시성이 필수적인 것으로 여겨졌지만 최근이 돼서야 단일 스레드 루프에서 트랜잭션을 실행하는 게 실현 가능하도고 결론지었다.\n"),a("ul",[a("li",[v._v("램 가격이 저렴해지면서 활성화된 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됐다.")]),v._v(" "),a("li",[v._v("OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 알았다. 반대로 오래 실행되는 분석 질의는 직렬 실행 루프 밖에서 일관된 스냅숏을 사용해 실행할 수 있다.")])])])]),v._v(" "),a("h4",{attrs:{id:"트랜잭션을-스토어드-프로시저-안에-캡슐화하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#트랜잭션을-스토어드-프로시저-안에-캡슐화하기"}},[v._v("#")]),v._v(" 트랜잭션을 스토어드 프로시저 안에 캡슐화하기")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션이 사용자의 입력을 기다려야 한다면 데이터베이스는 대부분 유휴 상태일 것 이다.")]),v._v(" "),a("li",[v._v("이를 효율적으로 처리할 수 없어서 거의 모든 OLTP 애플리케이션은 트랜잭션 내에서 사용자 응답을 대기하는 것을 회피함으로써 트랜잭션을 짧게 유지한다.")]),v._v(" "),a("li",[v._v("애플리케이션에서 질의를 실행하고 그 결과를 읽고, 첫 번째 결과에 따라 다른 질의를 실행할 수 도 있다.")]),v._v(" "),a("li",[v._v("이러한 상호작용식 트랜잭션을 데이터베이스에서 동시성을 허용하지 않으면 처리량은 끔직해 질 것 이다.")]),v._v(" "),a("li",[v._v("트랜잭션 코드 전체를 스토어드 프로시저 형태로 데이터베이스에 미리 제출하여 사용할 수 있다.")])]),v._v(" "),a("h4",{attrs:{id:"스토어드-프로시저의-장단점"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#스토어드-프로시저의-장단점"}},[v._v("#")]),v._v(" 스토어드 프로시저의 장단점")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스 벤더마다 제각각 스토어드 프로시저용 언어가 있다.")]),v._v(" "),a("li",[v._v("데이터베이스에서 실행되는 코드는 관리하기 어렵다.")]),v._v(" "),a("li",[v._v("데이터베이스 인스턴스 하나를 공유하기 때문에 잘못 작성된 스토어드 프로시저는 서버에 훨씬 민감하다.")])]),v._v(" "),a("h4",{attrs:{id:"파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파티셔닝"}},[v._v("#")]),v._v(" 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝할 수 있다면 각 파티셔닝은 다른 파티션과 독립적으로 실행되므로 처리량을 높일 수 있다.")]),v._v(" "),a("li",[v._v("그러나 여러 파티션에 접근해야 하는 트랜잭션이 있다면 해당 트랜잭션이 접근하는 모든 타피션에 걸쳐서 코디네이션을 해야하므로 엄청나게 느려진다.")])]),v._v(" "),a("h4",{attrs:{id:"직렬-실행-요약"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#직렬-실행-요약"}},[v._v("#")]),v._v(" 직렬 실행 요약")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션은 작고 빨라야 한다. 느린 트랜잭션이 모든 트랜잭션 처리를 지연시킬 수 있기 때문이다.")]),v._v(" "),a("li",[v._v("활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.")]),v._v(" "),a("li",[v._v("쓰기 처리량이 단일 CPU 코어에서 처리할 수 정도로 충분히 낮아야 한다.")]),v._v(" "),a("li",[v._v("여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 엄격한 제한이 있다.")])]),v._v(" "),a("h3",{attrs:{id:"_2단계-잠금-2pl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2단계-잠금-2pl"}},[v._v("#")]),v._v(" 2단계 잠금(2PL)")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스 직렬성을 구현하는데 널리 쓰인 유일한 알고리즘이다.")]),v._v(" "),a("li",[v._v("트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰기를 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다.(B가 A 몰래 갑자기 객체를 변경하지 못하도록 보장된다.)")]),v._v(" "),a("li",[v._v("트랜잭션 A가 객체에 썻고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다.")])]),v._v(" "),a("aside",[v._v("\n💡 2단게 잠금(2PL)과 2단계 커밋(two-phase commit, 2PC)은 아주 비슷하게 들리지만 완전히 다르다.\n")]),v._v(" "),a("h4",{attrs:{id:"_2단계-잠금-구현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2단계-잠금-구현"}},[v._v("#")]),v._v(" 2단계 잠금 구현")]),v._v(" "),a("ul",[a("li",[v._v("2PL은 마이SQL 서버에서 직렬성 격리 수준을 구현하는데 사용된다.")]),v._v(" "),a("li",[v._v("읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체의 잠금을 사용해 구현한다.\n"),a("ul",[a("li",[v._v("트랜잭션이 객체를 읽기를 원한다면 먼저 공유 모드로 잠금을 획득해야 한다. 동시에 여러 트랜잭션이 공유 모드로 잠금을 획득하는 것은 허용되지만 만약 그 객체에 이미 독점 모드로 잠금을 획든한 트랜잭션이 있으면 이 트랜잭션이 완료될 때까지 기다려야 한다.")]),v._v(" "),a("li",[v._v("트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 한다. 다른 어떤 트랜잭션도 동시에 작므을 획득할 수 없으므로 그 객체에 작믁ㅁ이 존재한다면 트랜잭션은 대기해야 한다.")]),v._v(" "),a("li",[v._v("트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드해야 한다. 업그레이드는 독점 잠금을 직접 획득할 때와 똑같이 동작한다.")]),v._v(" "),a("li",[v._v("트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될때 까지 잠금을 갖고 있어야 한다. 2PL의 첫 번째 단계는 잠금을 획득할 때이고 두 번째 단계는 모든 잠금을 해제할 때다.")]),v._v(" "),a("li",[v._v("트랜잭션이 서로 잠금을 해제하기를 기다리느라 멈춰 있는 상황을 "),a("code",[v._v("교착 상태")]),v._v("라고 한다.")])])])]),v._v(" "),a("h3",{attrs:{id:"직렬성-스냅숏-격리-serializable-snapshot-isolation-ssi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#직렬성-스냅숏-격리-serializable-snapshot-isolation-ssi"}},[v._v("#")]),v._v(" 직렬성 스냅숏 격리(Serializable Snapshot Isolation, SSI)")]),v._v(" "),a("ul",[a("li",[v._v("직렬성 격리와 좋은 성능이 공종하는 "),a("code",[v._v("직렬성 스냅숏 격리")]),v._v("라는 알고리즘이 유망하다.")])]),v._v(" "),a("h4",{attrs:{id:"비관적-동시성-제어-대-낙관적-동시성-제어"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#비관적-동시성-제어-대-낙관적-동시성-제어"}},[v._v("#")]),v._v(" 비관적 동시성 제어 대 낙관적 동시성 제어")]),v._v(" "),a("ul",[a("li",[v._v("2단계 잠금은 "),a("code",[v._v("비관적")]),v._v(" 동시성 제어 메커니즘이다.\n"),a("ul",[a("li",[v._v("뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 한다.")])])]),v._v(" "),a("li",[v._v("직렬성 스냅숏 격리는 "),a("code",[v._v("낙관적")]),v._v(" 동시성 제어 기법이다.\n"),a("ul",[a("li",[v._v("트랜잭션이 커밋되기를 원할 때 데이터베이스는 격리가 위반됐는지 확인한다.")]),v._v(" "),a("li",[v._v("만약 그렇다면 트랜잭션은 어보트되고 재시도해야 한다.")])])]),v._v(" "),a("li",[v._v("낙관적 동시성 제어는 경쟁이 심하면 어보트시켜야 할 트랜잭션의 비율이 높아지므로 성능이 떨어진다.")]),v._v(" "),a("li",[v._v("예비 용량이 충분하고 트랜잭션 사이의 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있다.")]),v._v(" "),a("li",[a("code",[v._v("SSI")]),v._v("는 스냅숏 격리를 기반으로 한다. 모든 읽기의 데이터는 데이터베이스의 일관된 스냅숏을 보게 된다.")])]),v._v(" "),a("h2",{attrs:{id:"정리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#정리"}},[v._v("#")]),v._v(" 정리")]),v._v(" "),a("h4",{attrs:{id:"동시성-제어를-위한-격리-수준"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#동시성-제어를-위한-격리-수준"}},[v._v("#")]),v._v(" 동시성 제어를 위한 격리 수준")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("더티 읽기")]),v._v(" "),a("ul",[a("li",[v._v("한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 읽는다. 커밋 후 읽기 또는 그보다 강한 격리 수준은 더티 읽기를 방지한다.")])])]),v._v(" "),a("li",[a("strong",[v._v("더티 쓰기")]),v._v(" "),a("ul",[a("li",[v._v("한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 덮어쓴다. 거의 모든 트랜잭션 구현은 더티 쓰기를 방지한다.")])])]),v._v(" "),a("li",[a("strong",[v._v("읽기 스큐(반복 읽기)")]),v._v(" "),a("ul",[a("li",[v._v("클라이언트는 다른 시점에 데이터베이스의 다른 부분을 본다. 이 문제를 막기 위해 어느 시점의 일관된 스냅숏으로부터 읽는 스냅숏 격리를 가장 흔히 사용한다.")])])]),v._v(" "),a("li",[a("strong",[v._v("갱신 손실")]),v._v(" "),a("ul",[a("li",[v._v("두 클라이언트가 동시에 "),a("code",[v._v("read-modify-write")]),v._v(" 주기를 실행한다. 다른 트랜잭션의 변경을 포함하지 않은 채로 쓴 내용을 덮어써서 데이터 손실이 일어난다.")])])]),v._v(" "),a("li",[a("strong",[v._v("쓰기 스큐")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 데이터베이스에 쓴다. 그러나  쓰기를 실행하는 시점에는 결정의 전체가 더 이상 참이 아니다. 직렬성 격리만 이런 이상 현상을 막을 수 있다.")])])]),v._v(" "),a("li",[a("strong",[v._v("팬텀 읽기")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행한다.")])])])]),v._v(" "),a("h4",{attrs:{id:"직렬성-트랜잭션을-구현하는-방법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#직렬성-트랜잭션을-구현하는-방법"}},[v._v("#")]),v._v(" 직렬성 트랜잭션을 구현하는 방법")]),v._v(" "),a("ul",[a("li",[v._v("트랜잭션을 순서대로 실행하기\n"),a("ul",[a("li",[v._v("트랜잭션의 실행 시간이 아주 짧고 트랜잭션 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 트랜잭션 처리량이 낮다면 아주 간단하고 효과적인 선택이다.")])])]),v._v(" "),a("li",[v._v("2단계 잠금\n"),a("ul",[a("li",[v._v("수십년 동안 직렬성을 구현하는 표준적인 방법이지만 성능 특성 때문에 사용을 피하는 애플리케이션이 많다.")])])]),v._v(" "),a("li",[v._v("직렬성 스냅숏 격리\n"),a("ul",[a("li",[v._v("낙관적 방법을 사용해서 트랜잭션이 차단되지 않고 진행할 수 있게 한다. 트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬적이지 않으면 어보트시킨다.")])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);