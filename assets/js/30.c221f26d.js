(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{428:function(v,_,a){"use strict";a.r(_);var t=a(21),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"파티셔닝과-복제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파티셔닝과-복제"}},[v._v("#")]),v._v(" 파티셔닝과 복제")]),v._v(" "),a("ul",[a("li",[v._v("데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로 부족하고 데이터를 파티션으로 쪼갤 필요가 있다. 이 작업을 "),a("code",[v._v("샤딩")]),v._v("이라고 한다.")]),v._v(" "),a("li",[v._v("파티션을 나눌 때는 보통 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 한다.")]),v._v(" "),a("li",[v._v("데이터 파티셔닝을 원하는 주된 이유는 "),a("strong",[v._v("확장성")]),v._v("이다.")]),v._v(" "),a("li",[v._v("보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.")])]),v._v(" "),a("aside",[v._v("\n💡 몽고DB, 엘라스틱서치, 솔라클라우드의 샤드(shared), HBase에서는 리전(region), 빅테이블에서는 태블릿(tablet), 카산드라, 리악에서는 브이노드(vnode), 카우치베이스에서는 브이버켓(vBucket)이라 부른다.\n")]),v._v(" "),a("h2",{attrs:{id:"키-값-데이터-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#키-값-데이터-파티셔닝"}},[v._v("#")]),v._v(" 키-값 데이터 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.")]),v._v(" "),a("li",[v._v("파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 "),a("strong",[v._v("쏠렸다(skewed)")]),v._v(" 고 말한다.")]),v._v(" "),a("li",[v._v("불균형하게 부하가 높은 파티션을 "),a("code",[v._v("핫스팟")]),v._v("이라고 한다.")]),v._v(" "),a("li",[v._v("어떤 레코드를 어느 노드에 저장해야 할까?")])]),v._v(" "),a("h3",{attrs:{id:"키-범위-기준-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#키-범위-기준-파티셔닝"}},[v._v("#")]),v._v(" 키 범위 기준 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("종이 백과사전처럼 각 파티션에 연속된 범위의 키를 할당한다.")]),v._v(" "),a("li",[v._v("각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다.")]),v._v(" "),a("li",[v._v("키 범위의 경계는 데이터에 맞춰 조정해야 한다. 데이터가 키 경계별로 고르게 분포하지 않을 수도 있기 때문이다.")]),v._v(" "),a("li",[v._v("키 범위 기준 파티셔닝은 접근 패턴이 핫스팟을 유발할 수도 있다.\n"),a("ul",[a("li",[v._v("특정 키에만 부하가 물려 해당 파티션만 과부하가 걸리고 나머지 파티션은 유휴 상태로 남아 있을 수 있다.")])])]),v._v(" "),a("li",[v._v("빅테이블, HBase, 리싱크DB, 2.4버전 이전의 몽고DB에서 사용된다.")])]),v._v(" "),a("h3",{attrs:{id:"키의-해시값-기준-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#키의-해시값-기준-파티셔닝"}},[v._v("#")]),v._v(" 키의 해시값 기준 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("쏠림과 핫스팟의 위험ㄷ 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는데 해시 함수를 사용한다.")]),v._v(" "),a("li",[v._v("카산드라와 몽고DB는 MD5를 사용한다.")]),v._v(" "),a("li",[v._v("각 파티션에 해시값 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당하면 된다.")]),v._v(" "),a("li",[v._v("키의 해시값을 사용해서 파티셔닝을 하면 정렬 순서가 유지되지 않아 범위 질의를 처리하는데 불리해진다.")]),v._v(" "),a("li",[v._v("리악, 카우치베이스,볼트모트에서는 기본키에 대한 범위 질의가 지원되지 않는다.")]),v._v(" "),a("li",[v._v("카산드라는 두 가지 파티셔닝 전략 모두 사용한다.\n"),a("ul",[a("li",[v._v("카산드라에서 테이블을 선언할 때 여러 컬럼을 포함하는 "),a("strong",[v._v("복합키")]),v._v("를 지정할 수 있다.")]),v._v(" "),a("li",[v._v("키의 첫 부분만 해싱을 적용하고 나머지 컬럼은 SS테이블에서 데이터를 정렬하는 색인을 사용한다.")]),v._v(" "),a("li",[v._v("첫 번째 컬럼에 대해서는 범위 질의를 쓸 수 없지만, 첫 번째 컬럼을 고정된 값으로 지정하면 다른 컬럼에 대해서는 범위 스캔을 수행할 수 있다.")])])])]),v._v(" "),a("h3",{attrs:{id:"쏠린-작업부하와-핫스팟-완화"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#쏠린-작업부하와-핫스팟-완화"}},[v._v("#")]),v._v(" 쏠린 작업부하와 핫스팟 완화")]),v._v(" "),a("ul",[a("li",[v._v("해시값 기준 파티셔닝은 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다.")]),v._v(" "),a("li",[v._v("현대 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야 한다.\n"),a("ul",[a("li",[v._v("예를 들어, 요청이 쏠리는 키를 발견했을 때, 임의의 숫자 2개만 붙이더라도 작업이 100개의 다른 키로 균등하게 분산된다.")]),v._v(" "),a("li",[v._v("어떤 키가 쪼개졌는지 추적할 방법도 있어야 한다.")])])])]),v._v(" "),a("h2",{attrs:{id:"파티셔닝과-보조-색인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파티셔닝과-보조-색인"}},[v._v("#")]),v._v(" 파티셔닝과 보조 색인")]),v._v(" "),a("ul",[a("li",[v._v("보조 색인은 보통 특정한 값이 발생한 항목을 검색하는 수단이다.")]),v._v(" "),a("li",[v._v("보조 색인은 관계형 데이터베이스의 핵심 요소이며 솔라나 엘라스틱서치 같은 검색 서버에게는 "),a("strong",[v._v("존재의 이유")]),v._v("다.")]),v._v(" "),a("li",[v._v("보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다.")])]),v._v(" "),a("h3",{attrs:{id:"문서-기준-보조-색인-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#문서-기준-보조-색인-파티셔닝"}},[v._v("#")]),v._v(" 문서 기준 보조 색인 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("고유 ID 기준으로 문서를 파티셔닝한다.")]),v._v(" "),a("li",[v._v("각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다.")]),v._v(" "),a("li",[v._v("데이터베이스에서 문서 추가, 삭제, 갱신 등의 쓰기 작업을 실행할 때는 쓰려고 하는 문서 ID를 포함하는 파티션만 다루면 된다.")]),v._v(" "),a("li",[v._v("그러한 까닭에 문서 파티셔닝 색인은 "),a("code",[v._v("지역 색인(local index)")]),v._v(" 라도도 부른다.")]),v._v(" "),a("li",[v._v("보조 색인의 모든 데이터가 한 파티셔닝에 없을 수도 있다. 따라서 모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.")]),v._v(" "),a("li",[v._v("이런식의 질의를 보내는 방법을 "),a("code",[v._v("스캐터/개더(scatter/gather)")]),v._v("라고 한다.")]),v._v(" "),a("li",[v._v("몽고DB, 리악, 카산드라, 엘라스틱서치, 솔라클라우드, 볼트DB는 모두 문서 기준 보조 색인을 사용한다.")])]),v._v(" "),a("h3",{attrs:{id:"용어-기준-보조-색인-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#용어-기준-보조-색인-파티셔닝"}},[v._v("#")]),v._v(" 용어 기준 보조 색인 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("예를 들어 보조 색인의 a-r 까지의 글자로 시작하면 파티션 0에, s-z까지의 글자로 시작하는 색깔은 파티션 1에 저장되도록 파티셔닝한다.")]),v._v(" "),a("li",[v._v("찾고자 하는 용어에 따라 색인의 파티션이 결정되므로 이런 식의 색인을 용어 기준으로 파티셔닝됐다라고 한다.")]),v._v(" "),a("li",[a("strong",[v._v("용어")]),v._v("라는 이름은 전문 색인에서 나왔는데 문서에 등장하는 모든 단어를 말한다.")]),v._v(" "),a("li",[v._v("문서 파티셔닝 색인에 비해 "),a("code",[v._v("전역(용여 파티셔닝)")]),v._v(" 색인이 갖는 이점은 읽기가 효율적이라는 것이다.")]),v._v(" "),a("li",[v._v("하지만 전역 색인은 쓰기가 느리고 복잡하다는 단점이 있다.")]),v._v(" "),a("li",[v._v("단일 문서를 쓸 때 해당 색인의 여러 파티셔네 영향을 줄 수 있기 때문이다.")]),v._v(" "),a("li",[v._v("현실에서는 전역 보조 색인은 대게 비동기로 갱신된다.\n"),a("ul",[a("li",[v._v("아마존 다이나모DB는 정상적인 상황에는 전역 보조 색인을 갱신하는데 1초도 안걸린다.")])])])]),v._v(" "),a("h2",{attrs:{id:"파티션-재균형화"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파티션-재균형화"}},[v._v("#")]),v._v(" 파티션 재균형화")]),v._v(" "),a("ul",[a("li",[v._v("시간이 지나면 데이터베이스에 변화가 생긴다.\n"),a("ul",[a("li",[v._v("질의 처리량이 증가해서 늘어난 부하를 처리하기 위해 CPU를 추가하고 싶다.")]),v._v(" "),a("li",[v._v("데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가하고 싶다.")]),v._v(" "),a("li",[v._v("장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비가 넘겨받아야 한다.")])])]),v._v(" "),a("li",[v._v("이런 변화가 생기면 데이터 요청이 한 노드에서 다른 노드로 옮겨야 하는데 이런 과정을 "),a("code",[v._v("재균형화(rebalancing)")]),v._v("라고 한다.")]),v._v(" "),a("li",[v._v("재균형화가 실행될 때 만족시킬 것으로 기대되는 최소 요구사항이 있다.\n"),a("ul",[a("li",[v._v("재균형화 후, 부하가 노드 사이에 균등하게 분배돼야 한다.")]),v._v(" "),a("li",[v._v("재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받으들여야 한다.")]),v._v(" "),a("li",[v._v("재균형화가 빨리 샐행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안된다.")])])])]),v._v(" "),a("h3",{attrs:{id:"재균형화-전략"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#재균형화-전략"}},[v._v("#")]),v._v(" 재균형화 전략")]),v._v(" "),a("h4",{attrs:{id:"쓰면-안되는-방법-해시값에-모드-n연산을-실행"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#쓰면-안되는-방법-해시값에-모드-n연산을-실행"}},[v._v("#")]),v._v(" 쓰면 안되는 방법: 해시값에 모드 N연산을 실행")]),v._v(" "),a("ul",[a("li",[v._v("해시값에 "),a("code",[v._v("mod")]),v._v(" 연산을 쓰게 되면 노드 개수 N이 바꾸면 대부분의 키가 노드 사이에 옮겨져야 한다는 점이다.")]),v._v(" "),a("li",[v._v("키가 자주 이동하면 재균형화 비용이 지나치게 커진다.")])]),v._v(" "),a("h4",{attrs:{id:"파티션-개수-고정"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파티션-개수-고정"}},[v._v("#")]),v._v(" 파티션 개수 고정")]),v._v(" "),a("ul",[a("li",[v._v("파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당하는 것이다.")]),v._v(" "),a("li",[v._v("클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션 몇개를 뻇어올 수 있다.")]),v._v(" "),a("li",[v._v("파티션은 노드 사이에서 통째로 이동하기만 한다. 파티션 개수는 바뀌지 않고 파티션에 할당된 키도 변경되지 않는다.")]),v._v(" "),a("li",[v._v("이 방식을 사용할 때는 보통 데이터베이스가 처음 구축될 때 파티션 개수가 고정되고 이후에 변하지 않는다.")]),v._v(" "),a("li",[v._v("파티션을 쪼개거나 합치는게 가능하지만 운영성 어려움이 많아 처음 설정하는 파티션 개수가 사용 가능한 노드 대수의 최대치가 되므로 미래에 증가될 것을 수용하기에 충분히 높은 값을 선택해야 한다.")]),v._v(" "),a("li",[v._v("파티션이 너무 크면 재균형화를 실행할 때와 노드 장애로부터 복구할 때 비용이 크다. 파티션이 너무 작으면 오버헤드가 너무 커진다.")]),v._v(" "),a("li",[v._v("파티션 크기가 적당할 때 성능이 가장 좋지만 파티션 개수는 고정돼 있고 데이터셋 크기는 변한다면 적절한 크기를 정하기 어렵다.")])]),v._v(" "),a("h4",{attrs:{id:"동적-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#동적-파티셔닝"}},[v._v("#")]),v._v(" 동적 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("키 범위 파티셔닝에서 파티션의 경계와 개수가 고정돼 있는게 매우 불편하다. 이런 이유로 파티션을 동적으로 만든다.")]),v._v(" "),a("li",[v._v("파티션 크기가 설정된 값을 넘어서면 파티션을 두 개로 쪼개 각각에 원래 파티션의 절반 정도의 데이터가 포함되게 한다.")]),v._v(" "),a("li",[v._v("반대로 데이터가 많이 삭제되어 파티션 크기가 임계값 아래로 떨어지면 인접한 파티션과 합쳐질 수 있다.")]),v._v(" "),a("li",[v._v("큰 파티션이 쪼개진 후 부하의 균형을 맞추기 위해 분할된 파티션 중 하나가 다른 노드로 이동될 수 있다.")]),v._v(" "),a("li",[v._v("동적 파티셔닝은 파티션 개수가 전체 데이터에 맞춰 조정된다는 이점이 있다.\n"),a("ul",[a("li",[v._v("단, 데이터 셋이 작을 때는 모든 쓰기 요청이 하나의 노드에서 실행되고 다른 노드들은 유휴 상태에 머물게 된다.")]),v._v(" "),a("li",[v._v("이 문제를 완하하기 위해서 몽고DB에서는 초기 파티션 집합을 설정할 수 있게 한다. (사전분할이라고 부른다)")])])]),v._v(" "),a("li",[v._v("동적 파티셔닝은 커 범위 파티셔닝뿐만 아니라 해시 파티셔닝에서도 똑같이 사용될 수 있다.")])]),v._v(" "),a("h4",{attrs:{id:"노드-비례-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#노드-비례-파티셔닝"}},[v._v("#")]),v._v(" 노드 비례 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("카산드라와 케타마에서 사용되는 방법은 파티션 개수가 노드 대수에 비례하게 하는 것이다.")]),v._v(" "),a("li",[v._v("노드 대수가 변함 없는 동안은 개별 파티션 크기가 데이터셋 크기에 비례해서 증가하지만 노드 대수를 늘리면 파티션 크기는 다시 작아진다.")]),v._v(" "),a("li",[v._v("새 노드가 클러스터에 추가되면 고정된 개수의 파티션을 무작위로 선택해 분할하고 각 분할된 파티션의 절반은 그대로 두고 절반은 새 노드에 할당한다.")])]),v._v(" "),a("h3",{attrs:{id:"운영-자동-재균형화와-수동-재균형화"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#운영-자동-재균형화와-수동-재균형화"}},[v._v("#")]),v._v(" 운영: 자동 재균형화와 수동 재균형화")]),v._v(" "),a("ul",[a("li",[v._v("완전 자동 재균형화"),a("code",[v._v("(시스템이 자동으로 언제 파티션을 노드 사이에 이동할지 결정함)")]),v._v("와 완전 수동 재균형화"),a("code",[v._v("(관리자가 명시적으로 파티션을 노드에 할당하도록 설정하고 관리자가 재설정할 때만 파티션 할당이 변경됨)")]),v._v(" 사이에는 중간 지점이 있다.")]),v._v(" "),a("li",[v._v("카우치베이스, 리악, 볼드모트는 자동으로 파티션 할당을 제안하지만 반영되려면 관리자가 확정해야 한다.")]),v._v(" "),a("li",[v._v("완전 자동 개균형화는 유지보수에 손이 덜 가지만, 예측하기 어렵다.")])]),v._v(" "),a("h2",{attrs:{id:"요청-라우팅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#요청-라우팅"}},[v._v("#")]),v._v(" 요청 라우팅")]),v._v(" "),a("ul",[a("li",[v._v("클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속을 해야할까?\n"),a("ul",[a("li",[v._v("클라이언트가 아무 노드에 접속하게 한다.그 후, 요청을 처리할 노드로 전달해서 응답을 받는다.")]),v._v(" "),a("li",[v._v("클라이언트의 모든 요청을 라우팅 계층으로 먼저 보낸다. 라우팅 계층에서는 각 요청을 처리할 노드를 알아내고 그에 따라 해당 노드에 요청을 전달한다.")]),v._v(" "),a("li",[v._v("클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있게 한다.")])])]),v._v(" "),a("li",[v._v("모든 경우에 핵심 문제는 라우팅 결정을 내리는 구성요소"),a("code",[v._v("(노드 중 하나, 라우팅 계층, 클라이언트 측)")]),v._v("가 노드에 할당된 파티션의 변경 사항을 어떻게 아느냐다.")]),v._v(" "),a("li",[v._v("많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 주키퍼 같은 별도의 코디네이션 서비스를 사용한다.\n"),a("ul",[a("li",[v._v("각 노드는 주키퍼에 자신을 등록하고 주키퍼는 파티션과 노드 사이의 신뢰성 있는 할당 정보를 관리한다.")]),v._v(" "),a("li",[v._v("노드사 추가되거나 삭제되면 주키퍼는 라우팅 계층에 이를 알려서 라우터 정보를 최신화 한다.")]),v._v(" "),a("li",[v._v("HBase, 솔라클라우드, 카프카 등")])])]),v._v(" "),a("li",[a("code",[v._v("가십 프로토콜(gossip protocol)")]),v._v("을 사용해서 클러스터 상태 변화를 노드 사이에 전달하는 방식도 있다.\n"),a("ul",[a("li",[v._v("아무 노드나 요청을 받을 수 있고 요청을 받은 노드는 요청을 처리할 노드에게 요청을 전달한다.")]),v._v(" "),a("li",[v._v("이 모델은 데이터베이스 노드에 복잡성은 더하지만 주키퍼 같은 외부 코디네이션 서비스에 의존하지 않는다.")])])])]),v._v(" "),a("h3",{attrs:{id:"병렬-질의-실행"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#병렬-질의-실행"}},[v._v("#")]),v._v(" 병렬 질의 실행")]),v._v(" "),a("ul",[a("li",[v._v("지금까지는 단일 키를 읽거나 간단한 질의에 대해서만 설명했다.")]),v._v(" "),a("li",[v._v("그러나 분석용으로 자주 사용되는 "),a("code",[v._v("대규모 병렬 처리(MPP)")]),v._v(" 관계형 데이터 베이스 제품은 훨씬 더 복잡한 종류의 질의를 지원한다.")]),v._v(" "),a("li",[v._v("MPP 옵티마이저는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.")])]),v._v(" "),a("h2",{attrs:{id:"정리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#정리"}},[v._v("#")]),v._v(" 정리")]),v._v(" "),a("ul",[a("li",[v._v("저장과 처리할 데이터가 많아서 장비 한 대로 처리하는게 불가능해지면 파티셔닝이 필요하다.")]),v._v(" "),a("li",[v._v("파티셔닝의 목적은 핫스팟이 생기지 않게 하면서 데이터와 질의 부하를 여러 장비에 균일하게 분배하는 것이다.")]),v._v(" "),a("li",[v._v("그렇게 하려면 데이터에 적합한 파티셔닝 방식을 선택해야 하고 클러스터 노드에 추가되거나 제거될 때 파티션 재균형화를 실행해야 한다.")])]),v._v(" "),a("h3",{attrs:{id:"파티셔닝-기법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#파티셔닝-기법"}},[v._v("#")]),v._v(" 파티셔닝 기법")]),v._v(" "),a("h4",{attrs:{id:"키-범위-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#키-범위-파티셔닝"}},[v._v("#")]),v._v(" 키 범위 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("키가 정렬돼 있고 개별 파티션은 키 범위 경계에 속한다.")]),v._v(" "),a("li",[v._v("키가 정렬되어 있어 범위 질의에 효율적이지만 핫스팟이 생길 위험이 있다.")]),v._v(" "),a("li",[v._v("파티션이 너무 커지면 키 범위를 두 개로 쪼개 동적으로 재균형화를 실행한다.")])]),v._v(" "),a("h4",{attrs:{id:"해시-파티셔닝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해시-파티셔닝"}},[v._v("#")]),v._v(" 해시 파티셔닝")]),v._v(" "),a("ul",[a("li",[v._v("키에 해시 함수를 적용하여 키 범위 파티셔닝을 적용한다.")]),v._v(" "),a("li",[v._v("범위 질의에 비효율적이지만 부하를 더욱 균일하게 분산할 수 있다.")])]),v._v(" "),a("h3",{attrs:{id:"보조-파티셔닝-기법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#보조-파티셔닝-기법"}},[v._v("#")]),v._v(" 보조 파티셔닝 기법")]),v._v(" "),a("h4",{attrs:{id:"문서-파티셔닝-색인-지역-색인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#문서-파티셔닝-색인-지역-색인"}},[v._v("#")]),v._v(" 문서 파티셔닝 색인(지역 색인)")]),v._v(" "),a("ul",[a("li",[v._v("보조 색인을 기본키와 값이 저장된 파티션에 저장한다.")]),v._v(" "),a("li",[v._v("쓸 때는 파티션 하나만 갱신하면 되지만 보조 색인을 읽으려면 모든 파티션에 걸쳐서 스캐터/개더를 사용해야 한다.")])]),v._v(" "),a("h4",{attrs:{id:"용어-파티셔닝-색인-전역-색인"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#용어-파티셔닝-색인-전역-색인"}},[v._v("#")]),v._v(" 용어 파티셔닝 색인(전역 색인)")]),v._v(" "),a("ul",[a("li",[v._v("색인된 값을 사용해서 보조 색인을 별도로 파티셔닝 한다.")]),v._v(" "),a("li",[v._v("문서를 쓸 때는 보조 색인 여러 개를 갱신해야 하지만 읽기는 단일 파티션에서 실행될 수 있다.")])])])}),[],!1,null,null,null);_.default=l.exports}}]);